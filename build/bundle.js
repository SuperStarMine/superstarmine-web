
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop$1() { }
    function assign$1(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop$1;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign$1($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);
    }
    function get_all_dirty_from_scope($$scope) {
        if ($$scope.ctx.length > 32) {
            const dirty = [];
            const length = $$scope.ctx.length / 32;
            for (let i = 0; i < length; i++) {
                dirty[i] = -1;
            }
            return dirty;
        }
        return -1;
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop$1;
    }
    function append$2(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text$1(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text$1(' ');
    }
    function empty$1() {
        return text$1('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr$1(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr$1(node, key, attributes[key]);
            }
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function children$2(element) {
        return Array.from(element.childNodes);
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail, bubbles = false) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, false, detail);
        return e;
    }
    class HtmlTag {
        constructor() {
            this.e = this.n = null;
        }
        c(html) {
            this.h(html);
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.c(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update$1(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update$1($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind$1(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = on_mount.map(run).filter(is_function);
                if (on_destroy) {
                    on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop$1,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children$2(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop$1;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.43.0' }, detail), true));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append$2(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr$1(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap$1(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop$1) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop$1) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop$1;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop$1;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop$1;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function parse$1(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/.pnpm/svelte-spa-router@3.2.0/node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.43.0 */

    const { Error: Error_1, Object: Object_1$2, console: console_1$1 } = globals;

    // (251:0) {:else}
    function create_else_block$8(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(251:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (244:0) {#if componentParams}
    function create_if_block$f(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign$1(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(244:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$f, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn('Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading');

    	return wrap$1({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location$1 = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);
    const params = writable(undefined);

    async function push$1(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link$1(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse$1(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.__svelte_spa_router_scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.__svelte_spa_router_scrollX, previousScrollState.__svelte_spa_router_scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	const writable_props = ['routes', 'prefix', 'restoreScrollState'];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		_wrap: wrap$1,
    		wrap,
    		getLocation,
    		loc,
    		location: location$1,
    		querystring,
    		params,
    		push: push$1,
    		pop,
    		replace,
    		link: link$1,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse: parse$1,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('componentParams' in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('previousScrollState' in $$props) previousScrollState = $$props.previousScrollState;
    		if ('popStateChanged' in $$props) popStateChanged = $$props.popStateChanged;
    		if ('lastLoc' in $$props) lastLoc = $$props.lastLoc;
    		if ('componentObj' in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const globalSettings = {
      standardWidths: [
        {
          mediaQuery: 'min-aspect-ratio: 16/9',
          value: 70
        },
        {
          mediaQuery: 'default',
          value: 80
        },
        {
          mediaQuery: 'max-aspect-ratio: 3/4',
          value: 90
        },
      ],
      imageDirectory: '/img/',
      imageExtensionsShort: ['webp', 'png'],
      imageSizes: [250, 500, 750, 1000, 1250, 1500, 1750, 2000],
      tinyImageSize: 15,
      tinyImageExtensionsShort: ['webp', 'jpg'],
      transitionDuration: 500, //ms
    };

    const sync = writable({});

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn) {
      var module = { exports: {} };
    	return fn(module, module.exports), module.exports;
    }

    var colorName$1 = {
    	"aliceblue": [240, 248, 255],
    	"antiquewhite": [250, 235, 215],
    	"aqua": [0, 255, 255],
    	"aquamarine": [127, 255, 212],
    	"azure": [240, 255, 255],
    	"beige": [245, 245, 220],
    	"bisque": [255, 228, 196],
    	"black": [0, 0, 0],
    	"blanchedalmond": [255, 235, 205],
    	"blue": [0, 0, 255],
    	"blueviolet": [138, 43, 226],
    	"brown": [165, 42, 42],
    	"burlywood": [222, 184, 135],
    	"cadetblue": [95, 158, 160],
    	"chartreuse": [127, 255, 0],
    	"chocolate": [210, 105, 30],
    	"coral": [255, 127, 80],
    	"cornflowerblue": [100, 149, 237],
    	"cornsilk": [255, 248, 220],
    	"crimson": [220, 20, 60],
    	"cyan": [0, 255, 255],
    	"darkblue": [0, 0, 139],
    	"darkcyan": [0, 139, 139],
    	"darkgoldenrod": [184, 134, 11],
    	"darkgray": [169, 169, 169],
    	"darkgreen": [0, 100, 0],
    	"darkgrey": [169, 169, 169],
    	"darkkhaki": [189, 183, 107],
    	"darkmagenta": [139, 0, 139],
    	"darkolivegreen": [85, 107, 47],
    	"darkorange": [255, 140, 0],
    	"darkorchid": [153, 50, 204],
    	"darkred": [139, 0, 0],
    	"darksalmon": [233, 150, 122],
    	"darkseagreen": [143, 188, 143],
    	"darkslateblue": [72, 61, 139],
    	"darkslategray": [47, 79, 79],
    	"darkslategrey": [47, 79, 79],
    	"darkturquoise": [0, 206, 209],
    	"darkviolet": [148, 0, 211],
    	"deeppink": [255, 20, 147],
    	"deepskyblue": [0, 191, 255],
    	"dimgray": [105, 105, 105],
    	"dimgrey": [105, 105, 105],
    	"dodgerblue": [30, 144, 255],
    	"firebrick": [178, 34, 34],
    	"floralwhite": [255, 250, 240],
    	"forestgreen": [34, 139, 34],
    	"fuchsia": [255, 0, 255],
    	"gainsboro": [220, 220, 220],
    	"ghostwhite": [248, 248, 255],
    	"gold": [255, 215, 0],
    	"goldenrod": [218, 165, 32],
    	"gray": [128, 128, 128],
    	"green": [0, 128, 0],
    	"greenyellow": [173, 255, 47],
    	"grey": [128, 128, 128],
    	"honeydew": [240, 255, 240],
    	"hotpink": [255, 105, 180],
    	"indianred": [205, 92, 92],
    	"indigo": [75, 0, 130],
    	"ivory": [255, 255, 240],
    	"khaki": [240, 230, 140],
    	"lavender": [230, 230, 250],
    	"lavenderblush": [255, 240, 245],
    	"lawngreen": [124, 252, 0],
    	"lemonchiffon": [255, 250, 205],
    	"lightblue": [173, 216, 230],
    	"lightcoral": [240, 128, 128],
    	"lightcyan": [224, 255, 255],
    	"lightgoldenrodyellow": [250, 250, 210],
    	"lightgray": [211, 211, 211],
    	"lightgreen": [144, 238, 144],
    	"lightgrey": [211, 211, 211],
    	"lightpink": [255, 182, 193],
    	"lightsalmon": [255, 160, 122],
    	"lightseagreen": [32, 178, 170],
    	"lightskyblue": [135, 206, 250],
    	"lightslategray": [119, 136, 153],
    	"lightslategrey": [119, 136, 153],
    	"lightsteelblue": [176, 196, 222],
    	"lightyellow": [255, 255, 224],
    	"lime": [0, 255, 0],
    	"limegreen": [50, 205, 50],
    	"linen": [250, 240, 230],
    	"magenta": [255, 0, 255],
    	"maroon": [128, 0, 0],
    	"mediumaquamarine": [102, 205, 170],
    	"mediumblue": [0, 0, 205],
    	"mediumorchid": [186, 85, 211],
    	"mediumpurple": [147, 112, 219],
    	"mediumseagreen": [60, 179, 113],
    	"mediumslateblue": [123, 104, 238],
    	"mediumspringgreen": [0, 250, 154],
    	"mediumturquoise": [72, 209, 204],
    	"mediumvioletred": [199, 21, 133],
    	"midnightblue": [25, 25, 112],
    	"mintcream": [245, 255, 250],
    	"mistyrose": [255, 228, 225],
    	"moccasin": [255, 228, 181],
    	"navajowhite": [255, 222, 173],
    	"navy": [0, 0, 128],
    	"oldlace": [253, 245, 230],
    	"olive": [128, 128, 0],
    	"olivedrab": [107, 142, 35],
    	"orange": [255, 165, 0],
    	"orangered": [255, 69, 0],
    	"orchid": [218, 112, 214],
    	"palegoldenrod": [238, 232, 170],
    	"palegreen": [152, 251, 152],
    	"paleturquoise": [175, 238, 238],
    	"palevioletred": [219, 112, 147],
    	"papayawhip": [255, 239, 213],
    	"peachpuff": [255, 218, 185],
    	"peru": [205, 133, 63],
    	"pink": [255, 192, 203],
    	"plum": [221, 160, 221],
    	"powderblue": [176, 224, 230],
    	"purple": [128, 0, 128],
    	"rebeccapurple": [102, 51, 153],
    	"red": [255, 0, 0],
    	"rosybrown": [188, 143, 143],
    	"royalblue": [65, 105, 225],
    	"saddlebrown": [139, 69, 19],
    	"salmon": [250, 128, 114],
    	"sandybrown": [244, 164, 96],
    	"seagreen": [46, 139, 87],
    	"seashell": [255, 245, 238],
    	"sienna": [160, 82, 45],
    	"silver": [192, 192, 192],
    	"skyblue": [135, 206, 235],
    	"slateblue": [106, 90, 205],
    	"slategray": [112, 128, 144],
    	"slategrey": [112, 128, 144],
    	"snow": [255, 250, 250],
    	"springgreen": [0, 255, 127],
    	"steelblue": [70, 130, 180],
    	"tan": [210, 180, 140],
    	"teal": [0, 128, 128],
    	"thistle": [216, 191, 216],
    	"tomato": [255, 99, 71],
    	"turquoise": [64, 224, 208],
    	"violet": [238, 130, 238],
    	"wheat": [245, 222, 179],
    	"white": [255, 255, 255],
    	"whitesmoke": [245, 245, 245],
    	"yellow": [255, 255, 0],
    	"yellowgreen": [154, 205, 50]
    };

    var isArrayish = function isArrayish(obj) {
    	if (!obj || typeof obj === 'string') {
    		return false;
    	}

    	return obj instanceof Array || Array.isArray(obj) ||
    		(obj.length >= 0 && (obj.splice instanceof Function ||
    			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
    };

    var simpleSwizzle = createCommonjsModule(function (module) {



    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;

    var swizzle = module.exports = function swizzle(args) {
    	var results = [];

    	for (var i = 0, len = args.length; i < len; i++) {
    		var arg = args[i];

    		if (isArrayish(arg)) {
    			// http://jsperf.com/javascript-array-concat-vs-push/98
    			results = concat.call(results, slice.call(arg));
    		} else {
    			results.push(arg);
    		}
    	}

    	return results;
    };

    swizzle.wrap = function (fn) {
    	return function () {
    		return fn(swizzle(arguments));
    	};
    };
    });

    /* MIT license */

    var colorString = createCommonjsModule(function (module) {
    var reverseNames = {};

    // create a list of reverse color names
    for (var name in colorName$1) {
    	if (colorName$1.hasOwnProperty(name)) {
    		reverseNames[colorName$1[name]] = name;
    	}
    }

    var cs = module.exports = {
    	to: {},
    	get: {}
    };

    cs.get = function (string) {
    	var prefix = string.substring(0, 3).toLowerCase();
    	var val;
    	var model;
    	switch (prefix) {
    		case 'hsl':
    			val = cs.get.hsl(string);
    			model = 'hsl';
    			break;
    		case 'hwb':
    			val = cs.get.hwb(string);
    			model = 'hwb';
    			break;
    		default:
    			val = cs.get.rgb(string);
    			model = 'rgb';
    			break;
    	}

    	if (!val) {
    		return null;
    	}

    	return {model: model, value: val};
    };

    cs.get.rgb = function (string) {
    	if (!string) {
    		return null;
    	}

    	var abbr = /^#([a-f0-9]{3,4})$/i;
    	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
    	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
    	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
    	var keyword = /(\D+)/;

    	var rgb = [0, 0, 0, 1];
    	var match;
    	var i;
    	var hexAlpha;

    	if (match = string.match(hex)) {
    		hexAlpha = match[2];
    		match = match[1];

    		for (i = 0; i < 3; i++) {
    			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
    			var i2 = i * 2;
    			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
    		}

    		if (hexAlpha) {
    			rgb[3] = parseInt(hexAlpha, 16) / 255;
    		}
    	} else if (match = string.match(abbr)) {
    		match = match[1];
    		hexAlpha = match[3];

    		for (i = 0; i < 3; i++) {
    			rgb[i] = parseInt(match[i] + match[i], 16);
    		}

    		if (hexAlpha) {
    			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
    		}
    	} else if (match = string.match(rgba)) {
    		for (i = 0; i < 3; i++) {
    			rgb[i] = parseInt(match[i + 1], 0);
    		}

    		if (match[4]) {
    			rgb[3] = parseFloat(match[4]);
    		}
    	} else if (match = string.match(per)) {
    		for (i = 0; i < 3; i++) {
    			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
    		}

    		if (match[4]) {
    			rgb[3] = parseFloat(match[4]);
    		}
    	} else if (match = string.match(keyword)) {
    		if (match[1] === 'transparent') {
    			return [0, 0, 0, 0];
    		}

    		rgb = colorName$1[match[1]];

    		if (!rgb) {
    			return null;
    		}

    		rgb[3] = 1;

    		return rgb;
    	} else {
    		return null;
    	}

    	for (i = 0; i < 3; i++) {
    		rgb[i] = clamp(rgb[i], 0, 255);
    	}
    	rgb[3] = clamp(rgb[3], 0, 1);

    	return rgb;
    };

    cs.get.hsl = function (string) {
    	if (!string) {
    		return null;
    	}

    	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?[\d\.]+)\s*)?\)$/;
    	var match = string.match(hsl);

    	if (match) {
    		var alpha = parseFloat(match[4]);
    		var h = (parseFloat(match[1]) + 360) % 360;
    		var s = clamp(parseFloat(match[2]), 0, 100);
    		var l = clamp(parseFloat(match[3]), 0, 100);
    		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

    		return [h, s, l, a];
    	}

    	return null;
    };

    cs.get.hwb = function (string) {
    	if (!string) {
    		return null;
    	}

    	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
    	var match = string.match(hwb);

    	if (match) {
    		var alpha = parseFloat(match[4]);
    		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
    		var w = clamp(parseFloat(match[2]), 0, 100);
    		var b = clamp(parseFloat(match[3]), 0, 100);
    		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
    		return [h, w, b, a];
    	}

    	return null;
    };

    cs.to.hex = function () {
    	var rgba = simpleSwizzle(arguments);

    	return (
    		'#' +
    		hexDouble(rgba[0]) +
    		hexDouble(rgba[1]) +
    		hexDouble(rgba[2]) +
    		(rgba[3] < 1
    			? (hexDouble(Math.round(rgba[3] * 255)))
    			: '')
    	);
    };

    cs.to.rgb = function () {
    	var rgba = simpleSwizzle(arguments);

    	return rgba.length < 4 || rgba[3] === 1
    		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
    		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
    };

    cs.to.rgb.percent = function () {
    	var rgba = simpleSwizzle(arguments);

    	var r = Math.round(rgba[0] / 255 * 100);
    	var g = Math.round(rgba[1] / 255 * 100);
    	var b = Math.round(rgba[2] / 255 * 100);

    	return rgba.length < 4 || rgba[3] === 1
    		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
    		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
    };

    cs.to.hsl = function () {
    	var hsla = simpleSwizzle(arguments);
    	return hsla.length < 4 || hsla[3] === 1
    		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
    		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
    };

    // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
    // (hwb have alpha optional & 1 is default value)
    cs.to.hwb = function () {
    	var hwba = simpleSwizzle(arguments);

    	var a = '';
    	if (hwba.length >= 4 && hwba[3] !== 1) {
    		a = ', ' + hwba[3];
    	}

    	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
    };

    cs.to.keyword = function (rgb) {
    	return reverseNames[rgb.slice(0, 3)];
    };

    // helpers
    function clamp(num, min, max) {
    	return Math.min(Math.max(min, num), max);
    }

    function hexDouble(num) {
    	var str = num.toString(16).toUpperCase();
    	return (str.length < 2) ? '0' + str : str;
    }
    });

    var colorName = {
    	"aliceblue": [240, 248, 255],
    	"antiquewhite": [250, 235, 215],
    	"aqua": [0, 255, 255],
    	"aquamarine": [127, 255, 212],
    	"azure": [240, 255, 255],
    	"beige": [245, 245, 220],
    	"bisque": [255, 228, 196],
    	"black": [0, 0, 0],
    	"blanchedalmond": [255, 235, 205],
    	"blue": [0, 0, 255],
    	"blueviolet": [138, 43, 226],
    	"brown": [165, 42, 42],
    	"burlywood": [222, 184, 135],
    	"cadetblue": [95, 158, 160],
    	"chartreuse": [127, 255, 0],
    	"chocolate": [210, 105, 30],
    	"coral": [255, 127, 80],
    	"cornflowerblue": [100, 149, 237],
    	"cornsilk": [255, 248, 220],
    	"crimson": [220, 20, 60],
    	"cyan": [0, 255, 255],
    	"darkblue": [0, 0, 139],
    	"darkcyan": [0, 139, 139],
    	"darkgoldenrod": [184, 134, 11],
    	"darkgray": [169, 169, 169],
    	"darkgreen": [0, 100, 0],
    	"darkgrey": [169, 169, 169],
    	"darkkhaki": [189, 183, 107],
    	"darkmagenta": [139, 0, 139],
    	"darkolivegreen": [85, 107, 47],
    	"darkorange": [255, 140, 0],
    	"darkorchid": [153, 50, 204],
    	"darkred": [139, 0, 0],
    	"darksalmon": [233, 150, 122],
    	"darkseagreen": [143, 188, 143],
    	"darkslateblue": [72, 61, 139],
    	"darkslategray": [47, 79, 79],
    	"darkslategrey": [47, 79, 79],
    	"darkturquoise": [0, 206, 209],
    	"darkviolet": [148, 0, 211],
    	"deeppink": [255, 20, 147],
    	"deepskyblue": [0, 191, 255],
    	"dimgray": [105, 105, 105],
    	"dimgrey": [105, 105, 105],
    	"dodgerblue": [30, 144, 255],
    	"firebrick": [178, 34, 34],
    	"floralwhite": [255, 250, 240],
    	"forestgreen": [34, 139, 34],
    	"fuchsia": [255, 0, 255],
    	"gainsboro": [220, 220, 220],
    	"ghostwhite": [248, 248, 255],
    	"gold": [255, 215, 0],
    	"goldenrod": [218, 165, 32],
    	"gray": [128, 128, 128],
    	"green": [0, 128, 0],
    	"greenyellow": [173, 255, 47],
    	"grey": [128, 128, 128],
    	"honeydew": [240, 255, 240],
    	"hotpink": [255, 105, 180],
    	"indianred": [205, 92, 92],
    	"indigo": [75, 0, 130],
    	"ivory": [255, 255, 240],
    	"khaki": [240, 230, 140],
    	"lavender": [230, 230, 250],
    	"lavenderblush": [255, 240, 245],
    	"lawngreen": [124, 252, 0],
    	"lemonchiffon": [255, 250, 205],
    	"lightblue": [173, 216, 230],
    	"lightcoral": [240, 128, 128],
    	"lightcyan": [224, 255, 255],
    	"lightgoldenrodyellow": [250, 250, 210],
    	"lightgray": [211, 211, 211],
    	"lightgreen": [144, 238, 144],
    	"lightgrey": [211, 211, 211],
    	"lightpink": [255, 182, 193],
    	"lightsalmon": [255, 160, 122],
    	"lightseagreen": [32, 178, 170],
    	"lightskyblue": [135, 206, 250],
    	"lightslategray": [119, 136, 153],
    	"lightslategrey": [119, 136, 153],
    	"lightsteelblue": [176, 196, 222],
    	"lightyellow": [255, 255, 224],
    	"lime": [0, 255, 0],
    	"limegreen": [50, 205, 50],
    	"linen": [250, 240, 230],
    	"magenta": [255, 0, 255],
    	"maroon": [128, 0, 0],
    	"mediumaquamarine": [102, 205, 170],
    	"mediumblue": [0, 0, 205],
    	"mediumorchid": [186, 85, 211],
    	"mediumpurple": [147, 112, 219],
    	"mediumseagreen": [60, 179, 113],
    	"mediumslateblue": [123, 104, 238],
    	"mediumspringgreen": [0, 250, 154],
    	"mediumturquoise": [72, 209, 204],
    	"mediumvioletred": [199, 21, 133],
    	"midnightblue": [25, 25, 112],
    	"mintcream": [245, 255, 250],
    	"mistyrose": [255, 228, 225],
    	"moccasin": [255, 228, 181],
    	"navajowhite": [255, 222, 173],
    	"navy": [0, 0, 128],
    	"oldlace": [253, 245, 230],
    	"olive": [128, 128, 0],
    	"olivedrab": [107, 142, 35],
    	"orange": [255, 165, 0],
    	"orangered": [255, 69, 0],
    	"orchid": [218, 112, 214],
    	"palegoldenrod": [238, 232, 170],
    	"palegreen": [152, 251, 152],
    	"paleturquoise": [175, 238, 238],
    	"palevioletred": [219, 112, 147],
    	"papayawhip": [255, 239, 213],
    	"peachpuff": [255, 218, 185],
    	"peru": [205, 133, 63],
    	"pink": [255, 192, 203],
    	"plum": [221, 160, 221],
    	"powderblue": [176, 224, 230],
    	"purple": [128, 0, 128],
    	"rebeccapurple": [102, 51, 153],
    	"red": [255, 0, 0],
    	"rosybrown": [188, 143, 143],
    	"royalblue": [65, 105, 225],
    	"saddlebrown": [139, 69, 19],
    	"salmon": [250, 128, 114],
    	"sandybrown": [244, 164, 96],
    	"seagreen": [46, 139, 87],
    	"seashell": [255, 245, 238],
    	"sienna": [160, 82, 45],
    	"silver": [192, 192, 192],
    	"skyblue": [135, 206, 235],
    	"slateblue": [106, 90, 205],
    	"slategray": [112, 128, 144],
    	"slategrey": [112, 128, 144],
    	"snow": [255, 250, 250],
    	"springgreen": [0, 255, 127],
    	"steelblue": [70, 130, 180],
    	"tan": [210, 180, 140],
    	"teal": [0, 128, 128],
    	"thistle": [216, 191, 216],
    	"tomato": [255, 99, 71],
    	"turquoise": [64, 224, 208],
    	"violet": [238, 130, 238],
    	"wheat": [245, 222, 179],
    	"white": [255, 255, 255],
    	"whitesmoke": [245, 245, 245],
    	"yellow": [255, 255, 0],
    	"yellowgreen": [154, 205, 50]
    };

    /* MIT license */

    var conversions = createCommonjsModule(function (module) {
    // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)

    var reverseKeywords = {};
    for (var key in colorName) {
    	if (colorName.hasOwnProperty(key)) {
    		reverseKeywords[colorName[key]] = key;
    	}
    }

    var convert = module.exports = {
    	rgb: {channels: 3, labels: 'rgb'},
    	hsl: {channels: 3, labels: 'hsl'},
    	hsv: {channels: 3, labels: 'hsv'},
    	hwb: {channels: 3, labels: 'hwb'},
    	cmyk: {channels: 4, labels: 'cmyk'},
    	xyz: {channels: 3, labels: 'xyz'},
    	lab: {channels: 3, labels: 'lab'},
    	lch: {channels: 3, labels: 'lch'},
    	hex: {channels: 1, labels: ['hex']},
    	keyword: {channels: 1, labels: ['keyword']},
    	ansi16: {channels: 1, labels: ['ansi16']},
    	ansi256: {channels: 1, labels: ['ansi256']},
    	hcg: {channels: 3, labels: ['h', 'c', 'g']},
    	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
    	gray: {channels: 1, labels: ['gray']}
    };

    // hide .channels and .labels properties
    for (var model in convert) {
    	if (convert.hasOwnProperty(model)) {
    		if (!('channels' in convert[model])) {
    			throw new Error('missing channels property: ' + model);
    		}

    		if (!('labels' in convert[model])) {
    			throw new Error('missing channel labels property: ' + model);
    		}

    		if (convert[model].labels.length !== convert[model].channels) {
    			throw new Error('channel and label counts mismatch: ' + model);
    		}

    		var channels = convert[model].channels;
    		var labels = convert[model].labels;
    		delete convert[model].channels;
    		delete convert[model].labels;
    		Object.defineProperty(convert[model], 'channels', {value: channels});
    		Object.defineProperty(convert[model], 'labels', {value: labels});
    	}
    }

    convert.rgb.hsl = function (rgb) {
    	var r = rgb[0] / 255;
    	var g = rgb[1] / 255;
    	var b = rgb[2] / 255;
    	var min = Math.min(r, g, b);
    	var max = Math.max(r, g, b);
    	var delta = max - min;
    	var h;
    	var s;
    	var l;

    	if (max === min) {
    		h = 0;
    	} else if (r === max) {
    		h = (g - b) / delta;
    	} else if (g === max) {
    		h = 2 + (b - r) / delta;
    	} else if (b === max) {
    		h = 4 + (r - g) / delta;
    	}

    	h = Math.min(h * 60, 360);

    	if (h < 0) {
    		h += 360;
    	}

    	l = (min + max) / 2;

    	if (max === min) {
    		s = 0;
    	} else if (l <= 0.5) {
    		s = delta / (max + min);
    	} else {
    		s = delta / (2 - max - min);
    	}

    	return [h, s * 100, l * 100];
    };

    convert.rgb.hsv = function (rgb) {
    	var rdif;
    	var gdif;
    	var bdif;
    	var h;
    	var s;

    	var r = rgb[0] / 255;
    	var g = rgb[1] / 255;
    	var b = rgb[2] / 255;
    	var v = Math.max(r, g, b);
    	var diff = v - Math.min(r, g, b);
    	var diffc = function (c) {
    		return (v - c) / 6 / diff + 1 / 2;
    	};

    	if (diff === 0) {
    		h = s = 0;
    	} else {
    		s = diff / v;
    		rdif = diffc(r);
    		gdif = diffc(g);
    		bdif = diffc(b);

    		if (r === v) {
    			h = bdif - gdif;
    		} else if (g === v) {
    			h = (1 / 3) + rdif - bdif;
    		} else if (b === v) {
    			h = (2 / 3) + gdif - rdif;
    		}
    		if (h < 0) {
    			h += 1;
    		} else if (h > 1) {
    			h -= 1;
    		}
    	}

    	return [
    		h * 360,
    		s * 100,
    		v * 100
    	];
    };

    convert.rgb.hwb = function (rgb) {
    	var r = rgb[0];
    	var g = rgb[1];
    	var b = rgb[2];
    	var h = convert.rgb.hsl(rgb)[0];
    	var w = 1 / 255 * Math.min(r, Math.min(g, b));

    	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

    	return [h, w * 100, b * 100];
    };

    convert.rgb.cmyk = function (rgb) {
    	var r = rgb[0] / 255;
    	var g = rgb[1] / 255;
    	var b = rgb[2] / 255;
    	var c;
    	var m;
    	var y;
    	var k;

    	k = Math.min(1 - r, 1 - g, 1 - b);
    	c = (1 - r - k) / (1 - k) || 0;
    	m = (1 - g - k) / (1 - k) || 0;
    	y = (1 - b - k) / (1 - k) || 0;

    	return [c * 100, m * 100, y * 100, k * 100];
    };

    /**
     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
     * */
    function comparativeDistance(x, y) {
    	return (
    		Math.pow(x[0] - y[0], 2) +
    		Math.pow(x[1] - y[1], 2) +
    		Math.pow(x[2] - y[2], 2)
    	);
    }

    convert.rgb.keyword = function (rgb) {
    	var reversed = reverseKeywords[rgb];
    	if (reversed) {
    		return reversed;
    	}

    	var currentClosestDistance = Infinity;
    	var currentClosestKeyword;

    	for (var keyword in colorName) {
    		if (colorName.hasOwnProperty(keyword)) {
    			var value = colorName[keyword];

    			// Compute comparative distance
    			var distance = comparativeDistance(rgb, value);

    			// Check if its less, if so set as closest
    			if (distance < currentClosestDistance) {
    				currentClosestDistance = distance;
    				currentClosestKeyword = keyword;
    			}
    		}
    	}

    	return currentClosestKeyword;
    };

    convert.keyword.rgb = function (keyword) {
    	return colorName[keyword];
    };

    convert.rgb.xyz = function (rgb) {
    	var r = rgb[0] / 255;
    	var g = rgb[1] / 255;
    	var b = rgb[2] / 255;

    	// assume sRGB
    	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
    	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
    	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

    	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
    	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
    	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

    	return [x * 100, y * 100, z * 100];
    };

    convert.rgb.lab = function (rgb) {
    	var xyz = convert.rgb.xyz(rgb);
    	var x = xyz[0];
    	var y = xyz[1];
    	var z = xyz[2];
    	var l;
    	var a;
    	var b;

    	x /= 95.047;
    	y /= 100;
    	z /= 108.883;

    	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
    	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
    	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

    	l = (116 * y) - 16;
    	a = 500 * (x - y);
    	b = 200 * (y - z);

    	return [l, a, b];
    };

    convert.hsl.rgb = function (hsl) {
    	var h = hsl[0] / 360;
    	var s = hsl[1] / 100;
    	var l = hsl[2] / 100;
    	var t1;
    	var t2;
    	var t3;
    	var rgb;
    	var val;

    	if (s === 0) {
    		val = l * 255;
    		return [val, val, val];
    	}

    	if (l < 0.5) {
    		t2 = l * (1 + s);
    	} else {
    		t2 = l + s - l * s;
    	}

    	t1 = 2 * l - t2;

    	rgb = [0, 0, 0];
    	for (var i = 0; i < 3; i++) {
    		t3 = h + 1 / 3 * -(i - 1);
    		if (t3 < 0) {
    			t3++;
    		}
    		if (t3 > 1) {
    			t3--;
    		}

    		if (6 * t3 < 1) {
    			val = t1 + (t2 - t1) * 6 * t3;
    		} else if (2 * t3 < 1) {
    			val = t2;
    		} else if (3 * t3 < 2) {
    			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
    		} else {
    			val = t1;
    		}

    		rgb[i] = val * 255;
    	}

    	return rgb;
    };

    convert.hsl.hsv = function (hsl) {
    	var h = hsl[0];
    	var s = hsl[1] / 100;
    	var l = hsl[2] / 100;
    	var smin = s;
    	var lmin = Math.max(l, 0.01);
    	var sv;
    	var v;

    	l *= 2;
    	s *= (l <= 1) ? l : 2 - l;
    	smin *= lmin <= 1 ? lmin : 2 - lmin;
    	v = (l + s) / 2;
    	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

    	return [h, sv * 100, v * 100];
    };

    convert.hsv.rgb = function (hsv) {
    	var h = hsv[0] / 60;
    	var s = hsv[1] / 100;
    	var v = hsv[2] / 100;
    	var hi = Math.floor(h) % 6;

    	var f = h - Math.floor(h);
    	var p = 255 * v * (1 - s);
    	var q = 255 * v * (1 - (s * f));
    	var t = 255 * v * (1 - (s * (1 - f)));
    	v *= 255;

    	switch (hi) {
    		case 0:
    			return [v, t, p];
    		case 1:
    			return [q, v, p];
    		case 2:
    			return [p, v, t];
    		case 3:
    			return [p, q, v];
    		case 4:
    			return [t, p, v];
    		case 5:
    			return [v, p, q];
    	}
    };

    convert.hsv.hsl = function (hsv) {
    	var h = hsv[0];
    	var s = hsv[1] / 100;
    	var v = hsv[2] / 100;
    	var vmin = Math.max(v, 0.01);
    	var lmin;
    	var sl;
    	var l;

    	l = (2 - s) * v;
    	lmin = (2 - s) * vmin;
    	sl = s * vmin;
    	sl /= (lmin <= 1) ? lmin : 2 - lmin;
    	sl = sl || 0;
    	l /= 2;

    	return [h, sl * 100, l * 100];
    };

    // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
    convert.hwb.rgb = function (hwb) {
    	var h = hwb[0] / 360;
    	var wh = hwb[1] / 100;
    	var bl = hwb[2] / 100;
    	var ratio = wh + bl;
    	var i;
    	var v;
    	var f;
    	var n;

    	// wh + bl cant be > 1
    	if (ratio > 1) {
    		wh /= ratio;
    		bl /= ratio;
    	}

    	i = Math.floor(6 * h);
    	v = 1 - bl;
    	f = 6 * h - i;

    	if ((i & 0x01) !== 0) {
    		f = 1 - f;
    	}

    	n = wh + f * (v - wh); // linear interpolation

    	var r;
    	var g;
    	var b;
    	switch (i) {
    		default:
    		case 6:
    		case 0: r = v; g = n; b = wh; break;
    		case 1: r = n; g = v; b = wh; break;
    		case 2: r = wh; g = v; b = n; break;
    		case 3: r = wh; g = n; b = v; break;
    		case 4: r = n; g = wh; b = v; break;
    		case 5: r = v; g = wh; b = n; break;
    	}

    	return [r * 255, g * 255, b * 255];
    };

    convert.cmyk.rgb = function (cmyk) {
    	var c = cmyk[0] / 100;
    	var m = cmyk[1] / 100;
    	var y = cmyk[2] / 100;
    	var k = cmyk[3] / 100;
    	var r;
    	var g;
    	var b;

    	r = 1 - Math.min(1, c * (1 - k) + k);
    	g = 1 - Math.min(1, m * (1 - k) + k);
    	b = 1 - Math.min(1, y * (1 - k) + k);

    	return [r * 255, g * 255, b * 255];
    };

    convert.xyz.rgb = function (xyz) {
    	var x = xyz[0] / 100;
    	var y = xyz[1] / 100;
    	var z = xyz[2] / 100;
    	var r;
    	var g;
    	var b;

    	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
    	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
    	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

    	// assume sRGB
    	r = r > 0.0031308
    		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
    		: r * 12.92;

    	g = g > 0.0031308
    		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
    		: g * 12.92;

    	b = b > 0.0031308
    		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
    		: b * 12.92;

    	r = Math.min(Math.max(0, r), 1);
    	g = Math.min(Math.max(0, g), 1);
    	b = Math.min(Math.max(0, b), 1);

    	return [r * 255, g * 255, b * 255];
    };

    convert.xyz.lab = function (xyz) {
    	var x = xyz[0];
    	var y = xyz[1];
    	var z = xyz[2];
    	var l;
    	var a;
    	var b;

    	x /= 95.047;
    	y /= 100;
    	z /= 108.883;

    	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
    	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
    	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

    	l = (116 * y) - 16;
    	a = 500 * (x - y);
    	b = 200 * (y - z);

    	return [l, a, b];
    };

    convert.lab.xyz = function (lab) {
    	var l = lab[0];
    	var a = lab[1];
    	var b = lab[2];
    	var x;
    	var y;
    	var z;

    	y = (l + 16) / 116;
    	x = a / 500 + y;
    	z = y - b / 200;

    	var y2 = Math.pow(y, 3);
    	var x2 = Math.pow(x, 3);
    	var z2 = Math.pow(z, 3);
    	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
    	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
    	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

    	x *= 95.047;
    	y *= 100;
    	z *= 108.883;

    	return [x, y, z];
    };

    convert.lab.lch = function (lab) {
    	var l = lab[0];
    	var a = lab[1];
    	var b = lab[2];
    	var hr;
    	var h;
    	var c;

    	hr = Math.atan2(b, a);
    	h = hr * 360 / 2 / Math.PI;

    	if (h < 0) {
    		h += 360;
    	}

    	c = Math.sqrt(a * a + b * b);

    	return [l, c, h];
    };

    convert.lch.lab = function (lch) {
    	var l = lch[0];
    	var c = lch[1];
    	var h = lch[2];
    	var a;
    	var b;
    	var hr;

    	hr = h / 360 * 2 * Math.PI;
    	a = c * Math.cos(hr);
    	b = c * Math.sin(hr);

    	return [l, a, b];
    };

    convert.rgb.ansi16 = function (args) {
    	var r = args[0];
    	var g = args[1];
    	var b = args[2];
    	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

    	value = Math.round(value / 50);

    	if (value === 0) {
    		return 30;
    	}

    	var ansi = 30
    		+ ((Math.round(b / 255) << 2)
    		| (Math.round(g / 255) << 1)
    		| Math.round(r / 255));

    	if (value === 2) {
    		ansi += 60;
    	}

    	return ansi;
    };

    convert.hsv.ansi16 = function (args) {
    	// optimization here; we already know the value and don't need to get
    	// it converted for us.
    	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };

    convert.rgb.ansi256 = function (args) {
    	var r = args[0];
    	var g = args[1];
    	var b = args[2];

    	// we use the extended greyscale palette here, with the exception of
    	// black and white. normal palette only has 4 greyscale shades.
    	if (r === g && g === b) {
    		if (r < 8) {
    			return 16;
    		}

    		if (r > 248) {
    			return 231;
    		}

    		return Math.round(((r - 8) / 247) * 24) + 232;
    	}

    	var ansi = 16
    		+ (36 * Math.round(r / 255 * 5))
    		+ (6 * Math.round(g / 255 * 5))
    		+ Math.round(b / 255 * 5);

    	return ansi;
    };

    convert.ansi16.rgb = function (args) {
    	var color = args % 10;

    	// handle greyscale
    	if (color === 0 || color === 7) {
    		if (args > 50) {
    			color += 3.5;
    		}

    		color = color / 10.5 * 255;

    		return [color, color, color];
    	}

    	var mult = (~~(args > 50) + 1) * 0.5;
    	var r = ((color & 1) * mult) * 255;
    	var g = (((color >> 1) & 1) * mult) * 255;
    	var b = (((color >> 2) & 1) * mult) * 255;

    	return [r, g, b];
    };

    convert.ansi256.rgb = function (args) {
    	// handle greyscale
    	if (args >= 232) {
    		var c = (args - 232) * 10 + 8;
    		return [c, c, c];
    	}

    	args -= 16;

    	var rem;
    	var r = Math.floor(args / 36) / 5 * 255;
    	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
    	var b = (rem % 6) / 5 * 255;

    	return [r, g, b];
    };

    convert.rgb.hex = function (args) {
    	var integer = ((Math.round(args[0]) & 0xFF) << 16)
    		+ ((Math.round(args[1]) & 0xFF) << 8)
    		+ (Math.round(args[2]) & 0xFF);

    	var string = integer.toString(16).toUpperCase();
    	return '000000'.substring(string.length) + string;
    };

    convert.hex.rgb = function (args) {
    	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    	if (!match) {
    		return [0, 0, 0];
    	}

    	var colorString = match[0];

    	if (match[0].length === 3) {
    		colorString = colorString.split('').map(function (char) {
    			return char + char;
    		}).join('');
    	}

    	var integer = parseInt(colorString, 16);
    	var r = (integer >> 16) & 0xFF;
    	var g = (integer >> 8) & 0xFF;
    	var b = integer & 0xFF;

    	return [r, g, b];
    };

    convert.rgb.hcg = function (rgb) {
    	var r = rgb[0] / 255;
    	var g = rgb[1] / 255;
    	var b = rgb[2] / 255;
    	var max = Math.max(Math.max(r, g), b);
    	var min = Math.min(Math.min(r, g), b);
    	var chroma = (max - min);
    	var grayscale;
    	var hue;

    	if (chroma < 1) {
    		grayscale = min / (1 - chroma);
    	} else {
    		grayscale = 0;
    	}

    	if (chroma <= 0) {
    		hue = 0;
    	} else
    	if (max === r) {
    		hue = ((g - b) / chroma) % 6;
    	} else
    	if (max === g) {
    		hue = 2 + (b - r) / chroma;
    	} else {
    		hue = 4 + (r - g) / chroma + 4;
    	}

    	hue /= 6;
    	hue %= 1;

    	return [hue * 360, chroma * 100, grayscale * 100];
    };

    convert.hsl.hcg = function (hsl) {
    	var s = hsl[1] / 100;
    	var l = hsl[2] / 100;
    	var c = 1;
    	var f = 0;

    	if (l < 0.5) {
    		c = 2.0 * s * l;
    	} else {
    		c = 2.0 * s * (1.0 - l);
    	}

    	if (c < 1.0) {
    		f = (l - 0.5 * c) / (1.0 - c);
    	}

    	return [hsl[0], c * 100, f * 100];
    };

    convert.hsv.hcg = function (hsv) {
    	var s = hsv[1] / 100;
    	var v = hsv[2] / 100;

    	var c = s * v;
    	var f = 0;

    	if (c < 1.0) {
    		f = (v - c) / (1 - c);
    	}

    	return [hsv[0], c * 100, f * 100];
    };

    convert.hcg.rgb = function (hcg) {
    	var h = hcg[0] / 360;
    	var c = hcg[1] / 100;
    	var g = hcg[2] / 100;

    	if (c === 0.0) {
    		return [g * 255, g * 255, g * 255];
    	}

    	var pure = [0, 0, 0];
    	var hi = (h % 1) * 6;
    	var v = hi % 1;
    	var w = 1 - v;
    	var mg = 0;

    	switch (Math.floor(hi)) {
    		case 0:
    			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
    		case 1:
    			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
    		case 2:
    			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
    		case 3:
    			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
    		case 4:
    			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
    		default:
    			pure[0] = 1; pure[1] = 0; pure[2] = w;
    	}

    	mg = (1.0 - c) * g;

    	return [
    		(c * pure[0] + mg) * 255,
    		(c * pure[1] + mg) * 255,
    		(c * pure[2] + mg) * 255
    	];
    };

    convert.hcg.hsv = function (hcg) {
    	var c = hcg[1] / 100;
    	var g = hcg[2] / 100;

    	var v = c + g * (1.0 - c);
    	var f = 0;

    	if (v > 0.0) {
    		f = c / v;
    	}

    	return [hcg[0], f * 100, v * 100];
    };

    convert.hcg.hsl = function (hcg) {
    	var c = hcg[1] / 100;
    	var g = hcg[2] / 100;

    	var l = g * (1.0 - c) + 0.5 * c;
    	var s = 0;

    	if (l > 0.0 && l < 0.5) {
    		s = c / (2 * l);
    	} else
    	if (l >= 0.5 && l < 1.0) {
    		s = c / (2 * (1 - l));
    	}

    	return [hcg[0], s * 100, l * 100];
    };

    convert.hcg.hwb = function (hcg) {
    	var c = hcg[1] / 100;
    	var g = hcg[2] / 100;
    	var v = c + g * (1.0 - c);
    	return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };

    convert.hwb.hcg = function (hwb) {
    	var w = hwb[1] / 100;
    	var b = hwb[2] / 100;
    	var v = 1 - b;
    	var c = v - w;
    	var g = 0;

    	if (c < 1) {
    		g = (v - c) / (1 - c);
    	}

    	return [hwb[0], c * 100, g * 100];
    };

    convert.apple.rgb = function (apple) {
    	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
    };

    convert.rgb.apple = function (rgb) {
    	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
    };

    convert.gray.rgb = function (args) {
    	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };

    convert.gray.hsl = convert.gray.hsv = function (args) {
    	return [0, 0, args[0]];
    };

    convert.gray.hwb = function (gray) {
    	return [0, 100, gray[0]];
    };

    convert.gray.cmyk = function (gray) {
    	return [0, 0, 0, gray[0]];
    };

    convert.gray.lab = function (gray) {
    	return [gray[0], 0, 0];
    };

    convert.gray.hex = function (gray) {
    	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
    	var integer = (val << 16) + (val << 8) + val;

    	var string = integer.toString(16).toUpperCase();
    	return '000000'.substring(string.length) + string;
    };

    convert.rgb.gray = function (rgb) {
    	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
    	return [val / 255 * 100];
    };
    });

    /*
    	this function routes a model to all other models.

    	all functions that are routed have a property `.conversion` attached
    	to the returned synthetic function. This property is an array
    	of strings, each with the steps in between the 'from' and 'to'
    	color models (inclusive).

    	conversions that are not possible simply are not included.
    */

    function buildGraph() {
    	var graph = {};
    	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
    	var models = Object.keys(conversions);

    	for (var len = models.length, i = 0; i < len; i++) {
    		graph[models[i]] = {
    			// http://jsperf.com/1-vs-infinity
    			// micro-opt, but this is simple.
    			distance: -1,
    			parent: null
    		};
    	}

    	return graph;
    }

    // https://en.wikipedia.org/wiki/Breadth-first_search
    function deriveBFS(fromModel) {
    	var graph = buildGraph();
    	var queue = [fromModel]; // unshift -> queue -> pop

    	graph[fromModel].distance = 0;

    	while (queue.length) {
    		var current = queue.pop();
    		var adjacents = Object.keys(conversions[current]);

    		for (var len = adjacents.length, i = 0; i < len; i++) {
    			var adjacent = adjacents[i];
    			var node = graph[adjacent];

    			if (node.distance === -1) {
    				node.distance = graph[current].distance + 1;
    				node.parent = current;
    				queue.unshift(adjacent);
    			}
    		}
    	}

    	return graph;
    }

    function link(from, to) {
    	return function (args) {
    		return to(from(args));
    	};
    }

    function wrapConversion(toModel, graph) {
    	var path = [graph[toModel].parent, toModel];
    	var fn = conversions[graph[toModel].parent][toModel];

    	var cur = graph[toModel].parent;
    	while (graph[cur].parent) {
    		path.unshift(graph[cur].parent);
    		fn = link(conversions[graph[cur].parent][cur], fn);
    		cur = graph[cur].parent;
    	}

    	fn.conversion = path;
    	return fn;
    }

    var route = function (fromModel) {
    	var graph = deriveBFS(fromModel);
    	var conversion = {};

    	var models = Object.keys(graph);
    	for (var len = models.length, i = 0; i < len; i++) {
    		var toModel = models[i];
    		var node = graph[toModel];

    		if (node.parent === null) {
    			// no possible conversion, or this node is the source model.
    			continue;
    		}

    		conversion[toModel] = wrapConversion(toModel, graph);
    	}

    	return conversion;
    };

    var convert = {};

    var models = Object.keys(conversions);

    function wrapRaw(fn) {
    	var wrappedFn = function (args) {
    		if (args === undefined || args === null) {
    			return args;
    		}

    		if (arguments.length > 1) {
    			args = Array.prototype.slice.call(arguments);
    		}

    		return fn(args);
    	};

    	// preserve .conversion property if there is one
    	if ('conversion' in fn) {
    		wrappedFn.conversion = fn.conversion;
    	}

    	return wrappedFn;
    }

    function wrapRounded(fn) {
    	var wrappedFn = function (args) {
    		if (args === undefined || args === null) {
    			return args;
    		}

    		if (arguments.length > 1) {
    			args = Array.prototype.slice.call(arguments);
    		}

    		var result = fn(args);

    		// we're assuming the result is an array here.
    		// see notice in conversions.js; don't use box types
    		// in conversion functions.
    		if (typeof result === 'object') {
    			for (var len = result.length, i = 0; i < len; i++) {
    				result[i] = Math.round(result[i]);
    			}
    		}

    		return result;
    	};

    	// preserve .conversion property if there is one
    	if ('conversion' in fn) {
    		wrappedFn.conversion = fn.conversion;
    	}

    	return wrappedFn;
    }

    models.forEach(function (fromModel) {
    	convert[fromModel] = {};

    	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
    	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

    	var routes = route(fromModel);
    	var routeModels = Object.keys(routes);

    	routeModels.forEach(function (toModel) {
    		var fn = routes[toModel];

    		convert[fromModel][toModel] = wrapRounded(fn);
    		convert[fromModel][toModel].raw = wrapRaw(fn);
    	});
    });

    var colorConvert = convert;

    var _slice = [].slice;

    var skippedModels = [
    	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
    	'keyword',

    	// gray conflicts with some method names, and has its own method defined.
    	'gray',

    	// shouldn't really be in color-convert either...
    	'hex'
    ];

    var hashedModelKeys = {};
    Object.keys(colorConvert).forEach(function (model) {
    	hashedModelKeys[_slice.call(colorConvert[model].labels).sort().join('')] = model;
    });

    var limiters = {};

    function Color(obj, model) {
    	if (!(this instanceof Color)) {
    		return new Color(obj, model);
    	}

    	if (model && model in skippedModels) {
    		model = null;
    	}

    	if (model && !(model in colorConvert)) {
    		throw new Error('Unknown model: ' + model);
    	}

    	var i;
    	var channels;

    	if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
    		this.model = 'rgb';
    		this.color = [0, 0, 0];
    		this.valpha = 1;
    	} else if (obj instanceof Color) {
    		this.model = obj.model;
    		this.color = obj.color.slice();
    		this.valpha = obj.valpha;
    	} else if (typeof obj === 'string') {
    		var result = colorString.get(obj);
    		if (result === null) {
    			throw new Error('Unable to parse color from string: ' + obj);
    		}

    		this.model = result.model;
    		channels = colorConvert[this.model].channels;
    		this.color = result.value.slice(0, channels);
    		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
    	} else if (obj.length) {
    		this.model = model || 'rgb';
    		channels = colorConvert[this.model].channels;
    		var newArr = _slice.call(obj, 0, channels);
    		this.color = zeroArray(newArr, channels);
    		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
    	} else if (typeof obj === 'number') {
    		// this is always RGB - can be converted later on.
    		obj &= 0xFFFFFF;
    		this.model = 'rgb';
    		this.color = [
    			(obj >> 16) & 0xFF,
    			(obj >> 8) & 0xFF,
    			obj & 0xFF
    		];
    		this.valpha = 1;
    	} else {
    		this.valpha = 1;

    		var keys = Object.keys(obj);
    		if ('alpha' in obj) {
    			keys.splice(keys.indexOf('alpha'), 1);
    			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
    		}

    		var hashedKeys = keys.sort().join('');
    		if (!(hashedKeys in hashedModelKeys)) {
    			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
    		}

    		this.model = hashedModelKeys[hashedKeys];

    		var labels = colorConvert[this.model].labels;
    		var color = [];
    		for (i = 0; i < labels.length; i++) {
    			color.push(obj[labels[i]]);
    		}

    		this.color = zeroArray(color);
    	}

    	// perform limitations (clamping, etc.)
    	if (limiters[this.model]) {
    		channels = colorConvert[this.model].channels;
    		for (i = 0; i < channels; i++) {
    			var limit = limiters[this.model][i];
    			if (limit) {
    				this.color[i] = limit(this.color[i]);
    			}
    		}
    	}

    	this.valpha = Math.max(0, Math.min(1, this.valpha));

    	if (Object.freeze) {
    		Object.freeze(this);
    	}
    }

    Color.prototype = {
    	toString: function () {
    		return this.string();
    	},

    	toJSON: function () {
    		return this[this.model]();
    	},

    	string: function (places) {
    		var self = this.model in colorString.to ? this : this.rgb();
    		self = self.round(typeof places === 'number' ? places : 1);
    		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
    		return colorString.to[self.model](args);
    	},

    	percentString: function (places) {
    		var self = this.rgb().round(typeof places === 'number' ? places : 1);
    		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
    		return colorString.to.rgb.percent(args);
    	},

    	array: function () {
    		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
    	},

    	object: function () {
    		var result = {};
    		var channels = colorConvert[this.model].channels;
    		var labels = colorConvert[this.model].labels;

    		for (var i = 0; i < channels; i++) {
    			result[labels[i]] = this.color[i];
    		}

    		if (this.valpha !== 1) {
    			result.alpha = this.valpha;
    		}

    		return result;
    	},

    	unitArray: function () {
    		var rgb = this.rgb().color;
    		rgb[0] /= 255;
    		rgb[1] /= 255;
    		rgb[2] /= 255;

    		if (this.valpha !== 1) {
    			rgb.push(this.valpha);
    		}

    		return rgb;
    	},

    	unitObject: function () {
    		var rgb = this.rgb().object();
    		rgb.r /= 255;
    		rgb.g /= 255;
    		rgb.b /= 255;

    		if (this.valpha !== 1) {
    			rgb.alpha = this.valpha;
    		}

    		return rgb;
    	},

    	round: function (places) {
    		places = Math.max(places || 0, 0);
    		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
    	},

    	alpha: function (val) {
    		if (arguments.length) {
    			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
    		}

    		return this.valpha;
    	},

    	// rgb
    	red: getset('rgb', 0, maxfn(255)),
    	green: getset('rgb', 1, maxfn(255)),
    	blue: getset('rgb', 2, maxfn(255)),

    	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

    	saturationl: getset('hsl', 1, maxfn(100)),
    	lightness: getset('hsl', 2, maxfn(100)),

    	saturationv: getset('hsv', 1, maxfn(100)),
    	value: getset('hsv', 2, maxfn(100)),

    	chroma: getset('hcg', 1, maxfn(100)),
    	gray: getset('hcg', 2, maxfn(100)),

    	white: getset('hwb', 1, maxfn(100)),
    	wblack: getset('hwb', 2, maxfn(100)),

    	cyan: getset('cmyk', 0, maxfn(100)),
    	magenta: getset('cmyk', 1, maxfn(100)),
    	yellow: getset('cmyk', 2, maxfn(100)),
    	black: getset('cmyk', 3, maxfn(100)),

    	x: getset('xyz', 0, maxfn(100)),
    	y: getset('xyz', 1, maxfn(100)),
    	z: getset('xyz', 2, maxfn(100)),

    	l: getset('lab', 0, maxfn(100)),
    	a: getset('lab', 1),
    	b: getset('lab', 2),

    	keyword: function (val) {
    		if (arguments.length) {
    			return new Color(val);
    		}

    		return colorConvert[this.model].keyword(this.color);
    	},

    	hex: function (val) {
    		if (arguments.length) {
    			return new Color(val);
    		}

    		return colorString.to.hex(this.rgb().round().color);
    	},

    	rgbNumber: function () {
    		var rgb = this.rgb().color;
    		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
    	},

    	luminosity: function () {
    		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
    		var rgb = this.rgb().color;

    		var lum = [];
    		for (var i = 0; i < rgb.length; i++) {
    			var chan = rgb[i] / 255;
    			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
    		}

    		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
    	},

    	contrast: function (color2) {
    		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
    		var lum1 = this.luminosity();
    		var lum2 = color2.luminosity();

    		if (lum1 > lum2) {
    			return (lum1 + 0.05) / (lum2 + 0.05);
    		}

    		return (lum2 + 0.05) / (lum1 + 0.05);
    	},

    	level: function (color2) {
    		var contrastRatio = this.contrast(color2);
    		if (contrastRatio >= 7.1) {
    			return 'AAA';
    		}

    		return (contrastRatio >= 4.5) ? 'AA' : '';
    	},

    	isDark: function () {
    		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
    		var rgb = this.rgb().color;
    		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
    		return yiq < 128;
    	},

    	isLight: function () {
    		return !this.isDark();
    	},

    	negate: function () {
    		var rgb = this.rgb();
    		for (var i = 0; i < 3; i++) {
    			rgb.color[i] = 255 - rgb.color[i];
    		}
    		return rgb;
    	},

    	lighten: function (ratio) {
    		var hsl = this.hsl();
    		hsl.color[2] += hsl.color[2] * ratio;
    		return hsl;
    	},

    	darken: function (ratio) {
    		var hsl = this.hsl();
    		hsl.color[2] -= hsl.color[2] * ratio;
    		return hsl;
    	},

    	saturate: function (ratio) {
    		var hsl = this.hsl();
    		hsl.color[1] += hsl.color[1] * ratio;
    		return hsl;
    	},

    	desaturate: function (ratio) {
    		var hsl = this.hsl();
    		hsl.color[1] -= hsl.color[1] * ratio;
    		return hsl;
    	},

    	whiten: function (ratio) {
    		var hwb = this.hwb();
    		hwb.color[1] += hwb.color[1] * ratio;
    		return hwb;
    	},

    	blacken: function (ratio) {
    		var hwb = this.hwb();
    		hwb.color[2] += hwb.color[2] * ratio;
    		return hwb;
    	},

    	grayscale: function () {
    		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
    		var rgb = this.rgb().color;
    		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
    		return Color.rgb(val, val, val);
    	},

    	fade: function (ratio) {
    		return this.alpha(this.valpha - (this.valpha * ratio));
    	},

    	opaquer: function (ratio) {
    		return this.alpha(this.valpha + (this.valpha * ratio));
    	},

    	rotate: function (degrees) {
    		var hsl = this.hsl();
    		var hue = hsl.color[0];
    		hue = (hue + degrees) % 360;
    		hue = hue < 0 ? 360 + hue : hue;
    		hsl.color[0] = hue;
    		return hsl;
    	},

    	mix: function (mixinColor, weight) {
    		// ported from sass implementation in C
    		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
    		if (!mixinColor || !mixinColor.rgb) {
    			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
    		}
    		var color1 = mixinColor.rgb();
    		var color2 = this.rgb();
    		var p = weight === undefined ? 0.5 : weight;

    		var w = 2 * p - 1;
    		var a = color1.alpha() - color2.alpha();

    		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
    		var w2 = 1 - w1;

    		return Color.rgb(
    				w1 * color1.red() + w2 * color2.red(),
    				w1 * color1.green() + w2 * color2.green(),
    				w1 * color1.blue() + w2 * color2.blue(),
    				color1.alpha() * p + color2.alpha() * (1 - p));
    	}
    };

    // model conversion methods and static constructors
    Object.keys(colorConvert).forEach(function (model) {
    	if (skippedModels.indexOf(model) !== -1) {
    		return;
    	}

    	var channels = colorConvert[model].channels;

    	// conversion methods
    	Color.prototype[model] = function () {
    		if (this.model === model) {
    			return new Color(this);
    		}

    		if (arguments.length) {
    			return new Color(arguments, model);
    		}

    		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
    		return new Color(assertArray(colorConvert[this.model][model].raw(this.color)).concat(newAlpha), model);
    	};

    	// 'static' construction methods
    	Color[model] = function (color) {
    		if (typeof color === 'number') {
    			color = zeroArray(_slice.call(arguments), channels);
    		}
    		return new Color(color, model);
    	};
    });

    function roundTo(num, places) {
    	return Number(num.toFixed(places));
    }

    function roundToPlace(places) {
    	return function (num) {
    		return roundTo(num, places);
    	};
    }

    function getset(model, channel, modifier) {
    	model = Array.isArray(model) ? model : [model];

    	model.forEach(function (m) {
    		(limiters[m] || (limiters[m] = []))[channel] = modifier;
    	});

    	model = model[0];

    	return function (val) {
    		var result;

    		if (arguments.length) {
    			if (modifier) {
    				val = modifier(val);
    			}

    			result = this[model]();
    			result.color[channel] = val;
    			return result;
    		}

    		result = this[model]().color[channel];
    		if (modifier) {
    			result = modifier(result);
    		}

    		return result;
    	};
    }

    function maxfn(max) {
    	return function (v) {
    		return Math.max(0, Math.min(max, v));
    	};
    }

    function assertArray(val) {
    	return Array.isArray(val) ? val : [val];
    }

    function zeroArray(arr, length) {
    	for (var i = 0; i < length; i++) {
    		if (typeof arr[i] !== 'number') {
    			arr[i] = 0;
    		}
    	}

    	return arr;
    }

    var color = Color;

    /* src/components/common-frame.svelte generated by Svelte v3.43.0 */
    const file$l = "src/components/common-frame.svelte";

    // (42:4) {#if title}
    function create_if_block_1$5(ctx) {
    	let h2;
    	let t;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			t = text$1(/*title*/ ctx[0]);
    			attr_dev(h2, "class", "svelte-1g2xbe3");
    			add_location(h2, file$l, 42, 6, 1064);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			append_dev(h2, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(42:4) {#if title}",
    		ctx
    	});

    	return block;
    }

    // (45:4) {#if subtitle}
    function create_if_block$e(ctx) {
    	let h3;
    	let t;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			t = text$1(/*subtitle*/ ctx[1]);
    			attr_dev(h3, "class", "svelte-1g2xbe3");
    			add_location(h3, file$l, 45, 6, 1116);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    			append_dev(h3, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*subtitle*/ 2) set_data_dev(t, /*subtitle*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(45:4) {#if subtitle}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let section;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current;
    	let if_block0 = /*title*/ ctx[0] && create_if_block_1$5(ctx);
    	let if_block1 = /*subtitle*/ ctx[1] && create_if_block$e(ctx);
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "title-bar svelte-1g2xbe3");
    			add_location(div0, file$l, 40, 2, 1018);
    			attr_dev(div1, "class", "padding svelte-1g2xbe3");
    			add_location(div1, file$l, 48, 2, 1157);
    			attr_dev(section, "id", /*id*/ ctx[3]);
    			set_style(section, "--themeColor", /*themeColor*/ ctx[2]);
    			set_style(section, "--backgroundColor", /*backgroundColor*/ ctx[5]);
    			set_style(section, "--textColor", /*textColor*/ ctx[4]);
    			attr_dev(section, "class", "svelte-1g2xbe3");
    			add_location(section, file$l, 39, 0, 899);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(section, t1);
    			append_dev(section, div1);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*title*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$5(ctx);
    					if_block0.c();
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*subtitle*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$e(ctx);
    					if_block1.c();
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 64)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[6],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[6])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*id*/ 8) {
    				attr_dev(section, "id", /*id*/ ctx[3]);
    			}

    			if (!current || dirty & /*themeColor*/ 4) {
    				set_style(section, "--themeColor", /*themeColor*/ ctx[2]);
    			}

    			if (!current || dirty & /*backgroundColor*/ 32) {
    				set_style(section, "--backgroundColor", /*backgroundColor*/ ctx[5]);
    			}

    			if (!current || dirty & /*textColor*/ 16) {
    				set_style(section, "--textColor", /*textColor*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let backgroundColor;
    	let textColor;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Common_frame', slots, ['default']);
    	let { title, subtitle, themeColor, id } = $$props;
    	const writable_props = ['title', 'subtitle', 'themeColor', 'id'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Common_frame> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('subtitle' in $$props) $$invalidate(1, subtitle = $$props.subtitle);
    		if ('themeColor' in $$props) $$invalidate(2, themeColor = $$props.themeColor);
    		if ('id' in $$props) $$invalidate(3, id = $$props.id);
    		if ('$$scope' in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Color: color,
    		title,
    		subtitle,
    		themeColor,
    		id,
    		textColor,
    		backgroundColor
    	});

    	$$self.$inject_state = $$props => {
    		if ('title' in $$props) $$invalidate(0, title = $$props.title);
    		if ('subtitle' in $$props) $$invalidate(1, subtitle = $$props.subtitle);
    		if ('themeColor' in $$props) $$invalidate(2, themeColor = $$props.themeColor);
    		if ('id' in $$props) $$invalidate(3, id = $$props.id);
    		if ('textColor' in $$props) $$invalidate(4, textColor = $$props.textColor);
    		if ('backgroundColor' in $$props) $$invalidate(5, backgroundColor = $$props.backgroundColor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*themeColor*/ 4) {
    			$$invalidate(5, backgroundColor = color(themeColor).lightness(96));
    		}

    		if ($$self.$$.dirty & /*themeColor*/ 4) {
    			$$invalidate(4, textColor = color(themeColor).luminosity() > 0.7 ? '#000' : '#fff');
    		}
    	};

    	return [title, subtitle, themeColor, id, textColor, backgroundColor, $$scope, slots];
    }

    class Common_frame extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			title: 0,
    			subtitle: 1,
    			themeColor: 2,
    			id: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Common_frame",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*title*/ ctx[0] === undefined && !('title' in props)) {
    			console.warn("<Common_frame> was created without expected prop 'title'");
    		}

    		if (/*subtitle*/ ctx[1] === undefined && !('subtitle' in props)) {
    			console.warn("<Common_frame> was created without expected prop 'subtitle'");
    		}

    		if (/*themeColor*/ ctx[2] === undefined && !('themeColor' in props)) {
    			console.warn("<Common_frame> was created without expected prop 'themeColor'");
    		}

    		if (/*id*/ ctx[3] === undefined && !('id' in props)) {
    			console.warn("<Common_frame> was created without expected prop 'id'");
    		}
    	}

    	get title() {
    		throw new Error("<Common_frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Common_frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subtitle() {
    		throw new Error("<Common_frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subtitle(value) {
    		throw new Error("<Common_frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get themeColor() {
    		throw new Error("<Common_frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set themeColor(value) {
    		throw new Error("<Common_frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Common_frame>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Common_frame>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * https://github.com/gre/bezier-easing
     * BezierEasing - use bezier curve for transition easing function
     * by Gatan Renaudeau 2014 - 2015  MIT License
     */
    // These values are established by empiricism with tests (tradeoff: performance VS precision)
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 0.001;
    var SUBDIVISION_PRECISION = 0.0000001;
    var SUBDIVISION_MAX_ITERATIONS = 10;

    var kSplineTableSize = 11;
    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

    var float32ArraySupported = typeof Float32Array === 'function';

    function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
    function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
    function C (aA1)      { return 3.0 * aA1; }

    // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
    function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

    // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
    function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

    function binarySubdivide (aX, aA, aB, mX1, mX2) {
      var currentX, currentT, i = 0;
      do {
        currentT = aA + (aB - aA) / 2.0;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0.0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }

    function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
     for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
       var currentSlope = getSlope(aGuessT, mX1, mX2);
       if (currentSlope === 0.0) {
         return aGuessT;
       }
       var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
       aGuessT -= currentX / currentSlope;
     }
     return aGuessT;
    }

    function LinearEasing (x) {
      return x;
    }

    var src = function bezier (mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error('bezier x values must be in [0, 1] range');
      }

      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }

      // Precompute samples table
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }

      function getTForX (aX) {
        var intervalStart = 0.0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;

        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;

        // Interpolate to provide an initial guess for t
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;

        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0.0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }

      return function BezierEasing (x) {
        // Because JavaScript number are imprecise, we should guarantee the extremes are right.
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };

    var SAT = createCommonjsModule(function (module, exports) {
    // Version 0.9.0 - Copyright 2012 - 2021 -  Jim Riecken <jimr@jimr.ca>
    //
    // Released under the MIT License - https://github.com/jriecken/sat-js
    //
    // A simple library for determining intersections of circles and
    // polygons using the Separating Axis Theorem.
    /** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */

    /*global define: false, module: false*/
    /*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true,
      eqeqeq:true, bitwise:true, strict:true, undef:true,
      curly:true, browser:true */

    // Create a UMD wrapper for SAT. Works in:
    //
    //  - Plain browser via global SAT variable
    //  - AMD loader (like require.js)
    //  - Node.js
    //
    // The quoted properties all over the place are used so that the Closure Compiler
    // does not mangle the exposed API in advanced mode.
    /**
     * @param {*} root - The global scope
     * @param {Function} factory - Factory that creates SAT module
     */
    (function (root, factory) {
      {
        module['exports'] = factory();
      }
    }(commonjsGlobal, function () {

      var SAT = {};

      //
      // ## Vector
      //
      // Represents a vector in two dimensions with `x` and `y` properties.


      // Create a new Vector, optionally passing in the `x` and `y` coordinates. If
      // a coordinate is not specified, it will be set to `0`
      /**
       * @param {?number=} x The x position.
       * @param {?number=} y The y position.
       * @constructor
       */
      function Vector(x, y) {
        this['x'] = x || 0;
        this['y'] = y || 0;
      }
      SAT['Vector'] = Vector;
      // Alias `Vector` as `V`
      SAT['V'] = Vector;


      // Copy the values of another Vector into this one.
      /**
       * @param {Vector} other The other Vector.
       * @return {Vector} This for chaining.
       */
      Vector.prototype['copy'] = Vector.prototype.copy = function (other) {
        this['x'] = other['x'];
        this['y'] = other['y'];
        return this;
      };

      // Create a new vector with the same coordinates as this on.
      /**
       * @return {Vector} The new cloned vector
       */
      Vector.prototype['clone'] = Vector.prototype.clone = function () {
        return new Vector(this['x'], this['y']);
      };

      // Change this vector to be perpendicular to what it was before. (Effectively
      // roatates it 90 degrees in a clockwise direction)
      /**
       * @return {Vector} This for chaining.
       */
      Vector.prototype['perp'] = Vector.prototype.perp = function () {
        var x = this['x'];
        this['x'] = this['y'];
        this['y'] = -x;
        return this;
      };

      // Rotate this vector (counter-clockwise) by the specified angle (in radians).
      /**
       * @param {number} angle The angle to rotate (in radians)
       * @return {Vector} This for chaining.
       */
      Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {
        var x = this['x'];
        var y = this['y'];
        this['x'] = x * Math.cos(angle) - y * Math.sin(angle);
        this['y'] = x * Math.sin(angle) + y * Math.cos(angle);
        return this;
      };

      // Reverse this vector.
      /**
       * @return {Vector} This for chaining.
       */
      Vector.prototype['reverse'] = Vector.prototype.reverse = function () {
        this['x'] = -this['x'];
        this['y'] = -this['y'];
        return this;
      };


      // Normalize this vector.  (make it have length of `1`)
      /**
       * @return {Vector} This for chaining.
       */
      Vector.prototype['normalize'] = Vector.prototype.normalize = function () {
        var d = this.len();
        if (d > 0) {
          this['x'] = this['x'] / d;
          this['y'] = this['y'] / d;
        }
        return this;
      };

      // Add another vector to this one.
      /**
       * @param {Vector} other The other Vector.
       * @return {Vector} This for chaining.
       */
      Vector.prototype['add'] = Vector.prototype.add = function (other) {
        this['x'] += other['x'];
        this['y'] += other['y'];
        return this;
      };

      // Subtract another vector from this one.
      /**
       * @param {Vector} other The other Vector.
       * @return {Vector} This for chaiing.
       */
      Vector.prototype['sub'] = Vector.prototype.sub = function (other) {
        this['x'] -= other['x'];
        this['y'] -= other['y'];
        return this;
      };

      // Scale this vector. An independent scaling factor can be provided
      // for each axis, or a single scaling factor that will scale both `x` and `y`.
      /**
       * @param {number} x The scaling factor in the x direction.
       * @param {?number=} y The scaling factor in the y direction.  If this
       *   is not specified, the x scaling factor will be used.
       * @return {Vector} This for chaining.
       */
      Vector.prototype['scale'] = Vector.prototype.scale = function (x, y) {
        this['x'] *= x;
        this['y'] *= typeof y != 'undefined' ? y : x;
        return this;
      };

      // Project this vector on to another vector.
      /**
       * @param {Vector} other The vector to project onto.
       * @return {Vector} This for chaining.
       */
      Vector.prototype['project'] = Vector.prototype.project = function (other) {
        var amt = this.dot(other) / other.len2();
        this['x'] = amt * other['x'];
        this['y'] = amt * other['y'];
        return this;
      };

      // Project this vector onto a vector of unit length. This is slightly more efficient
      // than `project` when dealing with unit vectors.
      /**
       * @param {Vector} other The unit vector to project onto.
       * @return {Vector} This for chaining.
       */
      Vector.prototype['projectN'] = Vector.prototype.projectN = function (other) {
        var amt = this.dot(other);
        this['x'] = amt * other['x'];
        this['y'] = amt * other['y'];
        return this;
      };

      // Reflect this vector on an arbitrary axis.
      /**
       * @param {Vector} axis The vector representing the axis.
       * @return {Vector} This for chaining.
       */
      Vector.prototype['reflect'] = Vector.prototype.reflect = function (axis) {
        var x = this['x'];
        var y = this['y'];
        this.project(axis).scale(2);
        this['x'] -= x;
        this['y'] -= y;
        return this;
      };

      // Reflect this vector on an arbitrary axis (represented by a unit vector). This is
      // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.
      /**
       * @param {Vector} axis The unit vector representing the axis.
       * @return {Vector} This for chaining.
       */
      Vector.prototype['reflectN'] = Vector.prototype.reflectN = function (axis) {
        var x = this['x'];
        var y = this['y'];
        this.projectN(axis).scale(2);
        this['x'] -= x;
        this['y'] -= y;
        return this;
      };

      // Get the dot product of this vector and another.
      /**
       * @param {Vector}  other The vector to dot this one against.
       * @return {number} The dot product.
       */
      Vector.prototype['dot'] = Vector.prototype.dot = function (other) {
        return this['x'] * other['x'] + this['y'] * other['y'];
      };

      // Get the squared length of this vector.
      /**
       * @return {number} The length^2 of this vector.
       */
      Vector.prototype['len2'] = Vector.prototype.len2 = function () {
        return this.dot(this);
      };

      // Get the length of this vector.
      /**
       * @return {number} The length of this vector.
       */
      Vector.prototype['len'] = Vector.prototype.len = function () {
        return Math.sqrt(this.len2());
      };

      // ## Circle
      //
      // Represents a circle with a position and a radius.

      // Create a new circle, optionally passing in a position and/or radius. If no position
      // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will
      // have a radius of `0`.
      /**
       * @param {Vector=} pos A vector representing the position of the center of the circle
       * @param {?number=} r The radius of the circle
       * @constructor
       */
      function Circle(pos, r) {
        this['pos'] = pos || new Vector();
        this['r'] = r || 0;
        this['offset'] = new Vector();
      }
      SAT['Circle'] = Circle;

      // Compute the axis-aligned bounding box (AABB) of this Circle.
      //
      // Note: Returns a _new_ `Box` each time you call this.
      /**
       * @return {Polygon} The AABB
       */
      Circle.prototype['getAABBAsBox'] = Circle.prototype.getAABBAsBox = function () {
        var r = this['r'];
        var corner = this['pos'].clone().add(this['offset']).sub(new Vector(r, r));
        return new Box(corner, r * 2, r * 2);
      };

      // Compute the axis-aligned bounding box (AABB) of this Circle.
      //
      // Note: Returns a _new_ `Polygon` each time you call this.
      /**
       * @return {Polygon} The AABB
       */
      Circle.prototype['getAABB'] = Circle.prototype.getAABB = function () {
        return this.getAABBAsBox().toPolygon();
      };

      // Set the current offset to apply to the radius.
      /**
       * @param {Vector} offset The new offset vector.
       * @return {Circle} This for chaining.
       */
      Circle.prototype['setOffset'] = Circle.prototype.setOffset = function (offset) {
        this['offset'] = offset;
        return this;
      };

      // ## Polygon
      //
      // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)
      //
      // Note: Do _not_ manually change the `points`, `angle`, or `offset` properties. Use the
      // provided setters. Otherwise the calculated properties will not be updated correctly.
      //
      // `pos` can be changed directly.

      // Create a new polygon, passing in a position vector, and an array of points (represented
      // by vectors relative to the position vector). If no position is passed in, the position
      // of the polygon will be `(0,0)`.
      /**
       * @param {Vector=} pos A vector representing the origin of the polygon. (all other
       *   points are relative to this one)
       * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,
       *   in counter-clockwise order.
       * @constructor
       */
      function Polygon(pos, points) {
        this['pos'] = pos || new Vector();
        this['angle'] = 0;
        this['offset'] = new Vector();
        this.setPoints(points || []);
      }
      SAT['Polygon'] = Polygon;

      // Set the points of the polygon. Any consecutive duplicate points will be combined.
      //
      // Note: The points are counter-clockwise *with respect to the coordinate system*.
      // If you directly draw the points on a screen that has the origin at the top-left corner
      // it will _appear_ visually that the points are being specified clockwise. This is just
      // because of the inversion of the Y-axis when being displayed.
      /**
       * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,
       *   in counter-clockwise order.
       * @return {Polygon} This for chaining.
       */
      Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function (points) {
        // Only re-allocate if this is a new polygon or the number of points has changed.
        var lengthChanged = !this['points'] || this['points'].length !== points.length;
        if (lengthChanged) {
          var i;
          var calcPoints = this['calcPoints'] = [];
          var edges = this['edges'] = [];
          var normals = this['normals'] = [];
          // Allocate the vector arrays for the calculated properties
          for (i = 0; i < points.length; i++) {
            // Remove consecutive duplicate points
            var p1 = points[i];
            var p2 = i < points.length - 1 ? points[i + 1] : points[0];
            if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {
              points.splice(i, 1);
              i -= 1;
              continue;
            }
            calcPoints.push(new Vector());
            edges.push(new Vector());
            normals.push(new Vector());
          }
        }
        this['points'] = points;
        this._recalc();
        return this;
      };

      // Set the current rotation angle of the polygon.
      /**
       * @param {number} angle The current rotation angle (in radians).
       * @return {Polygon} This for chaining.
       */
      Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function (angle) {
        this['angle'] = angle;
        this._recalc();
        return this;
      };

      // Set the current offset to apply to the `points` before applying the `angle` rotation.
      /**
       * @param {Vector} offset The new offset vector.
       * @return {Polygon} This for chaining.
       */
      Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function (offset) {
        this['offset'] = offset;
        this._recalc();
        return this;
      };

      // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).
      //
      // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation).
      /**
       * @param {number} angle The angle to rotate (in radians)
       * @return {Polygon} This for chaining.
       */
      Polygon.prototype['rotate'] = Polygon.prototype.rotate = function (angle) {
        var points = this['points'];
        var len = points.length;
        for (var i = 0; i < len; i++) {
          points[i].rotate(angle);
        }
        this._recalc();
        return this;
      };

      // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate
      // system* (i.e. `pos`).
      //
      // This is most useful to change the "center point" of a polygon. If you just want to move the whole polygon, change
      // the coordinates of `pos`.
      //
      // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)
      /**
       * @param {number} x The horizontal amount to translate.
       * @param {number} y The vertical amount to translate.
       * @return {Polygon} This for chaining.
       */
      Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {
        var points = this['points'];
        var len = points.length;
        for (var i = 0; i < len; i++) {
          points[i]['x'] += x;
          points[i]['y'] += y;
        }
        this._recalc();
        return this;
      };


      // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the
      // edges and normals of the collision polygon.
      /**
       * @return {Polygon} This for chaining.
       */
      Polygon.prototype._recalc = function () {
        // Calculated points - this is what is used for underlying collisions and takes into account
        // the angle/offset set on the polygon.
        var calcPoints = this['calcPoints'];
        // The edges here are the direction of the `n`th edge of the polygon, relative to
        // the `n`th point. If you want to draw a given edge from the edge value, you must
        // first translate to the position of the starting point.
        var edges = this['edges'];
        // The normals here are the direction of the normal for the `n`th edge of the polygon, relative
        // to the position of the `n`th point. If you want to draw an edge normal, you must first
        // translate to the position of the starting point.
        var normals = this['normals'];
        // Copy the original points array and apply the offset/angle
        var points = this['points'];
        var offset = this['offset'];
        var angle = this['angle'];
        var len = points.length;
        var i;
        for (i = 0; i < len; i++) {
          var calcPoint = calcPoints[i].copy(points[i]);
          calcPoint['x'] += offset['x'];
          calcPoint['y'] += offset['y'];
          if (angle !== 0) {
            calcPoint.rotate(angle);
          }
        }
        // Calculate the edges/normals
        for (i = 0; i < len; i++) {
          var p1 = calcPoints[i];
          var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];
          var e = edges[i].copy(p2).sub(p1);
          normals[i].copy(e).perp().normalize();
        }
        return this;
      };


      // Compute the axis-aligned bounding box. Any current state
      // (translations/rotations) will be applied before constructing the AABB.
      //
      // Note: Returns a _new_ `Box` each time you call this.
      /**
       * @return {Polygon} The AABB
       */
      Polygon.prototype['getAABBAsBox'] = Polygon.prototype.getAABBAsBox = function () {
        var points = this['calcPoints'];
        var len = points.length;
        var xMin = points[0]['x'];
        var yMin = points[0]['y'];
        var xMax = points[0]['x'];
        var yMax = points[0]['y'];
        for (var i = 1; i < len; i++) {
          var point = points[i];
          if (point['x'] < xMin) {
            xMin = point['x'];
          }
          else if (point['x'] > xMax) {
            xMax = point['x'];
          }
          if (point['y'] < yMin) {
            yMin = point['y'];
          }
          else if (point['y'] > yMax) {
            yMax = point['y'];
          }
        }
        return new Box(this['pos'].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);
      };


      // Compute the axis-aligned bounding box. Any current state
      // (translations/rotations) will be applied before constructing the AABB.
      //
      // Note: Returns a _new_ `Polygon` each time you call this.
      /**
       * @return {Polygon} The AABB
       */
      Polygon.prototype['getAABB'] = Polygon.prototype.getAABB = function () {
        return this.getAABBAsBox().toPolygon();
      };

      // Compute the centroid (geometric center) of the polygon. Any current state
      // (translations/rotations) will be applied before computing the centroid.
      //
      // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_a_polygon
      //
      // Note: Returns a _new_ `Vector` each time you call this.
      /**
       * @return {Vector} A Vector that contains the coordinates of the Centroid.
       */
      Polygon.prototype['getCentroid'] = Polygon.prototype.getCentroid = function () {
        var points = this['calcPoints'];
        var len = points.length;
        var cx = 0;
        var cy = 0;
        var ar = 0;
        for (var i = 0; i < len; i++) {
          var p1 = points[i];
          var p2 = i === len - 1 ? points[0] : points[i + 1]; // Loop around if last point
          var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];
          cx += (p1['x'] + p2['x']) * a;
          cy += (p1['y'] + p2['y']) * a;
          ar += a;
        }
        ar = ar * 3; // we want 1 / 6 the area and we currently have 2*area
        cx = cx / ar;
        cy = cy / ar;
        return new Vector(cx, cy);
      };


      // ## Box
      //
      // Represents an axis-aligned box, with a width and height.


      // Create a new box, with the specified position, width, and height. If no position
      // is given, the position will be `(0,0)`. If no width or height are given, they will
      // be set to `0`.
      /**
       * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).
       * @param {?number=} w The width of the box.
       * @param {?number=} h The height of the box.
       * @constructor
       */
      function Box(pos, w, h) {
        this['pos'] = pos || new Vector();
        this['w'] = w || 0;
        this['h'] = h || 0;
      }
      SAT['Box'] = Box;

      // Returns a polygon whose edges are the same as this box.
      /**
       * @return {Polygon} A new Polygon that represents this box.
       */
      Box.prototype['toPolygon'] = Box.prototype.toPolygon = function () {
        var pos = this['pos'];
        var w = this['w'];
        var h = this['h'];
        return new Polygon(new Vector(pos['x'], pos['y']), [
          new Vector(), new Vector(w, 0),
          new Vector(w, h), new Vector(0, h)
        ]);
      };

      // ## Response
      //
      // An object representing the result of an intersection. Contains:
      //  - The two objects participating in the intersection
      //  - The vector representing the minimum change necessary to extract the first object
      //    from the second one (as well as a unit vector in that direction and the magnitude
      //    of the overlap)
      //  - Whether the first object is entirely inside the second, and vice versa.
      /**
       * @constructor
       */
      function Response() {
        this['a'] = null;
        this['b'] = null;
        this['overlapN'] = new Vector();
        this['overlapV'] = new Vector();
        this.clear();
      }
      SAT['Response'] = Response;

      // Set some values of the response back to their defaults.  Call this between tests if
      // you are going to reuse a single Response object for multiple intersection tests (recommented
      // as it will avoid allcating extra memory)
      /**
       * @return {Response} This for chaining
       */
      Response.prototype['clear'] = Response.prototype.clear = function () {
        this['aInB'] = true;
        this['bInA'] = true;
        this['overlap'] = Number.MAX_VALUE;
        return this;
      };

      // ## Object Pools

      // A pool of `Vector` objects that are used in calculations to avoid
      // allocating memory.
      /**
       * @type {Array<Vector>}
       */
      var T_VECTORS = [];
      for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }

      // A pool of arrays of numbers used in calculations to avoid allocating
      // memory.
      /**
       * @type {Array<Array<number>>}
       */
      var T_ARRAYS = [];
      for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }

      // Temporary response used for polygon hit detection.
      /**
       * @type {Response}
       */
      var T_RESPONSE = new Response();

      // Tiny "point" polygon used for polygon hit detection.
      /**
       * @type {Polygon}
       */
      var TEST_POINT = new Box(new Vector(), 0.000001, 0.000001).toPolygon();

      // ## Helper Functions

      // Flattens the specified array of points onto a unit vector axis,
      // resulting in a one dimensional range of the minimum and
      // maximum value on that axis.
      /**
       * @param {Array<Vector>} points The points to flatten.
       * @param {Vector} normal The unit vector axis to flatten on.
       * @param {Array<number>} result An array.  After calling this function,
       *   result[0] will be the minimum value,
       *   result[1] will be the maximum value.
       */
      function flattenPointsOn(points, normal, result) {
        var min = Number.MAX_VALUE;
        var max = -Number.MAX_VALUE;
        var len = points.length;
        for (var i = 0; i < len; i++) {
          // The magnitude of the projection of the point onto the normal
          var dot = points[i].dot(normal);
          if (dot < min) { min = dot; }
          if (dot > max) { max = dot; }
        }
        result[0] = min; result[1] = max;
      }

      // Check whether two convex polygons are separated by the specified
      // axis (must be a unit vector).
      /**
       * @param {Vector} aPos The position of the first polygon.
       * @param {Vector} bPos The position of the second polygon.
       * @param {Array<Vector>} aPoints The points in the first polygon.
       * @param {Array<Vector>} bPoints The points in the second polygon.
       * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons
       *   will be projected onto this axis.
       * @param {Response=} response A Response object (optional) which will be populated
       *   if the axis is not a separating axis.
       * @return {boolean} true if it is a separating axis, false otherwise.  If false,
       *   and a response is passed in, information about how much overlap and
       *   the direction of the overlap will be populated.
       */
      function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {
        var rangeA = T_ARRAYS.pop();
        var rangeB = T_ARRAYS.pop();
        // The magnitude of the offset between the two polygons
        var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);
        var projectedOffset = offsetV.dot(axis);
        // Project the polygons onto the axis.
        flattenPointsOn(aPoints, axis, rangeA);
        flattenPointsOn(bPoints, axis, rangeB);
        // Move B's range to its position relative to A.
        rangeB[0] += projectedOffset;
        rangeB[1] += projectedOffset;
        // Check if there is a gap. If there is, this is a separating axis and we can stop
        if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {
          T_VECTORS.push(offsetV);
          T_ARRAYS.push(rangeA);
          T_ARRAYS.push(rangeB);
          return true;
        }
        // This is not a separating axis. If we're calculating a response, calculate the overlap.
        if (response) {
          var overlap = 0;
          // A starts further left than B
          if (rangeA[0] < rangeB[0]) {
            response['aInB'] = false;
            // A ends before B does. We have to pull A out of B
            if (rangeA[1] < rangeB[1]) {
              overlap = rangeA[1] - rangeB[0];
              response['bInA'] = false;
              // B is fully inside A.  Pick the shortest way out.
            } else {
              var option1 = rangeA[1] - rangeB[0];
              var option2 = rangeB[1] - rangeA[0];
              overlap = option1 < option2 ? option1 : -option2;
            }
            // B starts further left than A
          } else {
            response['bInA'] = false;
            // B ends before A ends. We have to push A out of B
            if (rangeA[1] > rangeB[1]) {
              overlap = rangeA[0] - rangeB[1];
              response['aInB'] = false;
              // A is fully inside B.  Pick the shortest way out.
            } else {
              var option1 = rangeA[1] - rangeB[0];
              var option2 = rangeB[1] - rangeA[0];
              overlap = option1 < option2 ? option1 : -option2;
            }
          }
          // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.
          var absOverlap = Math.abs(overlap);
          if (absOverlap < response['overlap']) {
            response['overlap'] = absOverlap;
            response['overlapN'].copy(axis);
            if (overlap < 0) {
              response['overlapN'].reverse();
            }
          }
        }
        T_VECTORS.push(offsetV);
        T_ARRAYS.push(rangeA);
        T_ARRAYS.push(rangeB);
        return false;
      }
      SAT['isSeparatingAxis'] = isSeparatingAxis;

      // Calculates which Voronoi region a point is on a line segment.
      // It is assumed that both the line and the point are relative to `(0,0)`
      //
      //            |       (0)      |
      //     (-1)  [S]--------------[E]  (1)
      //            |       (0)      |
      /**
       * @param {Vector} line The line segment.
       * @param {Vector} point The point.
       * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,
       *          MIDDLE_VORONOI_REGION (0) if it is the middle region,
       *          RIGHT_VORONOI_REGION (1) if it is the right region.
       */
      function voronoiRegion(line, point) {
        var len2 = line.len2();
        var dp = point.dot(line);
        // If the point is beyond the start of the line, it is in the
        // left voronoi region.
        if (dp < 0) { return LEFT_VORONOI_REGION; }
        // If the point is beyond the end of the line, it is in the
        // right voronoi region.
        else if (dp > len2) { return RIGHT_VORONOI_REGION; }
        // Otherwise, it's in the middle one.
        else { return MIDDLE_VORONOI_REGION; }
      }
      // Constants for Voronoi regions
      /**
       * @const
       */
      var LEFT_VORONOI_REGION = -1;
      /**
       * @const
       */
      var MIDDLE_VORONOI_REGION = 0;
      /**
       * @const
       */
      var RIGHT_VORONOI_REGION = 1;

      // ## Collision Tests

      // Check if a point is inside a circle.
      /**
       * @param {Vector} p The point to test.
       * @param {Circle} c The circle to test.
       * @return {boolean} true if the point is inside the circle, false if it is not.
       */
      function pointInCircle(p, c) {
        var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);
        var radiusSq = c['r'] * c['r'];
        var distanceSq = differenceV.len2();
        T_VECTORS.push(differenceV);
        // If the distance between is smaller than the radius then the point is inside the circle.
        return distanceSq <= radiusSq;
      }
      SAT['pointInCircle'] = pointInCircle;

      // Check if a point is inside a convex polygon.
      /**
       * @param {Vector} p The point to test.
       * @param {Polygon} poly The polygon to test.
       * @return {boolean} true if the point is inside the polygon, false if it is not.
       */
      function pointInPolygon(p, poly) {
        TEST_POINT['pos'].copy(p);
        T_RESPONSE.clear();
        var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);
        if (result) {
          result = T_RESPONSE['aInB'];
        }
        return result;
      }
      SAT['pointInPolygon'] = pointInPolygon;

      // Check if two circles collide.
      /**
       * @param {Circle} a The first circle.
       * @param {Circle} b The second circle.
       * @param {Response=} response Response object (optional) that will be populated if
       *   the circles intersect.
       * @return {boolean} true if the circles intersect, false if they don't.
       */
      function testCircleCircle(a, b, response) {
        // Check if the distance between the centers of the two
        // circles is greater than their combined radius.
        var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);
        var totalRadius = a['r'] + b['r'];
        var totalRadiusSq = totalRadius * totalRadius;
        var distanceSq = differenceV.len2();
        // If the distance is bigger than the combined radius, they don't intersect.
        if (distanceSq > totalRadiusSq) {
          T_VECTORS.push(differenceV);
          return false;
        }
        // They intersect.  If we're calculating a response, calculate the overlap.
        if (response) {
          var dist = Math.sqrt(distanceSq);
          response['a'] = a;
          response['b'] = b;
          response['overlap'] = totalRadius - dist;
          response['overlapN'].copy(differenceV.normalize());
          response['overlapV'].copy(differenceV).scale(response['overlap']);
          response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];
          response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];
        }
        T_VECTORS.push(differenceV);
        return true;
      }
      SAT['testCircleCircle'] = testCircleCircle;

      // Check if a polygon and a circle collide.
      /**
       * @param {Polygon} polygon The polygon.
       * @param {Circle} circle The circle.
       * @param {Response=} response Response object (optional) that will be populated if
       *   they interset.
       * @return {boolean} true if they intersect, false if they don't.
       */
      function testPolygonCircle(polygon, circle, response) {
        // Get the position of the circle relative to the polygon.
        var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);
        var radius = circle['r'];
        var radius2 = radius * radius;
        var points = polygon['calcPoints'];
        var len = points.length;
        var edge = T_VECTORS.pop();
        var point = T_VECTORS.pop();

        // For each edge in the polygon:
        for (var i = 0; i < len; i++) {
          var next = i === len - 1 ? 0 : i + 1;
          var prev = i === 0 ? len - 1 : i - 1;
          var overlap = 0;
          var overlapN = null;

          // Get the edge.
          edge.copy(polygon['edges'][i]);
          // Calculate the center of the circle relative to the starting point of the edge.
          point.copy(circlePos).sub(points[i]);

          // If the distance between the center of the circle and the point
          // is bigger than the radius, the polygon is definitely not fully in
          // the circle.
          if (response && point.len2() > radius2) {
            response['aInB'] = false;
          }

          // Calculate which Voronoi region the center of the circle is in.
          var region = voronoiRegion(edge, point);
          // If it's the left region:
          if (region === LEFT_VORONOI_REGION) {
            // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.
            edge.copy(polygon['edges'][prev]);
            // Calculate the center of the circle relative the starting point of the previous edge
            var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);
            region = voronoiRegion(edge, point2);
            if (region === RIGHT_VORONOI_REGION) {
              // It's in the region we want.  Check if the circle intersects the point.
              var dist = point.len();
              if (dist > radius) {
                // No intersection
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(point);
                T_VECTORS.push(point2);
                return false;
              } else if (response) {
                // It intersects, calculate the overlap.
                response['bInA'] = false;
                overlapN = point.normalize();
                overlap = radius - dist;
              }
            }
            T_VECTORS.push(point2);
            // If it's the right region:
          } else if (region === RIGHT_VORONOI_REGION) {
            // We need to make sure we're in the left region on the next edge
            edge.copy(polygon['edges'][next]);
            // Calculate the center of the circle relative to the starting point of the next edge.
            point.copy(circlePos).sub(points[next]);
            region = voronoiRegion(edge, point);
            if (region === LEFT_VORONOI_REGION) {
              // It's in the region we want.  Check if the circle intersects the point.
              var dist = point.len();
              if (dist > radius) {
                // No intersection
                T_VECTORS.push(circlePos);
                T_VECTORS.push(edge);
                T_VECTORS.push(point);
                return false;
              } else if (response) {
                // It intersects, calculate the overlap.
                response['bInA'] = false;
                overlapN = point.normalize();
                overlap = radius - dist;
              }
            }
            // Otherwise, it's the middle region:
          } else {
            // Need to check if the circle is intersecting the edge,
            // Change the edge into its "edge normal".
            var normal = edge.perp().normalize();
            // Find the perpendicular distance between the center of the
            // circle and the edge.
            var dist = point.dot(normal);
            var distAbs = Math.abs(dist);
            // If the circle is on the outside of the edge, there is no intersection.
            if (dist > 0 && distAbs > radius) {
              // No intersection
              T_VECTORS.push(circlePos);
              T_VECTORS.push(normal);
              T_VECTORS.push(point);
              return false;
            } else if (response) {
              // It intersects, calculate the overlap.
              overlapN = normal;
              overlap = radius - dist;
              // If the center of the circle is on the outside of the edge, or part of the
              // circle is on the outside, the circle is not fully inside the polygon.
              if (dist >= 0 || overlap < 2 * radius) {
                response['bInA'] = false;
              }
            }
          }

          // If this is the smallest overlap we've seen, keep it.
          // (overlapN may be null if the circle was in the wrong Voronoi region).
          if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {
            response['overlap'] = overlap;
            response['overlapN'].copy(overlapN);
          }
        }

        // Calculate the final overlap vector - based on the smallest overlap.
        if (response) {
          response['a'] = polygon;
          response['b'] = circle;
          response['overlapV'].copy(response['overlapN']).scale(response['overlap']);
        }
        T_VECTORS.push(circlePos);
        T_VECTORS.push(edge);
        T_VECTORS.push(point);
        return true;
      }
      SAT['testPolygonCircle'] = testPolygonCircle;

      // Check if a circle and a polygon collide.
      //
      // **NOTE:** This is slightly less efficient than polygonCircle as it just
      // runs polygonCircle and reverses everything at the end.
      /**
       * @param {Circle} circle The circle.
       * @param {Polygon} polygon The polygon.
       * @param {Response=} response Response object (optional) that will be populated if
       *   they interset.
       * @return {boolean} true if they intersect, false if they don't.
       */
      function testCirclePolygon(circle, polygon, response) {
        // Test the polygon against the circle.
        var result = testPolygonCircle(polygon, circle, response);
        if (result && response) {
          // Swap A and B in the response.
          var a = response['a'];
          var aInB = response['aInB'];
          response['overlapN'].reverse();
          response['overlapV'].reverse();
          response['a'] = response['b'];
          response['b'] = a;
          response['aInB'] = response['bInA'];
          response['bInA'] = aInB;
        }
        return result;
      }
      SAT['testCirclePolygon'] = testCirclePolygon;

      // Checks whether polygons collide.
      /**
       * @param {Polygon} a The first polygon.
       * @param {Polygon} b The second polygon.
       * @param {Response=} response Response object (optional) that will be populated if
       *   they interset.
       * @return {boolean} true if they intersect, false if they don't.
       */
      function testPolygonPolygon(a, b, response) {
        var aPoints = a['calcPoints'];
        var aLen = aPoints.length;
        var bPoints = b['calcPoints'];
        var bLen = bPoints.length;
        // If any of the edge normals of A is a separating axis, no intersection.
        for (var i = 0; i < aLen; i++) {
          if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {
            return false;
          }
        }
        // If any of the edge normals of B is a separating axis, no intersection.
        for (var i = 0; i < bLen; i++) {
          if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {
            return false;
          }
        }
        // Since none of the edge normals of A or B are a separating axis, there is an intersection
        // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the
        // final overlap vector.
        if (response) {
          response['a'] = a;
          response['b'] = b;
          response['overlapV'].copy(response['overlapN']).scale(response['overlap']);
        }
        return true;
      }
      SAT['testPolygonPolygon'] = testPolygonPolygon;

      return SAT;
    }));
    });

    /* src/components/picture.svelte generated by Svelte v3.43.0 */
    const file$k = "src/components/picture.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[24] = list[i];
    	child_ctx[26] = i;
    	return child_ctx;
    }

    // (58:0) {:else}
    function create_else_block$7(ctx) {
    	let picture;
    	let t;
    	let img;
    	let img_srcset_value;
    	let img_loading_value;
    	let mounted;
    	let dispose;
    	let each_value = /*imageExtensionsShort*/ ctx[14].filter(func$1);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			picture = element("picture");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			img = element("img");
    			attr_dev(img, "class", /*imgClass*/ ctx[6]);
    			attr_dev(img, "sizes", /*sizes*/ ctx[1]);
    			attr_dev(img, "srcset", img_srcset_value = /*resolveSrcsets*/ ctx[19](/*imageDirectory*/ ctx[13], /*imageExtensionsShort*/ ctx[14], /*imageSizes*/ ctx[15], /*imageId*/ ctx[0], /*loading*/ ctx[18], /*tinyImageExtensionsShort*/ ctx[16], /*tinyImageSize*/ ctx[17])[getSafeImageExtensionIndex(/*imageExtensionsShort*/ ctx[14].filter(func_1$1))]);
    			attr_dev(img, "alt", /*alt*/ ctx[2]);
    			attr_dev(img, "width", /*width*/ ctx[3]);
    			attr_dev(img, "height", /*height*/ ctx[4]);
    			attr_dev(img, "loading", img_loading_value = /*loadLazy*/ ctx[10] ? 'lazy' : 'eager');
    			add_location(img, file$k, 62, 4, 2628);
    			attr_dev(picture, "class", /*pictureClass*/ ctx[5]);
    			attr_dev(picture, "title", /*title*/ ctx[8]);
    			attr_dev(picture, "style", /*style*/ ctx[9]);
    			add_location(picture, file$k, 58, 2, 2301);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, picture, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(picture, null);
    			}

    			append_dev(picture, t);
    			append_dev(picture, img);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						img,
    						"load",
    						function () {
    							if (is_function(/*loadEventDispatcher*/ ctx[20](/*groupId*/ ctx[11], /*groupImagesCount*/ ctx[12]))) /*loadEventDispatcher*/ ctx[20](/*groupId*/ ctx[11], /*groupImagesCount*/ ctx[12]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						picture,
    						"click",
    						function () {
    							if (is_function(/*click*/ ctx[7])) /*click*/ ctx[7].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*imageExtensionsShort, sizes, resolveSrcsets, imageDirectory, imageSizes, imageId, loading, tinyImageExtensionsShort, tinyImageSize*/ 1040387) {
    				each_value = /*imageExtensionsShort*/ ctx[14].filter(func$1);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(picture, t);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*imgClass*/ 64) {
    				attr_dev(img, "class", /*imgClass*/ ctx[6]);
    			}

    			if (dirty & /*sizes*/ 2) {
    				attr_dev(img, "sizes", /*sizes*/ ctx[1]);
    			}

    			if (dirty & /*imageDirectory, imageExtensionsShort, imageSizes, imageId, loading, tinyImageExtensionsShort, tinyImageSize*/ 516097 && img_srcset_value !== (img_srcset_value = /*resolveSrcsets*/ ctx[19](/*imageDirectory*/ ctx[13], /*imageExtensionsShort*/ ctx[14], /*imageSizes*/ ctx[15], /*imageId*/ ctx[0], /*loading*/ ctx[18], /*tinyImageExtensionsShort*/ ctx[16], /*tinyImageSize*/ ctx[17])[getSafeImageExtensionIndex(/*imageExtensionsShort*/ ctx[14].filter(func_1$1))])) {
    				attr_dev(img, "srcset", img_srcset_value);
    			}

    			if (dirty & /*alt*/ 4) {
    				attr_dev(img, "alt", /*alt*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 8) {
    				attr_dev(img, "width", /*width*/ ctx[3]);
    			}

    			if (dirty & /*height*/ 16) {
    				attr_dev(img, "height", /*height*/ ctx[4]);
    			}

    			if (dirty & /*loadLazy*/ 1024 && img_loading_value !== (img_loading_value = /*loadLazy*/ ctx[10] ? 'lazy' : 'eager')) {
    				attr_dev(img, "loading", img_loading_value);
    			}

    			if (dirty & /*pictureClass*/ 32) {
    				attr_dev(picture, "class", /*pictureClass*/ ctx[5]);
    			}

    			if (dirty & /*title*/ 256) {
    				attr_dev(picture, "title", /*title*/ ctx[8]);
    			}

    			if (dirty & /*style*/ 512) {
    				attr_dev(picture, "style", /*style*/ ctx[9]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(picture);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(58:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (54:0) {#if imageExtensionsShort.includes('svg')}
    function create_if_block$d(ctx) {
    	let picture;
    	let img;
    	let img_src_value;
    	let img_loading_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			picture = element("picture");
    			img = element("img");
    			attr_dev(img, "class", /*imgClass*/ ctx[6]);
    			if (!src_url_equal(img.src, img_src_value = "" + (/*imageDirectory*/ ctx[13] + /*imageId*/ ctx[0] + ".svg"))) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", /*alt*/ ctx[2]);
    			attr_dev(img, "width", /*width*/ ctx[3]);
    			attr_dev(img, "height", /*height*/ ctx[4]);
    			attr_dev(img, "loading", img_loading_value = /*loadLazy*/ ctx[10] ? 'lazy' : 'eager');
    			add_location(img, file$k, 55, 4, 2101);
    			attr_dev(picture, "class", /*pictureClass*/ ctx[5]);
    			attr_dev(picture, "title", /*title*/ ctx[8]);
    			attr_dev(picture, "style", /*style*/ ctx[9]);
    			add_location(picture, file$k, 54, 2, 2033);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, picture, anchor);
    			append_dev(picture, img);

    			if (!mounted) {
    				dispose = [
    					listen_dev(
    						img,
    						"load",
    						function () {
    							if (is_function(/*loadEventDispatcher*/ ctx[20](/*groupId*/ ctx[11], /*groupImagesCount*/ ctx[12]))) /*loadEventDispatcher*/ ctx[20](/*groupId*/ ctx[11], /*groupImagesCount*/ ctx[12]).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(
    						picture,
    						"click",
    						function () {
    							if (is_function(/*click*/ ctx[7])) /*click*/ ctx[7].apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*imgClass*/ 64) {
    				attr_dev(img, "class", /*imgClass*/ ctx[6]);
    			}

    			if (dirty & /*imageDirectory, imageId*/ 8193 && !src_url_equal(img.src, img_src_value = "" + (/*imageDirectory*/ ctx[13] + /*imageId*/ ctx[0] + ".svg"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*alt*/ 4) {
    				attr_dev(img, "alt", /*alt*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 8) {
    				attr_dev(img, "width", /*width*/ ctx[3]);
    			}

    			if (dirty & /*height*/ 16) {
    				attr_dev(img, "height", /*height*/ ctx[4]);
    			}

    			if (dirty & /*loadLazy*/ 1024 && img_loading_value !== (img_loading_value = /*loadLazy*/ ctx[10] ? 'lazy' : 'eager')) {
    				attr_dev(img, "loading", img_loading_value);
    			}

    			if (dirty & /*pictureClass*/ 32) {
    				attr_dev(picture, "class", /*pictureClass*/ ctx[5]);
    			}

    			if (dirty & /*title*/ 256) {
    				attr_dev(picture, "title", /*title*/ ctx[8]);
    			}

    			if (dirty & /*style*/ 512) {
    				attr_dev(picture, "style", /*style*/ ctx[9]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(picture);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(54:0) {#if imageExtensionsShort.includes('svg')}",
    		ctx
    	});

    	return block;
    }

    // (60:4) {#each imageExtensionsShort.filter(v => v != 'svg') as ext, i}
    function create_each_block$9(ctx) {
    	let source;
    	let source_type_value;
    	let source_srcset_value;

    	const block = {
    		c: function create() {
    			source = element("source");
    			attr_dev(source, "type", source_type_value = "image/" + /*ext*/ ctx[24]);
    			attr_dev(source, "sizes", /*sizes*/ ctx[1]);
    			attr_dev(source, "srcset", source_srcset_value = /*resolveSrcsets*/ ctx[19](/*imageDirectory*/ ctx[13], /*imageExtensionsShort*/ ctx[14], /*imageSizes*/ ctx[15], /*imageId*/ ctx[0], /*loading*/ ctx[18], /*tinyImageExtensionsShort*/ ctx[16], /*tinyImageSize*/ ctx[17])[/*i*/ ctx[26]]);
    			add_location(source, file$k, 60, 6, 2438);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, source, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*imageExtensionsShort*/ 16384 && source_type_value !== (source_type_value = "image/" + /*ext*/ ctx[24])) {
    				attr_dev(source, "type", source_type_value);
    			}

    			if (dirty & /*sizes*/ 2) {
    				attr_dev(source, "sizes", /*sizes*/ ctx[1]);
    			}

    			if (dirty & /*imageDirectory, imageExtensionsShort, imageSizes, imageId, loading, tinyImageExtensionsShort, tinyImageSize*/ 516097 && source_srcset_value !== (source_srcset_value = /*resolveSrcsets*/ ctx[19](/*imageDirectory*/ ctx[13], /*imageExtensionsShort*/ ctx[14], /*imageSizes*/ ctx[15], /*imageId*/ ctx[0], /*loading*/ ctx[18], /*tinyImageExtensionsShort*/ ctx[16], /*tinyImageSize*/ ctx[17])[/*i*/ ctx[26]])) {
    				attr_dev(source, "srcset", source_srcset_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(source);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(60:4) {#each imageExtensionsShort.filter(v => v != 'svg') as ext, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let show_if;
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*imageExtensionsShort*/ 16384) show_if = !!/*imageExtensionsShort*/ ctx[14].includes('svg');
    		if (show_if) return create_if_block$d;
    		return create_else_block$7;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getSafeImageExtensionIndex(imageExtensionsShort) {
    	return imageExtensionsShort.findIndex(i => i == "jpg" || i == "png") || 0;
    }

    const func$1 = v => v != 'svg';
    const func_1$1 = v => v != 'svg';

    function instance$n($$self, $$props, $$invalidate) {
    	let $sync;
    	validate_store(sync, 'sync');
    	component_subscribe($$self, sync, $$value => $$invalidate(23, $sync = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Picture', slots, []);
    	let { contents = {}, imageId, sizes = "100vw", alt = `${imageId}`, width, height, pictureClass, imgClass, click, title, style, useTiny, loadLazy = true, groupId, groupImagesCount, imageDirectory = contents.imageDirectory || globalSettings.imageDirectory, imageExtensionsShort = contents.imageExtensionsShort || globalSettings.imageExtensionsShort, imageSizes = contents.imageSizes || globalSettings.imageSizes, tinyImageExtensionsShort = contents.tinyImageExtensionsShort || globalSettings.tinyImageExtensionsShort, tinyImageSize = contents.tinyImageSize || globalSettings.tinyImageSize } = $$props;
    	let loading = true;
    	addEventListener('load', () => $$invalidate(18, loading = false));

    	function resolveSrcsets(
    		imageDirectory,
    	imageExtensionsShort,
    	imageSizes,
    	imageId,
    	loading,
    	tinyImageExtensionsShort,
    	tinyImageSize
    	) {
    		return (loading && useTiny
    		? tinyImageExtensionsShort
    		: imageExtensionsShort).map(ext => {
    			if (loading && useTiny) {
    				return `${imageDirectory}${imageId}@${tinyImageSize}w.${ext} ${tinyImageSize}w`;
    			} else {
    				return imageSizes.map(size => `${imageDirectory}${imageId}@${size}w.${ext} ${size}w`);
    			}
    		});
    	}

    	function loadEventDispatcher(groupId, groupImagesCount) {
    		if (groupId) {
    			set_store_value(sync, $sync.loadImagesCount = $sync.loadImagesCount || {}, $sync);

    			set_store_value(
    				sync,
    				$sync.loadImagesCount[groupId] = $sync.loadImagesCount[groupId] > 0
    				? $sync.loadImagesCount[groupId] + 1
    				: 1,
    				$sync
    			);

    			if ($sync.loadImagesCount[groupId] >= groupImagesCount && !$sync.loadEventDispatched) {
    				window.dispatchEvent(new CustomEvent('pictureGroup_load', { detail: groupId }));
    				set_store_value(sync, $sync.loadEventDispatched = true, $sync);
    			}
    		}
    	}

    	const writable_props = [
    		'contents',
    		'imageId',
    		'sizes',
    		'alt',
    		'width',
    		'height',
    		'pictureClass',
    		'imgClass',
    		'click',
    		'title',
    		'style',
    		'useTiny',
    		'loadLazy',
    		'groupId',
    		'groupImagesCount',
    		'imageDirectory',
    		'imageExtensionsShort',
    		'imageSizes',
    		'tinyImageExtensionsShort',
    		'tinyImageSize'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Picture> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('contents' in $$props) $$invalidate(21, contents = $$props.contents);
    		if ('imageId' in $$props) $$invalidate(0, imageId = $$props.imageId);
    		if ('sizes' in $$props) $$invalidate(1, sizes = $$props.sizes);
    		if ('alt' in $$props) $$invalidate(2, alt = $$props.alt);
    		if ('width' in $$props) $$invalidate(3, width = $$props.width);
    		if ('height' in $$props) $$invalidate(4, height = $$props.height);
    		if ('pictureClass' in $$props) $$invalidate(5, pictureClass = $$props.pictureClass);
    		if ('imgClass' in $$props) $$invalidate(6, imgClass = $$props.imgClass);
    		if ('click' in $$props) $$invalidate(7, click = $$props.click);
    		if ('title' in $$props) $$invalidate(8, title = $$props.title);
    		if ('style' in $$props) $$invalidate(9, style = $$props.style);
    		if ('useTiny' in $$props) $$invalidate(22, useTiny = $$props.useTiny);
    		if ('loadLazy' in $$props) $$invalidate(10, loadLazy = $$props.loadLazy);
    		if ('groupId' in $$props) $$invalidate(11, groupId = $$props.groupId);
    		if ('groupImagesCount' in $$props) $$invalidate(12, groupImagesCount = $$props.groupImagesCount);
    		if ('imageDirectory' in $$props) $$invalidate(13, imageDirectory = $$props.imageDirectory);
    		if ('imageExtensionsShort' in $$props) $$invalidate(14, imageExtensionsShort = $$props.imageExtensionsShort);
    		if ('imageSizes' in $$props) $$invalidate(15, imageSizes = $$props.imageSizes);
    		if ('tinyImageExtensionsShort' in $$props) $$invalidate(16, tinyImageExtensionsShort = $$props.tinyImageExtensionsShort);
    		if ('tinyImageSize' in $$props) $$invalidate(17, tinyImageSize = $$props.tinyImageSize);
    	};

    	$$self.$capture_state = () => ({
    		sync,
    		globalSettings,
    		contents,
    		imageId,
    		sizes,
    		alt,
    		width,
    		height,
    		pictureClass,
    		imgClass,
    		click,
    		title,
    		style,
    		useTiny,
    		loadLazy,
    		groupId,
    		groupImagesCount,
    		imageDirectory,
    		imageExtensionsShort,
    		imageSizes,
    		tinyImageExtensionsShort,
    		tinyImageSize,
    		loading,
    		resolveSrcsets,
    		getSafeImageExtensionIndex,
    		loadEventDispatcher,
    		$sync
    	});

    	$$self.$inject_state = $$props => {
    		if ('contents' in $$props) $$invalidate(21, contents = $$props.contents);
    		if ('imageId' in $$props) $$invalidate(0, imageId = $$props.imageId);
    		if ('sizes' in $$props) $$invalidate(1, sizes = $$props.sizes);
    		if ('alt' in $$props) $$invalidate(2, alt = $$props.alt);
    		if ('width' in $$props) $$invalidate(3, width = $$props.width);
    		if ('height' in $$props) $$invalidate(4, height = $$props.height);
    		if ('pictureClass' in $$props) $$invalidate(5, pictureClass = $$props.pictureClass);
    		if ('imgClass' in $$props) $$invalidate(6, imgClass = $$props.imgClass);
    		if ('click' in $$props) $$invalidate(7, click = $$props.click);
    		if ('title' in $$props) $$invalidate(8, title = $$props.title);
    		if ('style' in $$props) $$invalidate(9, style = $$props.style);
    		if ('useTiny' in $$props) $$invalidate(22, useTiny = $$props.useTiny);
    		if ('loadLazy' in $$props) $$invalidate(10, loadLazy = $$props.loadLazy);
    		if ('groupId' in $$props) $$invalidate(11, groupId = $$props.groupId);
    		if ('groupImagesCount' in $$props) $$invalidate(12, groupImagesCount = $$props.groupImagesCount);
    		if ('imageDirectory' in $$props) $$invalidate(13, imageDirectory = $$props.imageDirectory);
    		if ('imageExtensionsShort' in $$props) $$invalidate(14, imageExtensionsShort = $$props.imageExtensionsShort);
    		if ('imageSizes' in $$props) $$invalidate(15, imageSizes = $$props.imageSizes);
    		if ('tinyImageExtensionsShort' in $$props) $$invalidate(16, tinyImageExtensionsShort = $$props.tinyImageExtensionsShort);
    		if ('tinyImageSize' in $$props) $$invalidate(17, tinyImageSize = $$props.tinyImageSize);
    		if ('loading' in $$props) $$invalidate(18, loading = $$props.loading);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		imageId,
    		sizes,
    		alt,
    		width,
    		height,
    		pictureClass,
    		imgClass,
    		click,
    		title,
    		style,
    		loadLazy,
    		groupId,
    		groupImagesCount,
    		imageDirectory,
    		imageExtensionsShort,
    		imageSizes,
    		tinyImageExtensionsShort,
    		tinyImageSize,
    		loading,
    		resolveSrcsets,
    		loadEventDispatcher,
    		contents,
    		useTiny
    	];
    }

    class Picture extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$n, create_fragment$n, safe_not_equal, {
    			contents: 21,
    			imageId: 0,
    			sizes: 1,
    			alt: 2,
    			width: 3,
    			height: 4,
    			pictureClass: 5,
    			imgClass: 6,
    			click: 7,
    			title: 8,
    			style: 9,
    			useTiny: 22,
    			loadLazy: 10,
    			groupId: 11,
    			groupImagesCount: 12,
    			imageDirectory: 13,
    			imageExtensionsShort: 14,
    			imageSizes: 15,
    			tinyImageExtensionsShort: 16,
    			tinyImageSize: 17
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Picture",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*imageId*/ ctx[0] === undefined && !('imageId' in props)) {
    			console.warn("<Picture> was created without expected prop 'imageId'");
    		}

    		if (/*width*/ ctx[3] === undefined && !('width' in props)) {
    			console.warn("<Picture> was created without expected prop 'width'");
    		}

    		if (/*height*/ ctx[4] === undefined && !('height' in props)) {
    			console.warn("<Picture> was created without expected prop 'height'");
    		}

    		if (/*pictureClass*/ ctx[5] === undefined && !('pictureClass' in props)) {
    			console.warn("<Picture> was created without expected prop 'pictureClass'");
    		}

    		if (/*imgClass*/ ctx[6] === undefined && !('imgClass' in props)) {
    			console.warn("<Picture> was created without expected prop 'imgClass'");
    		}

    		if (/*click*/ ctx[7] === undefined && !('click' in props)) {
    			console.warn("<Picture> was created without expected prop 'click'");
    		}

    		if (/*title*/ ctx[8] === undefined && !('title' in props)) {
    			console.warn("<Picture> was created without expected prop 'title'");
    		}

    		if (/*style*/ ctx[9] === undefined && !('style' in props)) {
    			console.warn("<Picture> was created without expected prop 'style'");
    		}

    		if (/*useTiny*/ ctx[22] === undefined && !('useTiny' in props)) {
    			console.warn("<Picture> was created without expected prop 'useTiny'");
    		}

    		if (/*groupId*/ ctx[11] === undefined && !('groupId' in props)) {
    			console.warn("<Picture> was created without expected prop 'groupId'");
    		}

    		if (/*groupImagesCount*/ ctx[12] === undefined && !('groupImagesCount' in props)) {
    			console.warn("<Picture> was created without expected prop 'groupImagesCount'");
    		}
    	}

    	get contents() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageId() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageId(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sizes() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sizes(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get alt() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set alt(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pictureClass() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pictureClass(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imgClass() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imgClass(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get click() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set click(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get useTiny() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set useTiny(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadLazy() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadLazy(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupId() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupId(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupImagesCount() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupImagesCount(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageDirectory() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageDirectory(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageExtensionsShort() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageExtensionsShort(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageSizes() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageSizes(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tinyImageExtensionsShort() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tinyImageExtensionsShort(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tinyImageSize() {
    		throw new Error("<Picture>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tinyImageSize(value) {
    		throw new Error("<Picture>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/nav-header.svelte generated by Svelte v3.43.0 */

    const { Object: Object_1$1, window: window_1 } = globals;
    const file$j = "src/components/nav-header.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    // (303:4) {#each contents.items as item}
    function create_each_block$8(ctx) {
    	let div;
    	let t_value = /*item*/ ctx[23].label + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[14](/*item*/ ctx[23]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text$1(t_value);
    			attr_dev(div, "class", "header_navigation_list_items svelte-x3s4f9");
    			add_location(div, file$j, 303, 6, 14072);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*contents*/ 1 && t_value !== (t_value = /*item*/ ctx[23].label + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(303:4) {#each contents.items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let header_1;
    	let picture;
    	let t0;
    	let input;
    	let t1;
    	let label0;
    	let div0;
    	let svg0;
    	let path0;
    	let path1;
    	let t2;
    	let nav;
    	let label1;
    	let span2;
    	let span0;
    	let t4;
    	let span1;
    	let t6;
    	let svg1;
    	let path2;
    	let path3;
    	let t7;
    	let div1;
    	let t8;
    	let t9;
    	let div2;
    	let svg2;
    	let t10;
    	let div3;
    	let t11;
    	let div4;
    	let current;
    	let mounted;
    	let dispose;

    	picture = new Picture({
    			props: {
    				click: /*func*/ ctx[8],
    				title: "" + (location.pathname == "/" && location.hash == ""
    				? ""
    				: "") + "",
    				pictureClass: "header_picture",
    				imgClass: "header_logo",
    				contents: /*contents*/ ctx[0],
    				globalSettings: /*globalSettings*/ ctx[1],
    				imageId: /*contents*/ ctx[0].imageId,
    				width: /*contents*/ ctx[0].aspectRatio.width,
    				height: /*contents*/ ctx[0].aspectRatio.height
    			},
    			$$inline: true
    		});

    	let each_value = /*contents*/ ctx[0].items;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			header_1 = element("header");
    			create_component(picture.$$.fragment);
    			t0 = space();
    			input = element("input");
    			t1 = space();
    			label0 = element("label");
    			div0 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			t2 = space();
    			nav = element("nav");
    			label1 = element("label");
    			span2 = element("span");
    			span0 = element("span");
    			span0.textContent = "";
    			t4 = text$1("");
    			span1 = element("span");
    			span1.textContent = "";
    			t6 = space();
    			svg1 = svg_element("svg");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			t7 = space();
    			div1 = element("div");
    			t8 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			div2 = element("div");
    			svg2 = svg_element("svg");
    			t10 = space();
    			div3 = element("div");
    			t11 = space();
    			div4 = element("div");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "class", "ui_button header_button_checkbox svelte-x3s4f9");
    			input.checked = true;
    			attr_dev(input, "name", "header_button_checkbox");
    			attr_dev(input, "id", "header_button_checkbox");
    			add_location(input, file$j, 282, 2, 12585);
    			attr_dev(path0, "d", "M0 0h24v24H0z");
    			attr_dev(path0, "fill", "none");
    			add_location(path0, file$j, 286, 8, 13080);
    			attr_dev(path1, "d", "M12 2L4.5 20.29l.71.71L12 18l6.79 3 .71-.71z");
    			attr_dev(path1, "stroke", "#444");
    			add_location(path1, file$j, 287, 8, 13127);
    			attr_dev(svg0, "class", "header_button_svg svelte-x3s4f9");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			add_location(svg0, file$j, 285, 6, 13020);
    			attr_dev(div0, "class", "header_button_svg-wrapper svelte-x3s4f9");
    			set_style(div0, "--arrow-x", /*gameProps*/ ctx[4].arrow.x + "px");
    			set_style(div0, "--arrow-y", /*gameProps*/ ctx[4].arrow.y + "px");
    			set_style(div0, "--arrow-r", /*gameProps*/ ctx[4].arrow.r + "deg");
    			add_location(div0, file$j, 284, 4, 12832);
    			attr_dev(label0, "for", "header_button_checkbox");
    			attr_dev(label0, "class", "header_button svelte-x3s4f9");
    			attr_dev(label0, "title", "");
    			add_location(label0, file$j, 283, 2, 12739);
    			attr_dev(span0, "class", "break-scope svelte-x3s4f9");
    			add_location(span0, file$j, 294, 10, 13455);
    			attr_dev(span1, "class", "break-scope svelte-x3s4f9");
    			add_location(span1, file$j, 294, 51, 13496);
    			attr_dev(span2, "class", "header_navigation_close_button_text svelte-x3s4f9");
    			add_location(span2, file$j, 293, 8, 13394);
    			attr_dev(path2, "d", "M0 0h24v24H0z");
    			attr_dev(path2, "fill", "none");
    			add_location(path2, file$j, 297, 10, 13636);
    			attr_dev(path3, "d", "M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z");
    			add_location(path3, file$j, 298, 10, 13684);
    			attr_dev(svg1, "class", "header_navigation_close_button_svg svelte-x3s4f9");
    			attr_dev(svg1, "viewBox", "0 0 24 24");
    			add_location(svg1, file$j, 296, 8, 13557);
    			attr_dev(label1, "for", "header_button_checkbox");
    			attr_dev(label1, "class", "header_navigation_close_button svelte-x3s4f9");
    			add_location(label1, file$j, 292, 4, 13310);
    			attr_dev(div1, "class", "header_close_area svelte-x3s4f9");
    			add_location(div1, file$j, 301, 4, 13904);
    			attr_dev(svg2, "class", "header_button_svg svelte-x3s4f9");
    			attr_dev(svg2, "viewBox", "0 0 24 24");
    			attr_dev(svg2, "fill", "white");
    			add_location(svg2, file$j, 306, 6, 14235);
    			attr_dev(div2, "class", "header_button_dummy svelte-x3s4f9");
    			add_location(div2, file$j, 305, 4, 14195);
    			attr_dev(nav, "class", "header_navigation svelte-x3s4f9");
    			add_location(nav, file$j, 291, 2, 13274);

    			attr_dev(header_1, "title", window.CSS.supports(`(backdrop-filter:blur(10px)) or (-webkit-backdrop-filter:blur(10px)) or (-moz-backdrop-filter:blur(10px)`)
    			? ""
    			: "Firefoxabout:configbackdrop-filter");

    			set_style(header_1, "--itemsCount", /*contents*/ ctx[0].items.length);
    			attr_dev(header_1, "class", "svelte-x3s4f9");
    			add_location(header_1, file$j, 280, 0, 11872);
    			attr_dev(div3, "class", "game-background svelte-x3s4f9");
    			set_style(div3, "--bg", /*gameProps*/ ctx[4].hit ? '#f73f22' : '#000');
    			add_location(div3, file$j, 311, 0, 14343);
    			add_location(div4, file$j, 312, 0, 14470);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header_1, anchor);
    			mount_component(picture, header_1, null);
    			append_dev(header_1, t0);
    			append_dev(header_1, input);
    			/*input_binding*/ ctx[9](input);
    			append_dev(header_1, t1);
    			append_dev(header_1, label0);
    			append_dev(label0, div0);
    			append_dev(div0, svg0);
    			append_dev(svg0, path0);
    			append_dev(svg0, path1);
    			/*path1_binding*/ ctx[10](path1);
    			/*div0_binding*/ ctx[11](div0);
    			append_dev(header_1, t2);
    			append_dev(header_1, nav);
    			append_dev(nav, label1);
    			append_dev(label1, span2);
    			append_dev(span2, span0);
    			append_dev(span2, t4);
    			append_dev(span2, span1);
    			append_dev(label1, t6);
    			append_dev(label1, svg1);
    			append_dev(svg1, path2);
    			append_dev(svg1, path3);
    			append_dev(nav, t7);
    			append_dev(nav, div1);
    			append_dev(nav, t8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(nav, null);
    			}

    			append_dev(nav, t9);
    			append_dev(nav, div2);
    			append_dev(div2, svg2);
    			/*header_1_binding*/ ctx[15](header_1);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div3, anchor);
    			/*div3_binding*/ ctx[16](div3);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, div4, anchor);
    			/*div4_binding*/ ctx[17](div4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1, "keydown", /*handleKeyDown*/ ctx[6], false, false, false),
    					listen_dev(window_1, "keyup", /*keyup_handler*/ ctx[7], false, false, false),
    					listen_dev(div1, "click", /*click_handler*/ ctx[12], false, false, false),
    					listen_dev(div1, "touchstart", /*touchstart_handler*/ ctx[13], { passive: true }, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const picture_changes = {};
    			if (dirty & /*contents*/ 1) picture_changes.contents = /*contents*/ ctx[0];
    			if (dirty & /*globalSettings*/ 2) picture_changes.globalSettings = /*globalSettings*/ ctx[1];
    			if (dirty & /*contents*/ 1) picture_changes.imageId = /*contents*/ ctx[0].imageId;
    			if (dirty & /*contents*/ 1) picture_changes.width = /*contents*/ ctx[0].aspectRatio.width;
    			if (dirty & /*contents*/ 1) picture_changes.height = /*contents*/ ctx[0].aspectRatio.height;
    			picture.$set(picture_changes);

    			if (!current || dirty & /*gameProps*/ 16) {
    				set_style(div0, "--arrow-x", /*gameProps*/ ctx[4].arrow.x + "px");
    			}

    			if (!current || dirty & /*gameProps*/ 16) {
    				set_style(div0, "--arrow-y", /*gameProps*/ ctx[4].arrow.y + "px");
    			}

    			if (!current || dirty & /*gameProps*/ 16) {
    				set_style(div0, "--arrow-r", /*gameProps*/ ctx[4].arrow.r + "deg");
    			}

    			if (dirty & /*triggerSmoothScroll, contents*/ 33) {
    				each_value = /*contents*/ ctx[0].items;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(nav, t9);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*contents*/ 1) {
    				set_style(header_1, "--itemsCount", /*contents*/ ctx[0].items.length);
    			}

    			if (!current || dirty & /*gameProps*/ 16) {
    				set_style(div3, "--bg", /*gameProps*/ ctx[4].hit ? '#f73f22' : '#000');
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(picture.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(picture.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header_1);
    			destroy_component(picture);
    			/*input_binding*/ ctx[9](null);
    			/*path1_binding*/ ctx[10](null);
    			/*div0_binding*/ ctx[11](null);
    			destroy_each(each_blocks, detaching);
    			/*header_1_binding*/ ctx[15](null);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div3);
    			/*div3_binding*/ ctx[16](null);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(div4);
    			/*div4_binding*/ ctx[17](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const scroll_duration = 400; //ms

    function easeInOutCubic(x) {
    	return x < 0.5
    	? 4 * x * x * x
    	: 1 - Math.pow(-2 * x + 2, 3) / 2;
    }

    function map_range(value, low1, high1, low2, high2) {
    	return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nav_header', slots, []);
    	let { contents, globalSettings } = $$props;
    	let header, checkbox;
    	let abort_scroll = false;

    	function smoothScroll(time, start_time, origin, destination) {
    		if (time == start_time) {
    			$$invalidate(3, checkbox.checked = false, checkbox);
    			requestAnimationFrame(time => smoothScroll(time, start_time, origin, destination));
    			return;
    		}

    		if (abort_scroll) {
    			abort_scroll = false;
    			return;
    		}

    		scrollTo({
    			top: origin + (destination || origin * -1) * easeInOutCubic((time - start_time) / scroll_duration)
    		});

    		if (time - start_time > scroll_duration) return;
    		requestAnimationFrame(time => smoothScroll(time, start_time, origin, destination));
    	}

    	function triggerSmoothScroll(target) {
    		if (target != 'top') {
    			var targetElement = document.getElementById(target);
    		}

    		requestAnimationFrame(time => smoothScroll(time, time, window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0, target == "top"
    		? 0
    		: targetElement.getBoundingClientRect().top - header.clientHeight));
    	}

    	const gameProps = {
    		engaged: false,
    		startTime: null,
    		lastTime: null,
    		hit: false,
    		wasHit: false,
    		keysPressed: { w: false, a: false, s: false, d: false },
    		command: [
    			"ArrowUp",
    			"ArrowUp",
    			"ArrowDown",
    			"ArrowDown",
    			"ArrowLeft",
    			"ArrowRight",
    			"ArrowLeft",
    			"ArrowRight",
    			"b",
    			"a"
    		],
    		commandsCount: 0,
    		backgroundElement: null,
    		debug: null,
    		field: {
    			width: 0,
    			height: 0,
    			origin: { x: null, y: null }
    		},
    		arrow: {
    			element: null,
    			svgElement: null,
    			width: 0,
    			height: 0,
    			speed: 20,
    			collision: null,
    			x: 0,
    			y: 0,
    			r: 0,
    			offset: { x: null, y: null }
    		},
    		obstacles: {
    			lastAdded: null,
    			interval: 500,
    			duration: 2000,
    			width: 200,
    			height: 200,
    			parent: null,
    			elements: []
    		},
    		launch: {
    			launching: false,
    			launched: false,
    			distance: 0,
    			duration: 2000,
    			turn: {
    				turning: false,
    				startTime: null,
    				startPoint: { x: 0, y: 0 },
    				radius: 0
    			}
    		}
    	};

    	const customEasing = src(.25, -0.4, .75, 1);

    	function handleKeyDown(e) {
    		if (gameProps.engaged) {
    			if (Object.keys(gameProps.keysPressed).includes(e.key)) {
    				$$invalidate(4, gameProps.keysPressed[e.key] = true, gameProps);

    				if (gameProps.keysPressed.w && gameProps.keysPressed.s) {
    					switch (e.key) {
    						case 'w':
    							$$invalidate(4, gameProps.keysPressed.s = false, gameProps);
    							break;
    						case 's':
    							$$invalidate(4, gameProps.keysPressed.w = false, gameProps);
    							break;
    					}
    				}

    				if (gameProps.keysPressed.a && gameProps.keysPressed.d) {
    					switch (e.key) {
    						case 'a':
    							$$invalidate(4, gameProps.keysPressed.d = false, gameProps);
    							break;
    						case 'd':
    							$$invalidate(4, gameProps.keysPressed.a = false, gameProps);
    							break;
    					}
    				}
    			}
    		} else if (e.key == gameProps.command[gameProps.commandsCount] && checkbox.checked) {
    			if ($$invalidate(4, ++gameProps.commandsCount, gameProps) == gameProps.command.length) {
    				requestAnimationFrame(gameInit);
    				$$invalidate(4, gameProps.engaged = true, gameProps);
    				gameProps.backgroundElement.classList.add('shown');
    			}
    		} else $$invalidate(4, gameProps.commandsCount = 0, gameProps);
    	}

    	onMount(() => {
    		$$invalidate(3, checkbox = document.getElementById('header_button_checkbox'));

    		setTimeout(
    			() => {
    				$$invalidate(3, checkbox.checked = false, checkbox);
    			},
    			2000
    		);
    	});

    	function gameInit() {
    		$$invalidate(4, gameProps.arrow.width = gameProps.arrow.svgElement.getBoundingClientRect().width, gameProps);
    		$$invalidate(4, gameProps.arrow.height = gameProps.arrow.svgElement.getBoundingClientRect().height, gameProps);
    		$$invalidate(4, gameProps.arrow.offset.x = gameProps.arrow.svgElement.getBoundingClientRect().x, gameProps);
    		$$invalidate(4, gameProps.arrow.offset.y = gameProps.arrow.svgElement.getBoundingClientRect().y, gameProps);

    		$$invalidate(
    			4,
    			gameProps.arrow.collision = new SAT.Polygon(new SAT.Vector(),
    			[
    					new SAT.Vector(),
    					new SAT.Vector(gameProps.arrow.width, gameProps.arrow.height / 2),
    					new SAT.Vector(0, gameProps.arrow.height)
    				]),
    			gameProps
    		);

    		$$invalidate(4, gameProps.field.width = innerWidth, gameProps);
    		$$invalidate(4, gameProps.field.height = innerHeight, gameProps);
    		$$invalidate(4, gameProps.field.origin.x = gameProps.field.width - gameProps.arrow.x, gameProps);
    		$$invalidate(4, gameProps.field.origin.y = gameProps.field.height / 2, gameProps);
    		$$invalidate(4, gameProps.launch.turn.radius = (gameProps.field.height - gameProps.arrow.offset.y) / 4, gameProps);
    		$$invalidate(4, gameProps.launch.turn.startPoint.x = -(gameProps.field.width - (gameProps.field.width - gameProps.arrow.offset.x) * 2 - gameProps.launch.turn.radius), gameProps);
    		$$invalidate(4, gameProps.launch.turn.startPoint.y = gameProps.arrow.offset.y, gameProps);
    		$$invalidate(4, gameProps.launch.distance = gameProps.launch.turn.radius * Math.PI + Math.abs(gameProps.launch.turn.startPoint.x), gameProps);
    		$$invalidate(4, gameProps.obstacles.width = gameProps.field.width / 7, gameProps);
    		$$invalidate(4, gameProps.obstacles.height = gameProps.field.width / 7, gameProps);
    		requestAnimationFrame(gameUpdate);
    	}

    	function gameUpdate(time) {
    		$$invalidate(4, gameProps.wasHit = gameProps.hit, gameProps);
    		$$invalidate(4, gameProps.hit = false, gameProps);

    		if (gameProps.startTime == null) {
    			$$invalidate(4, gameProps.startTime = time, gameProps);
    		}

    		if (!gameProps.launch.launched) {
    			if (time - gameProps.startTime < gameProps.launch.duration) {
    				if (!gameProps.launch.turn.turning) {
    					$$invalidate(4, gameProps.arrow.x = -(customEasing((time - gameProps.startTime) / gameProps.launch.duration) * gameProps.launch.distance), gameProps);

    					if (gameProps.arrow.x < gameProps.launch.turn.startPoint.x) {
    						$$invalidate(4, gameProps.launch.turn.turning = true, gameProps);
    						$$invalidate(4, gameProps.launch.turn.startTime = time, gameProps);
    					}
    				} else {
    					$$invalidate(4, gameProps.arrow.x = Math.cos(map_range(customEasing((time - gameProps.startTime) / gameProps.launch.duration), customEasing((gameProps.launch.turn.startTime - gameProps.startTime) / gameProps.launch.duration), 1, 0.5, 1.5) * Math.PI) * gameProps.launch.turn.radius + gameProps.launch.turn.startPoint.x, gameProps);
    					$$invalidate(4, gameProps.arrow.y = Math.sin(map_range(customEasing((time - gameProps.startTime) / gameProps.launch.duration), customEasing((gameProps.launch.turn.startTime - gameProps.startTime) / gameProps.launch.duration), 1, 0.5, 1.5) * Math.PI) * -gameProps.launch.turn.radius + gameProps.launch.turn.startPoint.y + gameProps.launch.turn.radius, gameProps);
    					$$invalidate(4, gameProps.arrow.r = map_range(customEasing((time - gameProps.startTime) / gameProps.launch.duration), customEasing((gameProps.launch.turn.startTime - gameProps.startTime) / gameProps.launch.duration), 1, 0, -180), gameProps);
    				}
    			} else {
    				$$invalidate(4, gameProps.launch.launched = true, gameProps);
    				gameProps.arrow.collision.translate(gameProps.arrow.svgElement.getBoundingClientRect().x, gameProps.arrow.svgElement.getBoundingClientRect().y);
    			}
    		} else {
    			const delta = gameProps.arrow.speed * (time - gameProps.lastTime) / 60;

    			if (gameProps.keysPressed.w) {
    				const deltaFixed = delta - (gameProps.arrow.collision.calcPoints[0].y - delta < 0
    				? gameProps.arrow.speed
    				: 0);

    				$$invalidate(4, gameProps.arrow.y -= deltaFixed, gameProps);
    				gameProps.arrow.collision.translate(0, -deltaFixed);
    			}

    			if (gameProps.keysPressed.a) {
    				const deltaFixed = delta - (gameProps.arrow.collision.calcPoints[0].x - delta < 0
    				? gameProps.arrow.speed
    				: 0);

    				$$invalidate(4, gameProps.arrow.x -= deltaFixed, gameProps);
    				gameProps.arrow.collision.translate(-deltaFixed, 0);
    			}

    			if (gameProps.keysPressed.s) {
    				const deltaFixed = delta - (gameProps.arrow.collision.calcPoints[2].y + delta > gameProps.field.height
    				? gameProps.arrow.speed
    				: 0);

    				$$invalidate(4, gameProps.arrow.y += deltaFixed, gameProps);
    				gameProps.arrow.collision.translate(0, deltaFixed);
    			}

    			if (gameProps.keysPressed.d) {
    				const deltaFixed = delta - (gameProps.arrow.collision.calcPoints[1].x + delta > gameProps.field.width
    				? gameProps.arrow.speed
    				: 0);

    				$$invalidate(4, gameProps.arrow.x += deltaFixed, gameProps);
    				gameProps.arrow.collision.translate(deltaFixed, 0);
    			}

    			if (gameProps.obstacles.lastAdded == null) $$invalidate(4, gameProps.obstacles.lastAdded = time - gameProps.obstacles.interval, gameProps);

    			if (time - gameProps.obstacles.lastAdded >= gameProps.obstacles.interval) {
    				const obstacle = {};
    				obstacle.element = document.createElement('div');
    				obstacle.element.classList.add('game-obstacle');
    				obstacle.element.style.setProperty('--gameFieldWidth', gameProps.field.width + 'px');
    				obstacle.element.style.setProperty('--width', gameProps.obstacles.width + 'px');
    				obstacle.element.style.setProperty('--height', gameProps.obstacles.height + 'px');
    				obstacle.angle = Math.random() * 360 - 180;
    				obstacle.element.style.setProperty('--angle', obstacle.angle + 'deg');
    				obstacle.rotation = Math.random() * 360 * 4 - 360 * 2;
    				obstacle.element.style.setProperty('--rotation', obstacle.rotation + 'deg');
    				obstacle.startY = Math.random() * (gameProps.field.height + gameProps.obstacles.height) - gameProps.obstacles.height / 2;
    				obstacle.element.style.setProperty('--StartY', obstacle.startY + 'px');
    				obstacle.endY = Math.random() * (gameProps.field.height + gameProps.obstacles.height) - gameProps.obstacles.height;
    				obstacle.element.style.setProperty('--EndY', obstacle.endY + 'px');
    				obstacle.element.style.setProperty('--duration', gameProps.obstacles.duration + 'ms');
    				obstacle.collision = new SAT.Box(new SAT.Vector(gameProps.field.width, obstacle.startY), gameProps.obstacles.width, gameProps.obstacles.height).toPolygon();
    				obstacle.collision.translate(-gameProps.obstacles.width / 2, -gameProps.obstacles.height / 2);
    				obstacle.collision.rotate(-1 * obstacle.angle * (Math.PI / 180));
    				obstacle.collision.translate(gameProps.obstacles.width / 2, gameProps.obstacles.height / 2);
    				$$invalidate(4, gameProps.obstacles.lastAdded = time, gameProps);
    				obstacle.addedAt = time;
    				obstacle.destroyAt = time + gameProps.obstacles.duration;
    				gameProps.obstacles.parent.appendChild(obstacle.element);
    				gameProps.obstacles.elements.push(obstacle);
    			}

    			gameProps.obstacles.elements.forEach(v => {
    				if (time > v.destroyAt) {
    					v.element.remove();
    					$$invalidate(4, gameProps.obstacles.elements = gameProps.obstacles.elements.filter(w => w !== v), gameProps);
    				}
    			});

    			gameProps.obstacles.elements.forEach(v => {
    				const transformRatio = (time - v.addedAt) / gameProps.obstacles.duration;
    				const timePassed = time - gameProps.lastTime;
    				v.collision.setOffset(new SAT.Vector(-transformRatio * (gameProps.field.width + gameProps.obstacles.width), transformRatio * (v.endY - v.startY)));
    				v.collision.translate(-gameProps.obstacles.width / 2, -gameProps.obstacles.height / 2);
    				v.collision.rotate(-timePassed * v.rotation);
    				v.collision.translate(gameProps.obstacles.width / 2, gameProps.obstacles.height / 2);
    				const tmp = gameProps.hit;
    				$$invalidate(4, gameProps.hit = (SAT.testPolygonPolygon(v.collision, gameProps.arrow.collision, new SAT.Response()) || gameProps.hit) && !gameProps.wasHit, gameProps);

    				if (gameProps.hit && !tmp) {
    					v.element.style.backgroundColor = '#f00';
    				}
    			});
    		}

    		$$invalidate(4, gameProps.lastTime = time, gameProps);
    		$$invalidate(3, checkbox.checked = true, checkbox);
    		requestAnimationFrame(gameUpdate);
    	}

    	const writable_props = ['contents', 'globalSettings'];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Nav_header> was created with unknown prop '${key}'`);
    	});

    	const keyup_handler = e => {
    		if (Object.keys(gameProps.keysPressed).includes(e.key)) $$invalidate(4, gameProps.keysPressed[e.key] = false, gameProps);
    	};

    	const func = () => location.pathname == "/" && location.hash == ""
    	? triggerSmoothScroll('top')
    	: location.assign(location.origin);

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			checkbox = $$value;
    			$$invalidate(3, checkbox);
    		});
    	}

    	function path1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			gameProps.arrow.svgElement = $$value;
    			$$invalidate(4, gameProps);
    		});
    	}

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			gameProps.arrow.element = $$value;
    			$$invalidate(4, gameProps);
    		});
    	}

    	const click_handler = () => $$invalidate(3, checkbox.checked = false, checkbox);
    	const touchstart_handler = () => $$invalidate(3, checkbox.checked = false, checkbox);
    	const click_handler_1 = item => triggerSmoothScroll(item.id);

    	function header_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			header = $$value;
    			$$invalidate(2, header);
    		});
    	}

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			gameProps.backgroundElement = $$value;
    			$$invalidate(4, gameProps);
    		});
    	}

    	function div4_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			gameProps.obstacles.parent = $$value;
    			$$invalidate(4, gameProps);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		pop,
    		BezierEasing: src,
    		SAT,
    		Picture,
    		contents,
    		globalSettings,
    		easeInOutCubic,
    		header,
    		checkbox,
    		scroll_duration,
    		abort_scroll,
    		smoothScroll,
    		triggerSmoothScroll,
    		gameProps,
    		customEasing,
    		handleKeyDown,
    		gameInit,
    		map_range,
    		gameUpdate
    	});

    	$$self.$inject_state = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('header' in $$props) $$invalidate(2, header = $$props.header);
    		if ('checkbox' in $$props) $$invalidate(3, checkbox = $$props.checkbox);
    		if ('abort_scroll' in $$props) abort_scroll = $$props.abort_scroll;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		contents,
    		globalSettings,
    		header,
    		checkbox,
    		gameProps,
    		triggerSmoothScroll,
    		handleKeyDown,
    		keyup_handler,
    		func,
    		input_binding,
    		path1_binding,
    		div0_binding,
    		click_handler,
    		touchstart_handler,
    		click_handler_1,
    		header_1_binding,
    		div3_binding,
    		div4_binding
    	];
    }

    class Nav_header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { contents: 0, globalSettings: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nav_header",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*contents*/ ctx[0] === undefined && !('contents' in props)) {
    			console.warn("<Nav_header> was created without expected prop 'contents'");
    		}

    		if (/*globalSettings*/ ctx[1] === undefined && !('globalSettings' in props)) {
    			console.warn("<Nav_header> was created without expected prop 'globalSettings'");
    		}
    	}

    	get contents() {
    		throw new Error("<Nav_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Nav_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get globalSettings() {
    		throw new Error("<Nav_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set globalSettings(value) {
    		throw new Error("<Nav_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/button.svelte generated by Svelte v3.43.0 */
    const file$i = "src/components/button.svelte";

    // (63:0) {:else}
    function create_else_block_1$1(ctx) {
    	let button;
    	let button_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			button = element("button");
    			if (default_slot) default_slot.c();
    			attr_dev(button, "class", button_class_value = "" + ((/*disabled*/ ctx[2] ? 'disabled' : '') + " " + /*Class*/ ctx[4] + " svelte-1vgogqf"));
    			attr_dev(button, "style", /*style*/ ctx[1]);
    			button.disabled = /*disabled*/ ctx[2];
    			add_location(button, file$i, 63, 2, 1695);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (default_slot) {
    				default_slot.m(button, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(
    					button,
    					"click",
    					function () {
    						if (is_function(!/*disabled*/ ctx[2]
    						? /*target*/ ctx[0]
    						: 'javascript:void(0);')) (!/*disabled*/ ctx[2]
    						? /*target*/ ctx[0]
    						: 'javascript:void(0);').apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*disabled, Class*/ 20 && button_class_value !== (button_class_value = "" + ((/*disabled*/ ctx[2] ? 'disabled' : '') + " " + /*Class*/ ctx[4] + " svelte-1vgogqf"))) {
    				attr_dev(button, "class", button_class_value);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(button, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(63:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (57:0) {#if isAnchor}
    function create_if_block$c(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$4, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*spaMode*/ ctx[3] && !/*disabled*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(57:0) {#if isAnchor}",
    		ctx
    	});

    	return block;
    }

    // (60:2) {:else}
    function create_else_block$6(ctx) {
    	let a;
    	let a_href_value;
    	let a_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();

    			attr_dev(a, "href", a_href_value = !/*disabled*/ ctx[2]
    			? /*target*/ ctx[0]
    			: 'javascript:void(0);');

    			attr_dev(a, "class", a_class_value = "" + (/*Class*/ ctx[4] + " " + (/*disabled*/ ctx[2] ? 'disabled' : '') + " svelte-1vgogqf"));
    			attr_dev(a, "style", /*style*/ ctx[1]);
    			attr_dev(a, "disabled", /*disabled*/ ctx[2]);
    			add_location(a, file$i, 60, 4, 1532);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*disabled, target*/ 5 && a_href_value !== (a_href_value = !/*disabled*/ ctx[2]
    			? /*target*/ ctx[0]
    			: 'javascript:void(0);')) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (!current || dirty & /*Class, disabled*/ 20 && a_class_value !== (a_class_value = "" + (/*Class*/ ctx[4] + " " + (/*disabled*/ ctx[2] ? 'disabled' : '') + " svelte-1vgogqf"))) {
    				attr_dev(a, "class", a_class_value);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(a, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				attr_dev(a, "disabled", /*disabled*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(60:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:2) {#if spaMode && !disabled}
    function create_if_block_1$4(ctx) {
    	let a;
    	let a_href_value;
    	let a_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();

    			attr_dev(a, "href", a_href_value = !/*disabled*/ ctx[2]
    			? /*target*/ ctx[0]
    			: 'javascript:void(0);');

    			attr_dev(a, "class", a_class_value = "" + (/*Class*/ ctx[4] + " " + (/*disabled*/ ctx[2] ? 'disabled' : '') + " svelte-1vgogqf"));
    			attr_dev(a, "style", /*style*/ ctx[1]);
    			attr_dev(a, "disabled", /*disabled*/ ctx[2]);
    			add_location(a, file$i, 58, 4, 1364);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(link$1.call(null, a));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 1024)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[10],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[10])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[10], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*disabled, target*/ 5 && a_href_value !== (a_href_value = !/*disabled*/ ctx[2]
    			? /*target*/ ctx[0]
    			: 'javascript:void(0);')) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (!current || dirty & /*Class, disabled*/ 20 && a_class_value !== (a_class_value = "" + (/*Class*/ ctx[4] + " " + (/*disabled*/ ctx[2] ? 'disabled' : '') + " svelte-1vgogqf"))) {
    				attr_dev(a, "class", a_class_value);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(a, "style", /*style*/ ctx[1]);
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				attr_dev(a, "disabled", /*disabled*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(58:2) {#if spaMode && !disabled}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$c, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*isAnchor*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty$1();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Button', slots, ['default']);
    	let { target, disabled = false, spaMode, marginLeft, marginRight, width = "45%", bg, style = "", Class } = $$props;
    	let isAnchor = RegExp("\/").test(target);

    	if (!isAnchor) {
    		let event = new CustomEvent(target);

    		target = function () {
    			document.dispatchEvent(event);
    		};
    	}

    	if (!marginLeft && !marginRight) {
    		style = style + "margin-left: 0;margin-right: 0;";
    	} else if (!marginRight) {
    		style = style + "margin-right: 0;";
    	} else if (!marginLeft) {
    		style = style + "margin-left: 0;";
    	}

    	if (disabled) {
    		style = style + "--themeColor: #aaa;";
    	} else if (bg) {
    		style = style + `--themeColor: ${bg};`;
    	}

    	style = style + `width:${width};`;

    	const writable_props = [
    		'target',
    		'disabled',
    		'spaMode',
    		'marginLeft',
    		'marginRight',
    		'width',
    		'bg',
    		'style',
    		'Class'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Button> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('target' in $$props) $$invalidate(0, target = $$props.target);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ('spaMode' in $$props) $$invalidate(3, spaMode = $$props.spaMode);
    		if ('marginLeft' in $$props) $$invalidate(6, marginLeft = $$props.marginLeft);
    		if ('marginRight' in $$props) $$invalidate(7, marginRight = $$props.marginRight);
    		if ('width' in $$props) $$invalidate(8, width = $$props.width);
    		if ('bg' in $$props) $$invalidate(9, bg = $$props.bg);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('Class' in $$props) $$invalidate(4, Class = $$props.Class);
    		if ('$$scope' in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		link: link$1,
    		target,
    		disabled,
    		spaMode,
    		marginLeft,
    		marginRight,
    		width,
    		bg,
    		style,
    		Class,
    		isAnchor
    	});

    	$$self.$inject_state = $$props => {
    		if ('target' in $$props) $$invalidate(0, target = $$props.target);
    		if ('disabled' in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ('spaMode' in $$props) $$invalidate(3, spaMode = $$props.spaMode);
    		if ('marginLeft' in $$props) $$invalidate(6, marginLeft = $$props.marginLeft);
    		if ('marginRight' in $$props) $$invalidate(7, marginRight = $$props.marginRight);
    		if ('width' in $$props) $$invalidate(8, width = $$props.width);
    		if ('bg' in $$props) $$invalidate(9, bg = $$props.bg);
    		if ('style' in $$props) $$invalidate(1, style = $$props.style);
    		if ('Class' in $$props) $$invalidate(4, Class = $$props.Class);
    		if ('isAnchor' in $$props) $$invalidate(5, isAnchor = $$props.isAnchor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		target,
    		style,
    		disabled,
    		spaMode,
    		Class,
    		isAnchor,
    		marginLeft,
    		marginRight,
    		width,
    		bg,
    		$$scope,
    		slots
    	];
    }

    class Button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {
    			target: 0,
    			disabled: 2,
    			spaMode: 3,
    			marginLeft: 6,
    			marginRight: 7,
    			width: 8,
    			bg: 9,
    			style: 1,
    			Class: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Button",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*target*/ ctx[0] === undefined && !('target' in props)) {
    			console.warn("<Button> was created without expected prop 'target'");
    		}

    		if (/*spaMode*/ ctx[3] === undefined && !('spaMode' in props)) {
    			console.warn("<Button> was created without expected prop 'spaMode'");
    		}

    		if (/*marginLeft*/ ctx[6] === undefined && !('marginLeft' in props)) {
    			console.warn("<Button> was created without expected prop 'marginLeft'");
    		}

    		if (/*marginRight*/ ctx[7] === undefined && !('marginRight' in props)) {
    			console.warn("<Button> was created without expected prop 'marginRight'");
    		}

    		if (/*bg*/ ctx[9] === undefined && !('bg' in props)) {
    			console.warn("<Button> was created without expected prop 'bg'");
    		}

    		if (/*Class*/ ctx[4] === undefined && !('Class' in props)) {
    			console.warn("<Button> was created without expected prop 'Class'");
    		}
    	}

    	get target() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set target(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spaMode() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spaMode(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get marginLeft() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set marginLeft(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get marginRight() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set marginRight(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bg() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bg(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get style() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set style(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Class() {
    		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Class(value) {
    		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/static-content.svelte generated by Svelte v3.43.0 */
    const file$h = "src/components/static-content.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (18:6) {#each article as article}
    function create_each_block_2$2(ctx) {
    	let p;
    	let t_value = /*article*/ ctx[3] + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text$1(t_value);
    			attr_dev(p, "class", "svelte-dzzzm6");
    			add_location(p, file$h, 18, 8, 656);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*article*/ 8 && t_value !== (t_value = /*article*/ ctx[3] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(18:6) {#each article as article}",
    		ctx
    	});

    	return block;
    }

    // (29:10) {:else}
    function create_else_block$5(ctx) {
    	let t_value = /*button*/ ctx[5].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*buttons*/ 4 && t_value !== (t_value = /*button*/ ctx[5].title + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(29:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (25:10) {#if Array.isArray(button.title)}
    function create_if_block$b(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*button*/ ctx[5].title;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*buttons*/ 4) {
    				each_value_1 = /*button*/ ctx[5].title;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(25:10) {#if Array.isArray(button.title)}",
    		ctx
    	});

    	return block;
    }

    // (26:12) {#each button.title as title}
    function create_each_block_1$4(ctx) {
    	let span;
    	let t_value = /*title*/ ctx[8] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "break-scope");
    			add_location(span, file$h, 26, 14, 906);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*buttons*/ 4 && t_value !== (t_value = /*title*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(26:12) {#each button.title as title}",
    		ctx
    	});

    	return block;
    }

    // (24:8) <Button target="{button.target}">
    function create_default_slot$6(ctx) {
    	let show_if;
    	let t;

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*buttons*/ 4) show_if = !!Array.isArray(/*button*/ ctx[5].title);
    		if (show_if) return create_if_block$b;
    		return create_else_block$5;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(24:8) <Button target=\\\"{button.target}\\\">",
    		ctx
    	});

    	return block;
    }

    // (23:6) {#each buttons as button}
    function create_each_block$7(ctx) {
    	let button;
    	let current;

    	button = new Button({
    			props: {
    				target: /*button*/ ctx[5].target,
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};
    			if (dirty & /*buttons*/ 4) button_changes.target = /*button*/ ctx[5].target;

    			if (dirty & /*$$scope, buttons*/ 8196) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(23:6) {#each buttons as button}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let div1;
    	let picture;
    	let t0;
    	let div0;
    	let t1;
    	let section2;
    	let section0;
    	let t2;
    	let section1;
    	let current;

    	picture = new Picture({
    			props: {
    				pictureClass: "static-picture",
    				imgClass: "static-img",
    				contents: /*contents*/ ctx[0],
    				globalSettings: /*globalSettings*/ ctx[1],
    				imageId: /*contents*/ ctx[0].imageId,
    				width: /*contents*/ ctx[0].aspectRatio.width,
    				height: /*contents*/ ctx[0].aspectRatio.height,
    				style: "width:100%"
    			},
    			$$inline: true
    		});

    	let each_value_2 = /*article*/ ctx[3];
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	let each_value = /*buttons*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(picture.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			t1 = space();
    			section2 = element("section");
    			section0 = element("section");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			section1 = element("section");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "spacer svelte-dzzzm6");
    			add_location(div0, file$h, 14, 2, 528);
    			attr_dev(section0, "class", "text svelte-dzzzm6");
    			add_location(section0, file$h, 16, 4, 592);
    			attr_dev(section1, "class", "buttons svelte-dzzzm6");
    			add_location(section1, file$h, 21, 4, 706);
    			attr_dev(section2, "class", "right-column svelte-dzzzm6");
    			add_location(section2, file$h, 15, 2, 557);
    			attr_dev(div1, "class", "container svelte-dzzzm6");
    			add_location(div1, file$h, 12, 0, 291);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(picture, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			append_dev(div1, section2);
    			append_dev(section2, section0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(section0, null);
    			}

    			append_dev(section2, t2);
    			append_dev(section2, section1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(section1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const picture_changes = {};
    			if (dirty & /*contents*/ 1) picture_changes.contents = /*contents*/ ctx[0];
    			if (dirty & /*globalSettings*/ 2) picture_changes.globalSettings = /*globalSettings*/ ctx[1];
    			if (dirty & /*contents*/ 1) picture_changes.imageId = /*contents*/ ctx[0].imageId;
    			if (dirty & /*contents*/ 1) picture_changes.width = /*contents*/ ctx[0].aspectRatio.width;
    			if (dirty & /*contents*/ 1) picture_changes.height = /*contents*/ ctx[0].aspectRatio.height;
    			picture.$set(picture_changes);

    			if (dirty & /*article*/ 8) {
    				each_value_2 = /*article*/ ctx[3];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(section0, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty & /*buttons, Array*/ 4) {
    				each_value = /*buttons*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(section1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(picture.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(picture.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(picture);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Static_content', slots, []);
    	let { contents, globalSettings, standardWidth, article = contents.article, buttons = contents.bottomButtons } = $$props;
    	const writable_props = ['contents', 'globalSettings', 'standardWidth', 'article', 'buttons'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Static_content> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('standardWidth' in $$props) $$invalidate(4, standardWidth = $$props.standardWidth);
    		if ('article' in $$props) $$invalidate(3, article = $$props.article);
    		if ('buttons' in $$props) $$invalidate(2, buttons = $$props.buttons);
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		Picture,
    		contents,
    		globalSettings,
    		standardWidth,
    		article,
    		buttons
    	});

    	$$self.$inject_state = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('standardWidth' in $$props) $$invalidate(4, standardWidth = $$props.standardWidth);
    		if ('article' in $$props) $$invalidate(3, article = $$props.article);
    		if ('buttons' in $$props) $$invalidate(2, buttons = $$props.buttons);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [contents, globalSettings, buttons, article, standardWidth];
    }

    class Static_content extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {
    			contents: 0,
    			globalSettings: 1,
    			standardWidth: 4,
    			article: 3,
    			buttons: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Static_content",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*contents*/ ctx[0] === undefined && !('contents' in props)) {
    			console.warn("<Static_content> was created without expected prop 'contents'");
    		}

    		if (/*globalSettings*/ ctx[1] === undefined && !('globalSettings' in props)) {
    			console.warn("<Static_content> was created without expected prop 'globalSettings'");
    		}

    		if (/*standardWidth*/ ctx[4] === undefined && !('standardWidth' in props)) {
    			console.warn("<Static_content> was created without expected prop 'standardWidth'");
    		}
    	}

    	get contents() {
    		throw new Error("<Static_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Static_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get globalSettings() {
    		throw new Error("<Static_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set globalSettings(value) {
    		throw new Error("<Static_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get standardWidth() {
    		throw new Error("<Static_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set standardWidth(value) {
    		throw new Error("<Static_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get article() {
    		throw new Error("<Static_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set article(value) {
    		throw new Error("<Static_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get buttons() {
    		throw new Error("<Static_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set buttons(value) {
    		throw new Error("<Static_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/date-list.svelte generated by Svelte v3.43.0 */

    const file$g = "src/components/date-list.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (18:10) {:else}
    function create_else_block$4(ctx) {
    	let span;
    	let t_value = /*article*/ ctx[1].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			add_location(span, file$g, 18, 12, 903);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && t_value !== (t_value = /*article*/ ctx[1].title + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(18:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (14:10) {#if Array.isArray(article.title)}
    function create_if_block$a(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*article*/ ctx[1].title;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1) {
    				each_value_1 = /*article*/ ctx[1].title;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(14:10) {#if Array.isArray(article.title)}",
    		ctx
    	});

    	return block;
    }

    // (15:12) {#each article.title as title}
    function create_each_block_1$3(ctx) {
    	let span;
    	let t_value = /*title*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "break-scope");
    			add_location(span, file$g, 15, 14, 812);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && t_value !== (t_value = /*title*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(15:12) {#each article.title as title}",
    		ctx
    	});

    	return block;
    }

    // (6:2) {#each contents.articles as article}
    function create_each_block$6(ctx) {
    	let li;
    	let a;
    	let time;

    	let t0_value = (/*article*/ ctx[1].date.year
    	? ("0000" + /*article*/ ctx[1].date.year).slice(-4)
    	: "") + (/*article*/ ctx[1].date.month
    	? "/" + ("00" + /*article*/ ctx[1].date.month).slice(-2)
    	: "") + (/*article*/ ctx[1].date.day
    	? "/" + ("00" + /*article*/ ctx[1].date.day).slice(-2)
    	: "") + "";

    	let t0;
    	let time_datetime_value;
    	let t1;
    	let div;
    	let show_if;
    	let a_href_value;
    	let t2;

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*contents*/ 1) show_if = !!Array.isArray(/*article*/ ctx[1].title);
    		if (show_if) return create_if_block$a;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			time = element("time");
    			t0 = text$1(t0_value);
    			t1 = space();
    			div = element("div");
    			if_block.c();
    			t2 = space();
    			attr_dev(time, "class", "date svelte-1sas8yn");

    			attr_dev(time, "datetime", time_datetime_value = (/*article*/ ctx[1].date.year
    			? ("0000" + /*article*/ ctx[1].date.year).slice(-4)
    			: "") + (/*article*/ ctx[1].date.month
    			? "-" + ("00" + /*article*/ ctx[1].date.month).slice(-2)
    			: "") + (/*article*/ ctx[1].date.day
    			? "-" + ("00" + /*article*/ ctx[1].date.day).slice(-2)
    			: ""));

    			add_location(time, file$g, 9, 8, 203);
    			attr_dev(div, "class", "title-container svelte-1sas8yn");
    			add_location(div, file$g, 12, 8, 680);
    			attr_dev(a, "href", a_href_value = /*article*/ ctx[1].url);
    			attr_dev(a, "class", "svelte-1sas8yn");
    			add_location(a, file$g, 7, 6, 116);
    			attr_dev(li, "class", "entry svelte-1sas8yn");
    			add_location(li, file$g, 6, 4, 91);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, time);
    			append_dev(time, t0);
    			append_dev(a, t1);
    			append_dev(a, div);
    			if_block.m(div, null);
    			append_dev(li, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && t0_value !== (t0_value = (/*article*/ ctx[1].date.year
    			? ("0000" + /*article*/ ctx[1].date.year).slice(-4)
    			: "") + (/*article*/ ctx[1].date.month
    			? "/" + ("00" + /*article*/ ctx[1].date.month).slice(-2)
    			: "") + (/*article*/ ctx[1].date.day
    			? "/" + ("00" + /*article*/ ctx[1].date.day).slice(-2)
    			: "") + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*contents*/ 1 && time_datetime_value !== (time_datetime_value = (/*article*/ ctx[1].date.year
    			? ("0000" + /*article*/ ctx[1].date.year).slice(-4)
    			: "") + (/*article*/ ctx[1].date.month
    			? "-" + ("00" + /*article*/ ctx[1].date.month).slice(-2)
    			: "") + (/*article*/ ctx[1].date.day
    			? "-" + ("00" + /*article*/ ctx[1].date.day).slice(-2)
    			: ""))) {
    				attr_dev(time, "datetime", time_datetime_value);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}

    			if (dirty & /*contents*/ 1 && a_href_value !== (a_href_value = /*article*/ ctx[1].url)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(6:2) {#each contents.articles as article}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let ul;
    	let each_value = /*contents*/ ctx[0].articles;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-1sas8yn");
    			add_location(ul, file$g, 4, 0, 43);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*contents, Array*/ 1) {
    				each_value = /*contents*/ ctx[0].articles;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Date_list', slots, []);
    	let { contents } = $$props;
    	const writable_props = ['contents'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Date_list> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    	};

    	$$self.$capture_state = () => ({ contents });

    	$$self.$inject_state = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [contents];
    }

    class Date_list extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { contents: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Date_list",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*contents*/ ctx[0] === undefined && !('contents' in props)) {
    			console.warn("<Date_list> was created without expected prop 'contents'");
    		}
    	}

    	get contents() {
    		throw new Error("<Date_list>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Date_list>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * SSR Window 3.0.0
     * Better handling for window object in SSR environment
     * https://github.com/nolimits4web/ssr-window
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */
    /* eslint-disable no-param-reassign */
    function isObject$4(obj) {
        return (obj !== null &&
            typeof obj === 'object' &&
            'constructor' in obj &&
            obj.constructor === Object);
    }
    function extend$2(target, src) {
        if (target === void 0) { target = {}; }
        if (src === void 0) { src = {}; }
        Object.keys(src).forEach(function (key) {
            if (typeof target[key] === 'undefined')
                target[key] = src[key];
            else if (isObject$4(src[key]) &&
                isObject$4(target[key]) &&
                Object.keys(src[key]).length > 0) {
                extend$2(target[key], src[key]);
            }
        });
    }

    var ssrDocument = {
        body: {},
        addEventListener: function () { },
        removeEventListener: function () { },
        activeElement: {
            blur: function () { },
            nodeName: '',
        },
        querySelector: function () {
            return null;
        },
        querySelectorAll: function () {
            return [];
        },
        getElementById: function () {
            return null;
        },
        createEvent: function () {
            return {
                initEvent: function () { },
            };
        },
        createElement: function () {
            return {
                children: [],
                childNodes: [],
                style: {},
                setAttribute: function () { },
                getElementsByTagName: function () {
                    return [];
                },
            };
        },
        createElementNS: function () {
            return {};
        },
        importNode: function () {
            return null;
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
    };
    function getDocument() {
        var doc = typeof document !== 'undefined' ? document : {};
        extend$2(doc, ssrDocument);
        return doc;
    }

    var ssrWindow = {
        document: ssrDocument,
        navigator: {
            userAgent: '',
        },
        location: {
            hash: '',
            host: '',
            hostname: '',
            href: '',
            origin: '',
            pathname: '',
            protocol: '',
            search: '',
        },
        history: {
            replaceState: function () { },
            pushState: function () { },
            go: function () { },
            back: function () { },
        },
        CustomEvent: function CustomEvent() {
            return this;
        },
        addEventListener: function () { },
        removeEventListener: function () { },
        getComputedStyle: function () {
            return {
                getPropertyValue: function () {
                    return '';
                },
            };
        },
        Image: function () { },
        Date: function () { },
        screen: {},
        setTimeout: function () { },
        clearTimeout: function () { },
        matchMedia: function () {
            return {};
        },
        requestAnimationFrame: function (callback) {
            if (typeof setTimeout === 'undefined') {
                callback();
                return null;
            }
            return setTimeout(callback, 0);
        },
        cancelAnimationFrame: function (id) {
            if (typeof setTimeout === 'undefined') {
                return;
            }
            clearTimeout(id);
        },
    };
    function getWindow() {
        var win = typeof window !== 'undefined' ? window : {};
        extend$2(win, ssrWindow);
        return win;
    }

    /**
     * Dom7 3.0.0
     * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
     * https://framework7.io/docs/dom7.html
     *
     * Copyright 2020, Vladimir Kharlampidi
     *
     * Licensed under MIT
     *
     * Released on: November 9, 2020
     */

    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }

    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
      };
      return _getPrototypeOf(o);
    }

    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
      };

      return _setPrototypeOf(o, p);
    }

    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct) return false;
      if (Reflect.construct.sham) return false;
      if (typeof Proxy === "function") return true;

      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
        return true;
      } catch (e) {
        return false;
      }
    }

    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct(Parent, args, Class) {
          var a = [null];
          a.push.apply(a, args);
          var Constructor = Function.bind.apply(Parent, a);
          var instance = new Constructor();
          if (Class) _setPrototypeOf(instance, Class.prototype);
          return instance;
        };
      }

      return _construct.apply(null, arguments);
    }

    function _isNativeFunction(fn) {
      return Function.toString.call(fn).indexOf("[native code]") !== -1;
    }

    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? new Map() : undefined;

      _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !_isNativeFunction(Class)) return Class;

        if (typeof Class !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }

        if (typeof _cache !== "undefined") {
          if (_cache.has(Class)) return _cache.get(Class);

          _cache.set(Class, Wrapper);
        }

        function Wrapper() {
          return _construct(Class, arguments, _getPrototypeOf(this).constructor);
        }

        Wrapper.prototype = Object.create(Class.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
        return _setPrototypeOf(Wrapper, Class);
      };

      return _wrapNativeSuper(Class);
    }

    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }

      return self;
    }

    /* eslint-disable no-proto */
    function makeReactive(obj) {
      var proto = obj.__proto__;
      Object.defineProperty(obj, '__proto__', {
        get: function get() {
          return proto;
        },
        set: function set(value) {
          proto.__proto__ = value;
        }
      });
    }

    var Dom7 = /*#__PURE__*/function (_Array) {
      _inheritsLoose(Dom7, _Array);

      function Dom7(items) {
        var _this;

        _this = _Array.call.apply(_Array, [this].concat(items)) || this;
        makeReactive(_assertThisInitialized(_this));
        return _this;
      }

      return Dom7;
    }( /*#__PURE__*/_wrapNativeSuper(Array));

    function arrayFlat(arr) {
      if (arr === void 0) {
        arr = [];
      }

      var res = [];
      arr.forEach(function (el) {
        if (Array.isArray(el)) {
          res.push.apply(res, arrayFlat(el));
        } else {
          res.push(el);
        }
      });
      return res;
    }
    function arrayFilter(arr, callback) {
      return Array.prototype.filter.call(arr, callback);
    }
    function arrayUnique(arr) {
      var uniqueArray = [];

      for (var i = 0; i < arr.length; i += 1) {
        if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
      }

      return uniqueArray;
    }

    function qsa(selector, context) {
      if (typeof selector !== 'string') {
        return [selector];
      }

      var a = [];
      var res = context.querySelectorAll(selector);

      for (var i = 0; i < res.length; i += 1) {
        a.push(res[i]);
      }

      return a;
    }

    function $(selector, context) {
      var window = getWindow();
      var document = getDocument();
      var arr = [];

      if (!context && selector instanceof Dom7) {
        return selector;
      }

      if (!selector) {
        return new Dom7(arr);
      }

      if (typeof selector === 'string') {
        var html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          var tempParent = document.createElement(toCreate);
          tempParent.innerHTML = html;

          for (var i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          arr = qsa(selector.trim(), context || document);
        } // arr = qsa(selector, document);

      } else if (selector.nodeType || selector === window || selector === document) {
        arr.push(selector);
      } else if (Array.isArray(selector)) {
        if (selector instanceof Dom7) return selector;
        arr = selector;
      }

      return new Dom7(arrayUnique(arr));
    }

    $.fn = Dom7.prototype;

    function addClass$1() {
      for (var _len = arguments.length, classes = new Array(_len), _key = 0; _key < _len; _key++) {
        classes[_key] = arguments[_key];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList;

        (_el$classList = el.classList).add.apply(_el$classList, classNames);
      });
      return this;
    }

    function removeClass$1() {
      for (var _len2 = arguments.length, classes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        classes[_key2] = arguments[_key2];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        var _el$classList2;

        (_el$classList2 = el.classList).remove.apply(_el$classList2, classNames);
      });
      return this;
    }

    function toggleClass$1() {
      for (var _len3 = arguments.length, classes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        classes[_key3] = arguments[_key3];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      this.forEach(function (el) {
        classNames.forEach(function (className) {
          el.classList.toggle(className);
        });
      });
    }

    function hasClass$1() {
      for (var _len4 = arguments.length, classes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        classes[_key4] = arguments[_key4];
      }

      var classNames = arrayFlat(classes.map(function (c) {
        return c.split(' ');
      }));
      return arrayFilter(this, function (el) {
        return classNames.filter(function (className) {
          return el.classList.contains(className);
        }).length > 0;
      }).length > 0;
    }

    function attr(attrs, value) {
      if (arguments.length === 1 && typeof attrs === 'string') {
        // Get attr
        if (this[0]) return this[0].getAttribute(attrs);
        return undefined;
      } // Set attrs


      for (var i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i].setAttribute(attrs, value);
        } else {
          // Object
          for (var attrName in attrs) {
            this[i][attrName] = attrs[attrName];
            this[i].setAttribute(attrName, attrs[attrName]);
          }
        }
      }

      return this;
    }

    function removeAttr(attr) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].removeAttribute(attr);
      }

      return this;
    }

    function transform$1(transform) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transform = transform;
      }

      return this;
    }

    function transition$1(duration) {
      for (var i = 0; i < this.length; i += 1) {
        this[i].style.transitionDuration = typeof duration !== 'string' ? duration + "ms" : duration;
      }

      return this;
    }

    function on() {
      for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;

      function handleLiveEvent(e) {
        var target = e.target;
        if (!target) return;
        var eventData = e.target.dom7EventData || [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        if ($(target).is(targetSelector)) listener.apply(target, eventData);else {
          var _parents = $(target).parents(); // eslint-disable-line


          for (var k = 0; k < _parents.length; k += 1) {
            if ($(_parents[k]).is(targetSelector)) listener.apply(_parents[k], eventData);
          }
        }
      }

      function handleEvent(e) {
        var eventData = e && e.target ? e.target.dom7EventData || [] : [];

        if (eventData.indexOf(e) < 0) {
          eventData.unshift(e);
        }

        listener.apply(this, eventData);
      }

      var events = eventType.split(' ');
      var j;

      for (var i = 0; i < this.length; i += 1) {
        var el = this[i];

        if (!targetSelector) {
          for (j = 0; j < events.length; j += 1) {
            var event = events[j];
            if (!el.dom7Listeners) el.dom7Listeners = {};
            if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
            el.dom7Listeners[event].push({
              listener: listener,
              proxyListener: handleEvent
            });
            el.addEventListener(event, handleEvent, capture);
          }
        } else {
          // Live events
          for (j = 0; j < events.length; j += 1) {
            var _event = events[j];
            if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
            if (!el.dom7LiveListeners[_event]) el.dom7LiveListeners[_event] = [];

            el.dom7LiveListeners[_event].push({
              listener: listener,
              proxyListener: handleLiveEvent
            });

            el.addEventListener(_event, handleLiveEvent, capture);
          }
        }
      }

      return this;
    }

    function off() {
      for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      var eventType = args[0],
          targetSelector = args[1],
          listener = args[2],
          capture = args[3];

      if (typeof args[1] === 'function') {
        eventType = args[0];
        listener = args[1];
        capture = args[2];
        targetSelector = undefined;
      }

      if (!capture) capture = false;
      var events = eventType.split(' ');

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];
          var handlers = void 0;

          if (!targetSelector && el.dom7Listeners) {
            handlers = el.dom7Listeners[event];
          } else if (targetSelector && el.dom7LiveListeners) {
            handlers = el.dom7LiveListeners[event];
          }

          if (handlers && handlers.length) {
            for (var k = handlers.length - 1; k >= 0; k -= 1) {
              var handler = handlers[k];

              if (listener && handler.listener === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              } else if (!listener) {
                el.removeEventListener(event, handler.proxyListener, capture);
                handlers.splice(k, 1);
              }
            }
          }
        }
      }

      return this;
    }

    function trigger() {
      var window = getWindow();

      for (var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {
        args[_key9] = arguments[_key9];
      }

      var events = args[0].split(' ');
      var eventData = args[1];

      for (var i = 0; i < events.length; i += 1) {
        var event = events[i];

        for (var j = 0; j < this.length; j += 1) {
          var el = this[j];

          if (window.CustomEvent) {
            var evt = new window.CustomEvent(event, {
              detail: eventData,
              bubbles: true,
              cancelable: true
            });
            el.dom7EventData = args.filter(function (data, dataIndex) {
              return dataIndex > 0;
            });
            el.dispatchEvent(evt);
            el.dom7EventData = [];
            delete el.dom7EventData;
          }
        }
      }

      return this;
    }

    function transitionEnd$1(callback) {
      var dom = this;

      function fireCallBack(e) {
        if (e.target !== this) return;
        callback.call(this, e);
        dom.off('transitionend', fireCallBack);
      }

      if (callback) {
        dom.on('transitionend', fireCallBack);
      }

      return this;
    }

    function outerWidth(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles = this.styles();

          return this[0].offsetWidth + parseFloat(_styles.getPropertyValue('margin-right')) + parseFloat(_styles.getPropertyValue('margin-left'));
        }

        return this[0].offsetWidth;
      }

      return null;
    }

    function outerHeight(includeMargins) {
      if (this.length > 0) {
        if (includeMargins) {
          var _styles2 = this.styles();

          return this[0].offsetHeight + parseFloat(_styles2.getPropertyValue('margin-top')) + parseFloat(_styles2.getPropertyValue('margin-bottom'));
        }

        return this[0].offsetHeight;
      }

      return null;
    }

    function offset() {
      if (this.length > 0) {
        var window = getWindow();
        var document = getDocument();
        var el = this[0];
        var box = el.getBoundingClientRect();
        var body = document.body;
        var clientTop = el.clientTop || body.clientTop || 0;
        var clientLeft = el.clientLeft || body.clientLeft || 0;
        var scrollTop = el === window ? window.scrollY : el.scrollTop;
        var scrollLeft = el === window ? window.scrollX : el.scrollLeft;
        return {
          top: box.top + scrollTop - clientTop,
          left: box.left + scrollLeft - clientLeft
        };
      }

      return null;
    }

    function styles() {
      var window = getWindow();
      if (this[0]) return window.getComputedStyle(this[0], null);
      return {};
    }

    function css(props, value) {
      var window = getWindow();
      var i;

      if (arguments.length === 1) {
        if (typeof props === 'string') {
          // .css('width')
          if (this[0]) return window.getComputedStyle(this[0], null).getPropertyValue(props);
        } else {
          // .css({ width: '100px' })
          for (i = 0; i < this.length; i += 1) {
            for (var _prop in props) {
              this[i].style[_prop] = props[_prop];
            }
          }

          return this;
        }
      }

      if (arguments.length === 2 && typeof props === 'string') {
        // .css('width', '100px')
        for (i = 0; i < this.length; i += 1) {
          this[i].style[props] = value;
        }

        return this;
      }

      return this;
    }

    function each(callback) {
      if (!callback) return this;
      this.forEach(function (el, index) {
        callback.apply(el, [el, index]);
      });
      return this;
    }

    function filter(callback) {
      var result = arrayFilter(this, callback);
      return $(result);
    }

    function html(html) {
      if (typeof html === 'undefined') {
        return this[0] ? this[0].innerHTML : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].innerHTML = html;
      }

      return this;
    }

    function text(text) {
      if (typeof text === 'undefined') {
        return this[0] ? this[0].textContent.trim() : null;
      }

      for (var i = 0; i < this.length; i += 1) {
        this[i].textContent = text;
      }

      return this;
    }

    function is(selector) {
      var window = getWindow();
      var document = getDocument();
      var el = this[0];
      var compareWith;
      var i;
      if (!el || typeof selector === 'undefined') return false;

      if (typeof selector === 'string') {
        if (el.matches) return el.matches(selector);
        if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
        if (el.msMatchesSelector) return el.msMatchesSelector(selector);
        compareWith = $(selector);

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      if (selector === document) {
        return el === document;
      }

      if (selector === window) {
        return el === window;
      }

      if (selector.nodeType || selector instanceof Dom7) {
        compareWith = selector.nodeType ? [selector] : selector;

        for (i = 0; i < compareWith.length; i += 1) {
          if (compareWith[i] === el) return true;
        }

        return false;
      }

      return false;
    }

    function index() {
      var child = this[0];
      var i;

      if (child) {
        i = 0; // eslint-disable-next-line

        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1) i += 1;
        }

        return i;
      }

      return undefined;
    }

    function eq(index) {
      if (typeof index === 'undefined') return this;
      var length = this.length;

      if (index > length - 1) {
        return $([]);
      }

      if (index < 0) {
        var returnIndex = length + index;
        if (returnIndex < 0) return $([]);
        return $([this[returnIndex]]);
      }

      return $([this[index]]);
    }

    function append$1() {
      var newChild;
      var document = getDocument();

      for (var k = 0; k < arguments.length; k += 1) {
        newChild = k < 0 || arguments.length <= k ? undefined : arguments[k];

        for (var i = 0; i < this.length; i += 1) {
          if (typeof newChild === 'string') {
            var tempDiv = document.createElement('div');
            tempDiv.innerHTML = newChild;

            while (tempDiv.firstChild) {
              this[i].appendChild(tempDiv.firstChild);
            }
          } else if (newChild instanceof Dom7) {
            for (var j = 0; j < newChild.length; j += 1) {
              this[i].appendChild(newChild[j]);
            }
          } else {
            this[i].appendChild(newChild);
          }
        }
      }

      return this;
    }

    function prepend(newChild) {
      var document = getDocument();
      var i;
      var j;

      for (i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = newChild;

          for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
            this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
          }
        } else if (newChild instanceof Dom7) {
          for (j = 0; j < newChild.length; j += 1) {
            this[i].insertBefore(newChild[j], this[i].childNodes[0]);
          }
        } else {
          this[i].insertBefore(newChild, this[i].childNodes[0]);
        }
      }

      return this;
    }

    function next(selector) {
      if (this.length > 0) {
        if (selector) {
          if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
            return $([this[0].nextElementSibling]);
          }

          return $([]);
        }

        if (this[0].nextElementSibling) return $([this[0].nextElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function nextAll(selector) {
      var nextEls = [];
      var el = this[0];
      if (!el) return $([]);

      while (el.nextElementSibling) {
        var _next = el.nextElementSibling; // eslint-disable-line

        if (selector) {
          if ($(_next).is(selector)) nextEls.push(_next);
        } else nextEls.push(_next);

        el = _next;
      }

      return $(nextEls);
    }

    function prev(selector) {
      if (this.length > 0) {
        var el = this[0];

        if (selector) {
          if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
            return $([el.previousElementSibling]);
          }

          return $([]);
        }

        if (el.previousElementSibling) return $([el.previousElementSibling]);
        return $([]);
      }

      return $([]);
    }

    function prevAll(selector) {
      var prevEls = [];
      var el = this[0];
      if (!el) return $([]);

      while (el.previousElementSibling) {
        var _prev = el.previousElementSibling; // eslint-disable-line

        if (selector) {
          if ($(_prev).is(selector)) prevEls.push(_prev);
        } else prevEls.push(_prev);

        el = _prev;
      }

      return $(prevEls);
    }

    function parent(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode !== null) {
          if (selector) {
            if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
          } else {
            parents.push(this[i].parentNode);
          }
        }
      }

      return $(parents);
    }

    function parents(selector) {
      var parents = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var _parent = this[i].parentNode; // eslint-disable-line

        while (_parent) {
          if (selector) {
            if ($(_parent).is(selector)) parents.push(_parent);
          } else {
            parents.push(_parent);
          }

          _parent = _parent.parentNode;
        }
      }

      return $(parents);
    }

    function closest$1(selector) {
      var closest = this; // eslint-disable-line

      if (typeof selector === 'undefined') {
        return $([]);
      }

      if (!closest.is(selector)) {
        closest = closest.parents(selector).eq(0);
      }

      return closest;
    }

    function find(selector) {
      var foundElements = [];

      for (var i = 0; i < this.length; i += 1) {
        var found = this[i].querySelectorAll(selector);

        for (var j = 0; j < found.length; j += 1) {
          foundElements.push(found[j]);
        }
      }

      return $(foundElements);
    }

    function children$1(selector) {
      var children = []; // eslint-disable-line

      for (var i = 0; i < this.length; i += 1) {
        var childNodes = this[i].children;

        for (var j = 0; j < childNodes.length; j += 1) {
          if (!selector || $(childNodes[j]).is(selector)) {
            children.push(childNodes[j]);
          }
        }
      }

      return $(children);
    }

    function remove$1() {
      for (var i = 0; i < this.length; i += 1) {
        if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
      }

      return this;
    }

    var Methods = {
      addClass: addClass$1,
      removeClass: removeClass$1,
      hasClass: hasClass$1,
      toggleClass: toggleClass$1,
      attr: attr,
      removeAttr: removeAttr,
      transform: transform$1,
      transition: transition$1,
      on: on,
      off: off,
      trigger: trigger,
      transitionEnd: transitionEnd$1,
      outerWidth: outerWidth,
      outerHeight: outerHeight,
      styles: styles,
      offset: offset,
      css: css,
      each: each,
      html: html,
      text: text,
      is: is,
      index: index,
      eq: eq,
      append: append$1,
      prepend: prepend,
      next: next,
      nextAll: nextAll,
      prev: prev,
      prevAll: prevAll,
      parent: parent,
      parents: parents,
      closest: closest$1,
      find: find,
      children: children$1,
      filter: filter,
      remove: remove$1
    };
    Object.keys(Methods).forEach(function (methodName) {
      Object.defineProperty($.fn, methodName, {
        value: Methods[methodName],
        writable: true
      });
    });

    function deleteProps(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    }

    function nextTick$1(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }

      return setTimeout(callback, delay);
    }

    function now() {
      return Date.now();
    }

    function getComputedStyle$1(el) {
      var window = getWindow();
      var style;

      if (window.getComputedStyle) {
        style = window.getComputedStyle(el, null);
      }

      if (!style && el.currentStyle) {
        style = el.currentStyle;
      }

      if (!style) {
        style = el.style;
      }

      return style;
    }

    function getTranslate(el, axis) {
      if (axis === void 0) {
        axis = 'x';
      }

      var window = getWindow();
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = getComputedStyle$1(el);

      if (window.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(function (a) {
            return a.replace(',', '.');
          }).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new window.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]); // Normal Browsers
          else curTransform = parseFloat(matrix[4]);
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42; // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]); // Normal Browsers
          else curTransform = parseFloat(matrix[5]);
      }

      return curTransform || 0;
    }

    function isObject$3(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function isNode(node) {
      // eslint-disable-next-line
      if (typeof window !== 'undefined' && typeof window.HTMLElement !== 'undefined') {
        return node instanceof HTMLElement;
      }

      return node && (node.nodeType === 1 || node.nodeType === 11);
    }

    function extend$1() {
      var to = Object(arguments.length <= 0 ? undefined : arguments[0]);
      var noExtend = ['__proto__', 'constructor', 'prototype'];

      for (var i = 1; i < arguments.length; i += 1) {
        var nextSource = i < 0 || arguments.length <= i ? undefined : arguments[i];

        if (nextSource !== undefined && nextSource !== null && !isNode(nextSource)) {
          var keysArray = Object.keys(Object(nextSource)).filter(function (key) {
            return noExtend.indexOf(key) < 0;
          });

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (isObject$3(to[nextKey]) && isObject$3(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject$3(to[nextKey]) && isObject$3(nextSource[nextKey])) {
                to[nextKey] = {};

                if (nextSource[nextKey].__swiper__) {
                  to[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to[nextKey], nextSource[nextKey]);
                }
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }

    function bindModuleMethods(instance, obj) {
      Object.keys(obj).forEach(function (key) {
        if (isObject$3(obj[key])) {
          Object.keys(obj[key]).forEach(function (subKey) {
            if (typeof obj[key][subKey] === 'function') {
              obj[key][subKey] = obj[key][subKey].bind(instance);
            }
          });
        }

        instance[key] = obj[key];
      });
    }

    function classesToSelector(classes) {
      if (classes === void 0) {
        classes = '';
      }

      return "." + classes.trim().replace(/([\.:!\/])/g, '\\$1') // eslint-disable-line
      .replace(/ /g, '.');
    }

    function createElementIfNotDefined($container, params, createElements, checkProps) {
      var document = getDocument();

      if (createElements) {
        Object.keys(checkProps).forEach(function (key) {
          if (!params[key] && params.auto === true) {
            var element = document.createElement('div');
            element.className = checkProps[key];
            $container.append(element);
            params[key] = element;
          }
        });
      }

      return params;
    }

    var support;

    function calcSupport() {
      var window = getWindow();
      var document = getDocument();
      return {
        touch: !!('ontouchstart' in window || window.DocumentTouch && document instanceof window.DocumentTouch),
        pointerEvents: !!window.PointerEvent && 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints >= 0,
        observer: function checkObserver() {
          return 'MutationObserver' in window || 'WebkitMutationObserver' in window;
        }(),
        passiveListener: function checkPassiveListener() {
          var supportsPassive = false;

          try {
            var opts = Object.defineProperty({}, 'passive', {
              // eslint-disable-next-line
              get: function get() {
                supportsPassive = true;
              }
            });
            window.addEventListener('testPassiveListener', null, opts);
          } catch (e) {// No support
          }

          return supportsPassive;
        }(),
        gestures: function checkGestures() {
          return 'ongesturestart' in window;
        }()
      };
    }

    function getSupport() {
      if (!support) {
        support = calcSupport();
      }

      return support;
    }

    var device;

    function calcDevice(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          userAgent = _ref.userAgent;

      var support = getSupport();
      var window = getWindow();
      var platform = window.navigator.platform;
      var ua = userAgent || window.navigator.userAgent;
      var device = {
        ios: false,
        android: false
      };
      var screenWidth = window.screen.width;
      var screenHeight = window.screen.height;
      var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

      var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
      var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
      var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      var windows = platform === 'Win32';
      var macos = platform === 'MacIntel'; // iPadOs 13 fix

      var iPadScreens = ['1024x1366', '1366x1024', '834x1194', '1194x834', '834x1112', '1112x834', '768x1024', '1024x768', '820x1180', '1180x820', '810x1080', '1080x810'];

      if (!ipad && macos && support.touch && iPadScreens.indexOf(screenWidth + "x" + screenHeight) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [0, 1, '13_0_0'];
        macos = false;
      } // Android


      if (android && !windows) {
        device.os = 'android';
        device.android = true;
      }

      if (ipad || iphone || ipod) {
        device.os = 'ios';
        device.ios = true;
      } // Export object


      return device;
    }

    function getDevice(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }

      if (!device) {
        device = calcDevice(overrides);
      }

      return device;
    }

    var browser$1;

    function calcBrowser() {
      var window = getWindow();

      function isSafari() {
        var ua = window.navigator.userAgent.toLowerCase();
        return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
      }

      return {
        isEdge: !!window.navigator.userAgent.match(/Edge/g),
        isSafari: isSafari(),
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window.navigator.userAgent)
      };
    }

    function getBrowser() {
      if (!browser$1) {
        browser$1 = calcBrowser();
      }

      return browser$1;
    }

    var supportsResizeObserver = function supportsResizeObserver() {
      var window = getWindow();
      return typeof window.ResizeObserver !== 'undefined';
    };

    var Resize = {
      name: 'resize',
      create: function create() {
        var swiper = this;
        extend$1(swiper, {
          resize: {
            observer: null,
            createObserver: function createObserver() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.resize.observer = new ResizeObserver(function (entries) {
                var width = swiper.width,
                    height = swiper.height;
                var newWidth = width;
                var newHeight = height;
                entries.forEach(function (_ref) {
                  var contentBoxSize = _ref.contentBoxSize,
                      contentRect = _ref.contentRect,
                      target = _ref.target;
                  if (target && target !== swiper.el) return;
                  newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                  newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                });

                if (newWidth !== width || newHeight !== height) {
                  swiper.resize.resizeHandler();
                }
              });
              swiper.resize.observer.observe(swiper.el);
            },
            removeObserver: function removeObserver() {
              if (swiper.resize.observer && swiper.resize.observer.unobserve && swiper.el) {
                swiper.resize.observer.unobserve(swiper.el);
                swiper.resize.observer = null;
              }
            },
            resizeHandler: function resizeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('beforeResize');
              swiper.emit('resize');
            },
            orientationChangeHandler: function orientationChangeHandler() {
              if (!swiper || swiper.destroyed || !swiper.initialized) return;
              swiper.emit('orientationchange');
            }
          }
        });
      },
      on: {
        init: function init(swiper) {
          var window = getWindow();

          if (swiper.params.resizeObserver && supportsResizeObserver()) {
            swiper.resize.createObserver();
            return;
          } // Emit resize


          window.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

          window.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        },
        destroy: function destroy(swiper) {
          var window = getWindow();
          swiper.resize.removeObserver();
          window.removeEventListener('resize', swiper.resize.resizeHandler);
          window.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
        }
      }
    };

    function _extends$3() { _extends$3 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$3.apply(this, arguments); }
    var Observer = {
      attach: function attach(target, options) {
        if (options === void 0) {
          options = {};
        }

        var window = getWindow();
        var swiper = this;
        var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver;
        var observer = new ObserverFunc(function (mutations) {
          // The observerUpdate event should only be triggered
          // once despite the number of mutations.  Additional
          // triggers are redundant and are very costly
          if (mutations.length === 1) {
            swiper.emit('observerUpdate', mutations[0]);
            return;
          }

          var observerUpdate = function observerUpdate() {
            swiper.emit('observerUpdate', mutations[0]);
          };

          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(observerUpdate);
          } else {
            window.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
          childList: typeof options.childList === 'undefined' ? true : options.childList,
          characterData: typeof options.characterData === 'undefined' ? true : options.characterData
        });
        swiper.observer.observers.push(observer);
      },
      init: function init() {
        var swiper = this;
        if (!swiper.support.observer || !swiper.params.observer) return;

        if (swiper.params.observeParents) {
          var containerParents = swiper.$el.parents();

          for (var i = 0; i < containerParents.length; i += 1) {
            swiper.observer.attach(containerParents[i]);
          }
        } // Observe container


        swiper.observer.attach(swiper.$el[0], {
          childList: swiper.params.observeSlideChildren
        }); // Observe wrapper

        swiper.observer.attach(swiper.$wrapperEl[0], {
          attributes: false
        });
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.observer.observers.forEach(function (observer) {
          observer.disconnect();
        });
        swiper.observer.observers = [];
      }
    };
    var Observer$1 = {
      name: 'observer',
      params: {
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          observer: _extends$3({}, Observer, {
            observers: []
          })
        });
      },
      on: {
        init: function init(swiper) {
          swiper.observer.init();
        },
        destroy: function destroy(swiper) {
          swiper.observer.destroy();
        }
      }
    };

    var modular = {
      useParams: function useParams(instanceParams) {
        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName]; // Extend params

          if (module.params) {
            extend$1(instanceParams, module.params);
          }
        });
      },
      useModules: function useModules(modulesParams) {
        if (modulesParams === void 0) {
          modulesParams = {};
        }

        var instance = this;
        if (!instance.modules) return;
        Object.keys(instance.modules).forEach(function (moduleName) {
          var module = instance.modules[moduleName];
          var moduleParams = modulesParams[moduleName] || {}; // Add event listeners

          if (module.on && instance.on) {
            Object.keys(module.on).forEach(function (moduleEventName) {
              instance.on(moduleEventName, module.on[moduleEventName]);
            });
          } // Module create callback


          if (module.create) {
            module.create.bind(instance)(moduleParams);
          }
        });
      }
    };

    /* eslint-disable no-underscore-dangle */
    var eventsEmitter = {
      on: function on(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';
        events.split(' ').forEach(function (event) {
          if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
          self.eventsListeners[event][method](handler);
        });
        return self;
      },
      once: function once(events, handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;

        function onceHandler() {
          self.off(events, onceHandler);

          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }

          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          handler.apply(self, args);
        }

        onceHandler.__emitterProxy = handler;
        return self.on(events, onceHandler, priority);
      },
      onAny: function onAny(handler, priority) {
        var self = this;
        if (typeof handler !== 'function') return self;
        var method = priority ? 'unshift' : 'push';

        if (self.eventsAnyListeners.indexOf(handler) < 0) {
          self.eventsAnyListeners[method](handler);
        }

        return self;
      },
      offAny: function offAny(handler) {
        var self = this;
        if (!self.eventsAnyListeners) return self;
        var index = self.eventsAnyListeners.indexOf(handler);

        if (index >= 0) {
          self.eventsAnyListeners.splice(index, 1);
        }

        return self;
      },
      off: function off(events, handler) {
        var self = this;
        if (!self.eventsListeners) return self;
        events.split(' ').forEach(function (event) {
          if (typeof handler === 'undefined') {
            self.eventsListeners[event] = [];
          } else if (self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler, index) {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self;
      },
      emit: function emit() {
        var self = this;
        if (!self.eventsListeners) return self;
        var events;
        var data;
        var context;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        if (typeof args[0] === 'string' || Array.isArray(args[0])) {
          events = args[0];
          data = args.slice(1, args.length);
          context = self;
        } else {
          events = args[0].events;
          data = args[0].data;
          context = args[0].context || self;
        }

        data.unshift(context);
        var eventsArray = Array.isArray(events) ? events : events.split(' ');
        eventsArray.forEach(function (event) {
          if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
            self.eventsAnyListeners.forEach(function (eventHandler) {
              eventHandler.apply(context, [event].concat(data));
            });
          }

          if (self.eventsListeners && self.eventsListeners[event]) {
            self.eventsListeners[event].forEach(function (eventHandler) {
              eventHandler.apply(context, data);
            });
          }
        });
        return self;
      }
    };

    function updateSize() {
      var swiper = this;
      var width;
      var height;
      var $el = swiper.$el;

      if (typeof swiper.params.width !== 'undefined' && swiper.params.width !== null) {
        width = swiper.params.width;
      } else {
        width = $el[0].clientWidth;
      }

      if (typeof swiper.params.height !== 'undefined' && swiper.params.height !== null) {
        height = swiper.params.height;
      } else {
        height = $el[0].clientHeight;
      }

      if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
      } // Subtract paddings


      width = width - parseInt($el.css('padding-left') || 0, 10) - parseInt($el.css('padding-right') || 0, 10);
      height = height - parseInt($el.css('padding-top') || 0, 10) - parseInt($el.css('padding-bottom') || 0, 10);
      if (Number.isNaN(width)) width = 0;
      if (Number.isNaN(height)) height = 0;
      extend$1(swiper, {
        width: width,
        height: height,
        size: swiper.isHorizontal() ? width : height
      });
    }

    function updateSlides() {
      var swiper = this;

      function getDirectionLabel(property) {
        if (swiper.isHorizontal()) {
          return property;
        } // prettier-ignore


        return {
          'width': 'height',
          'margin-top': 'margin-left',
          'margin-bottom ': 'margin-right',
          'margin-left': 'margin-top',
          'margin-right': 'margin-bottom',
          'padding-left': 'padding-top',
          'padding-right': 'padding-bottom',
          'marginRight': 'marginBottom'
        }[property];
      }

      function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(getDirectionLabel(label)) || 0);
      }

      var params = swiper.params;
      var $wrapperEl = swiper.$wrapperEl,
          swiperSize = swiper.size,
          rtl = swiper.rtlTranslate,
          wrongRTL = swiper.wrongRTL;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
      var slides = $wrapperEl.children("." + swiper.params.slideClass);
      var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
      var snapGrid = [];
      var slidesGrid = [];
      var slidesSizesGrid = [];
      var offsetBefore = params.slidesOffsetBefore;

      if (typeof offsetBefore === 'function') {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
      }

      var offsetAfter = params.slidesOffsetAfter;

      if (typeof offsetAfter === 'function') {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
      }

      var previousSnapGridLength = swiper.snapGrid.length;
      var previousSlidesGridLength = swiper.slidesGrid.length;
      var spaceBetween = params.spaceBetween;
      var slidePosition = -offsetBefore;
      var prevSlideSize = 0;
      var index = 0;

      if (typeof swiperSize === 'undefined') {
        return;
      }

      if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
      }

      swiper.virtualSize = -spaceBetween; // reset margins

      if (rtl) slides.css({
        marginLeft: '',
        marginBottom: '',
        marginTop: ''
      });else slides.css({
        marginRight: '',
        marginBottom: '',
        marginTop: ''
      });
      var slidesNumberEvenToRows;

      if (params.slidesPerColumn > 1) {
        if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
          slidesNumberEvenToRows = slidesLength;
        } else {
          slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
        }

        if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
          slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
        }
      } // Calc slides


      var slideSize;
      var slidesPerColumn = params.slidesPerColumn;
      var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
      var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

      for (var i = 0; i < slidesLength; i += 1) {
        slideSize = 0;
        var slide = slides.eq(i);

        if (params.slidesPerColumn > 1) {
          // Set slides order
          var newSlideOrderIndex = void 0;
          var column = void 0;
          var row = void 0;

          if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
            var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
            var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
            var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
            row = Math.floor(slideIndexInGroup / columnsInGroup);
            column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
            newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
            slide.css({
              '-webkit-box-ordinal-group': newSlideOrderIndex,
              '-moz-box-ordinal-group': newSlideOrderIndex,
              '-ms-flex-order': newSlideOrderIndex,
              '-webkit-order': newSlideOrderIndex,
              order: newSlideOrderIndex
            });
          } else if (params.slidesPerColumnFill === 'column') {
            column = Math.floor(i / slidesPerColumn);
            row = i - column * slidesPerColumn;

            if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
              row += 1;

              if (row >= slidesPerColumn) {
                row = 0;
                column += 1;
              }
            }
          } else {
            row = Math.floor(i / slidesPerRow);
            column = i - row * slidesPerRow;
          }

          slide.css(getDirectionLabel('margin-top'), row !== 0 ? params.spaceBetween && params.spaceBetween + "px" : '');
        }

        if (slide.css('display') === 'none') continue; // eslint-disable-line

        if (params.slidesPerView === 'auto') {
          var slideStyles = getComputedStyle(slide[0]);
          var currentTransform = slide[0].style.transform;
          var currentWebKitTransform = slide[0].style.webkitTransform;

          if (currentTransform) {
            slide[0].style.transform = 'none';
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = 'none';
          }

          if (params.roundLengths) {
            slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
          } else {
            // eslint-disable-next-line
            var width = getDirectionPropertyValue(slideStyles, 'width');
            var paddingLeft = getDirectionPropertyValue(slideStyles, 'padding-left');
            var paddingRight = getDirectionPropertyValue(slideStyles, 'padding-right');
            var marginLeft = getDirectionPropertyValue(slideStyles, 'margin-left');
            var marginRight = getDirectionPropertyValue(slideStyles, 'margin-right');
            var boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              var _slide$ = slide[0],
                  clientWidth = _slide$.clientWidth,
                  offsetWidth = _slide$.offsetWidth;
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }

          if (currentTransform) {
            slide[0].style.transform = currentTransform;
          }

          if (currentWebKitTransform) {
            slide[0].style.webkitTransform = currentWebKitTransform;
          }

          if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths) slideSize = Math.floor(slideSize);

          if (slides[i]) {
            slides[i].style[getDirectionLabel('width')] = slideSize + "px";
          }
        }

        if (slides[i]) {
          slides[i].swiperSlideSize = slideSize;
        }

        slidesSizesGrid.push(slideSize);

        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths) slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }

        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }

      swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
      var newSlidesGrid;

      if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
        $wrapperEl.css({
          width: swiper.virtualSize + params.spaceBetween + "px"
        });
      }

      if (params.setWrapperSize) {
        var _$wrapperEl$css;

        $wrapperEl.css((_$wrapperEl$css = {}, _$wrapperEl$css[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css));
      }

      if (params.slidesPerColumn > 1) {
        var _$wrapperEl$css2;

        swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
        $wrapperEl.css((_$wrapperEl$css2 = {}, _$wrapperEl$css2[getDirectionLabel('width')] = swiper.virtualSize + params.spaceBetween + "px", _$wrapperEl$css2));

        if (params.centeredSlides) {
          newSlidesGrid = [];

          for (var _i = 0; _i < snapGrid.length; _i += 1) {
            var slidesGridItem = snapGrid[_i];
            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[_i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
          }

          snapGrid = newSlidesGrid;
        }
      } // Remove last grid elements depending on width


      if (!params.centeredSlides) {
        newSlidesGrid = [];

        for (var _i2 = 0; _i2 < snapGrid.length; _i2 += 1) {
          var _slidesGridItem = snapGrid[_i2];
          if (params.roundLengths) _slidesGridItem = Math.floor(_slidesGridItem);

          if (snapGrid[_i2] <= swiper.virtualSize - swiperSize) {
            newSlidesGrid.push(_slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;

        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper.virtualSize - swiperSize);
        }
      }

      if (snapGrid.length === 0) snapGrid = [0];

      if (params.spaceBetween !== 0) {
        var _slides$filter$css;

        var key = swiper.isHorizontal() && rtl ? 'marginLeft' : getDirectionLabel('marginRight');
        slides.filter(function (_, slideIndex) {
          if (!params.cssMode) return true;

          if (slideIndex === slides.length - 1) {
            return false;
          }

          return true;
        }).css((_slides$filter$css = {}, _slides$filter$css[key] = spaceBetween + "px", _slides$filter$css));
      }

      if (params.centeredSlides && params.centeredSlidesBounds) {
        var allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        allSlidesSize -= params.spaceBetween;
        var maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map(function (snap) {
          if (snap < 0) return -offsetBefore;
          if (snap > maxSnap) return maxSnap + offsetAfter;
          return snap;
        });
      }

      if (params.centerInsufficientSlides) {
        var _allSlidesSize = 0;
        slidesSizesGrid.forEach(function (slideSizeValue) {
          _allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
        });
        _allSlidesSize -= params.spaceBetween;

        if (_allSlidesSize < swiperSize) {
          var allSlidesOffset = (swiperSize - _allSlidesSize) / 2;
          snapGrid.forEach(function (snap, snapIndex) {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach(function (snap, snapIndex) {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }

      extend$1(swiper, {
        slides: slides,
        snapGrid: snapGrid,
        slidesGrid: slidesGrid,
        slidesSizesGrid: slidesSizesGrid
      });

      if (slidesLength !== previousSlidesLength) {
        swiper.emit('slidesLengthChange');
      }

      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit('snapGridLengthChange');
      }

      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit('slidesGridLengthChange');
      }

      if (params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateSlidesOffset();
      }
    }

    function updateAutoHeight(speed) {
      var swiper = this;
      var activeSlides = [];
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var newHeight = 0;
      var i;

      if (typeof speed === 'number') {
        swiper.setTransition(speed);
      } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
      }

      var getSlideByIndex = function getSlideByIndex(index) {
        if (isVirtual) {
          return swiper.slides.filter(function (el) {
            return parseInt(el.getAttribute('data-swiper-slide-index'), 10) === index;
          })[0];
        }

        return swiper.slides.eq(index)[0];
      }; // Find slides currently in view


      if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
          swiper.visibleSlides.each(function (slide) {
            activeSlides.push(slide);
          });
        } else {
          for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
            var index = swiper.activeIndex + i;
            if (index > swiper.slides.length && !isVirtual) break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
      } // Find new height from highest slide in view


      for (i = 0; i < activeSlides.length; i += 1) {
        if (typeof activeSlides[i] !== 'undefined') {
          var height = activeSlides[i].offsetHeight;
          newHeight = height > newHeight ? height : newHeight;
        }
      } // Update Height


      if (newHeight) swiper.$wrapperEl.css('height', newHeight + "px");
    }

    function updateSlidesOffset() {
      var swiper = this;
      var slides = swiper.slides;

      for (var i = 0; i < slides.length; i += 1) {
        slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
      }
    }

    function updateSlidesProgress(translate) {
      if (translate === void 0) {
        translate = this && this.translate || 0;
      }

      var swiper = this;
      var params = swiper.params;
      var slides = swiper.slides,
          rtl = swiper.rtlTranslate;
      if (slides.length === 0) return;
      if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();
      var offsetCenter = -translate;
      if (rtl) offsetCenter = translate; // Visible Slides

      slides.removeClass(params.slideVisibleClass);
      swiper.visibleSlidesIndexes = [];
      swiper.visibleSlides = [];

      for (var i = 0; i < slides.length; i += 1) {
        var slide = slides[i];
        var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

        if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
          var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
          var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
          var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

          if (isVisible) {
            swiper.visibleSlides.push(slide);
            swiper.visibleSlidesIndexes.push(i);
            slides.eq(i).addClass(params.slideVisibleClass);
          }
        }

        slide.progress = rtl ? -slideProgress : slideProgress;
      }

      swiper.visibleSlides = $(swiper.visibleSlides);
    }

    function updateProgress(translate) {
      var swiper = this;

      if (typeof translate === 'undefined') {
        var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

        translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
      }

      var params = swiper.params;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
      var progress = swiper.progress,
          isBeginning = swiper.isBeginning,
          isEnd = swiper.isEnd;
      var wasBeginning = isBeginning;
      var wasEnd = isEnd;

      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate - swiper.minTranslate()) / translatesDiff;
        isBeginning = progress <= 0;
        isEnd = progress >= 1;
      }

      extend$1(swiper, {
        progress: progress,
        isBeginning: isBeginning,
        isEnd: isEnd
      });
      if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate);

      if (isBeginning && !wasBeginning) {
        swiper.emit('reachBeginning toEdge');
      }

      if (isEnd && !wasEnd) {
        swiper.emit('reachEnd toEdge');
      }

      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit('fromEdge');
      }

      swiper.emit('progress', progress);
    }

    function updateSlidesClasses() {
      var swiper = this;
      var slides = swiper.slides,
          params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex,
          realIndex = swiper.realIndex;
      var isVirtual = swiper.virtual && params.virtual.enabled;
      slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
      var activeSlide;

      if (isVirtual) {
        activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
      } else {
        activeSlide = slides.eq(activeIndex);
      } // Active classes


      activeSlide.addClass(params.slideActiveClass);

      if (params.loop) {
        // Duplicate to all looped slides
        if (activeSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
        }
      } // Next Slide


      var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

      if (params.loop && nextSlide.length === 0) {
        nextSlide = slides.eq(0);
        nextSlide.addClass(params.slideNextClass);
      } // Prev Slide


      var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

      if (params.loop && prevSlide.length === 0) {
        prevSlide = slides.eq(-1);
        prevSlide.addClass(params.slidePrevClass);
      }

      if (params.loop) {
        // Duplicate to all looped slides
        if (nextSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
        }

        if (prevSlide.hasClass(params.slideDuplicateClass)) {
          $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
        } else {
          $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
        }
      }

      swiper.emitSlidesClasses();
    }

    function updateActiveIndex(newActiveIndex) {
      var swiper = this;
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
      var slidesGrid = swiper.slidesGrid,
          snapGrid = swiper.snapGrid,
          params = swiper.params,
          previousIndex = swiper.activeIndex,
          previousRealIndex = swiper.realIndex,
          previousSnapIndex = swiper.snapIndex;
      var activeIndex = newActiveIndex;
      var snapIndex;

      if (typeof activeIndex === 'undefined') {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
              activeIndex = i;
            } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
              activeIndex = i + 1;
            }
          } else if (translate >= slidesGrid[i]) {
            activeIndex = i;
          }
        } // Normalize slideIndex


        if (params.normalizeSlideIndex) {
          if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
        }
      }

      if (snapGrid.indexOf(translate) >= 0) {
        snapIndex = snapGrid.indexOf(translate);
      } else {
        var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }

      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper.snapIndex = snapIndex;
          swiper.emit('snapIndexChange');
        }

        return;
      } // Get real index


      var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
      extend$1(swiper, {
        snapIndex: snapIndex,
        realIndex: realIndex,
        previousIndex: previousIndex,
        activeIndex: activeIndex
      });
      swiper.emit('activeIndexChange');
      swiper.emit('snapIndexChange');

      if (previousRealIndex !== realIndex) {
        swiper.emit('realIndexChange');
      }

      if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        swiper.emit('slideChange');
      }
    }

    function updateClickedSlide(e) {
      var swiper = this;
      var params = swiper.params;
      var slide = $(e.target).closest("." + params.slideClass)[0];
      var slideFound = false;
      var slideIndex;

      if (slide) {
        for (var i = 0; i < swiper.slides.length; i += 1) {
          if (swiper.slides[i] === slide) {
            slideFound = true;
            slideIndex = i;
            break;
          }
        }
      }

      if (slide && slideFound) {
        swiper.clickedSlide = slide;

        if (swiper.virtual && swiper.params.virtual.enabled) {
          swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
        } else {
          swiper.clickedIndex = slideIndex;
        }
      } else {
        swiper.clickedSlide = undefined;
        swiper.clickedIndex = undefined;
        return;
      }

      if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
      }
    }

    var update = {
      updateSize: updateSize,
      updateSlides: updateSlides,
      updateAutoHeight: updateAutoHeight,
      updateSlidesOffset: updateSlidesOffset,
      updateSlidesProgress: updateSlidesProgress,
      updateProgress: updateProgress,
      updateSlidesClasses: updateSlidesClasses,
      updateActiveIndex: updateActiveIndex,
      updateClickedSlide: updateClickedSlide
    };

    function getSwiperTranslate(axis) {
      if (axis === void 0) {
        axis = this.isHorizontal() ? 'x' : 'y';
      }

      var swiper = this;
      var params = swiper.params,
          rtl = swiper.rtlTranslate,
          translate = swiper.translate,
          $wrapperEl = swiper.$wrapperEl;

      if (params.virtualTranslate) {
        return rtl ? -translate : translate;
      }

      if (params.cssMode) {
        return translate;
      }

      var currentTranslate = getTranslate($wrapperEl[0], axis);
      if (rtl) currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }

    function setTranslate(translate, byController) {
      var swiper = this;
      var rtl = swiper.rtlTranslate,
          params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          wrapperEl = swiper.wrapperEl,
          progress = swiper.progress;
      var x = 0;
      var y = 0;
      var z = 0;

      if (swiper.isHorizontal()) {
        x = rtl ? -translate : translate;
      } else {
        y = translate;
      }

      if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
      }

      if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
      } else if (!params.virtualTranslate) {
        $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
      }

      swiper.previousTranslate = swiper.translate;
      swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== progress) {
        swiper.updateProgress(translate);
      }

      swiper.emit('setTranslate', swiper.translate, byController);
    }

    function minTranslate() {
      return -this.snapGrid[0];
    }

    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }

    function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
      if (translate === void 0) {
        translate = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (translateBounds === void 0) {
        translateBounds = true;
      }

      var swiper = this;
      var params = swiper.params,
          wrapperEl = swiper.wrapperEl;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
      }

      var minTranslate = swiper.minTranslate();
      var maxTranslate = swiper.maxTranslate();
      var newTranslate;
      if (translateBounds && translate > minTranslate) newTranslate = minTranslate;else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;else newTranslate = translate; // Update progress

      swiper.updateProgress(newTranslate);

      if (params.cssMode) {
        var isH = swiper.isHorizontal();

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            var _wrapperEl$scrollTo;

            wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = -newTranslate, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
          }
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionEnd');
        }
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);

        if (runCallbacks) {
          swiper.emit('beforeTransitionStart', speed, internal);
          swiper.emit('transitionStart');
        }

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onTranslateToWrapperTransitionEnd) {
            swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
              swiper.onTranslateToWrapperTransitionEnd = null;
              delete swiper.onTranslateToWrapperTransitionEnd;

              if (runCallbacks) {
                swiper.emit('transitionEnd');
              }
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
        }
      }

      return true;
    }

    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate: setTranslate,
      minTranslate: minTranslate,
      maxTranslate: maxTranslate,
      translateTo: translateTo
    };

    function setTransition(duration, byController) {
      var swiper = this;

      if (!swiper.params.cssMode) {
        swiper.$wrapperEl.transition(duration);
      }

      swiper.emit('setTransition', duration, byController);
    }

    function transitionStart(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var activeIndex = swiper.activeIndex,
          params = swiper.params,
          previousIndex = swiper.previousIndex;
      if (params.cssMode) return;

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      var dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit('transitionStart');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionStart');
          return;
        }

        swiper.emit('slideChangeTransitionStart');

        if (dir === 'next') {
          swiper.emit('slideNextTransitionStart');
        } else {
          swiper.emit('slidePrevTransitionStart');
        }
      }
    }

    function transitionEnd(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var activeIndex = swiper.activeIndex,
          previousIndex = swiper.previousIndex,
          params = swiper.params;
      swiper.animating = false;
      if (params.cssMode) return;
      swiper.setTransition(0);
      var dir = direction;

      if (!dir) {
        if (activeIndex > previousIndex) dir = 'next';else if (activeIndex < previousIndex) dir = 'prev';else dir = 'reset';
      }

      swiper.emit('transitionEnd');

      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === 'reset') {
          swiper.emit('slideResetTransitionEnd');
          return;
        }

        swiper.emit('slideChangeTransitionEnd');

        if (dir === 'next') {
          swiper.emit('slideNextTransitionEnd');
        } else {
          swiper.emit('slidePrevTransitionEnd');
        }
      }
    }

    var transition = {
      setTransition: setTransition,
      transitionStart: transitionStart,
      transitionEnd: transitionEnd
    };

    function slideTo(index, speed, runCallbacks, internal, initial) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (typeof index !== 'number' && typeof index !== 'string') {
        throw new Error("The 'index' argument cannot have type other than 'number' or 'string'. [" + typeof index + "] given.");
      }

      if (typeof index === 'string') {
        /**
         * The `index` argument converted from `string` to `number`.
         * @type {number}
         */
        var indexAsNumber = parseInt(index, 10);
        /**
         * Determines whether the `index` argument is a valid `number`
         * after being converted from the `string` type.
         * @type {boolean}
         */

        var isValidNumber = isFinite(indexAsNumber);

        if (!isValidNumber) {
          throw new Error("The passed-in 'index' (string) couldn't be converted to 'number'. [" + index + "] given.");
        } // Knowing that the converted `index` is a valid number,
        // we can update the original argument's value.


        index = indexAsNumber;
      }

      var swiper = this;
      var slideIndex = index;
      if (slideIndex < 0) slideIndex = 0;
      var params = swiper.params,
          snapGrid = swiper.snapGrid,
          slidesGrid = swiper.slidesGrid,
          previousIndex = swiper.previousIndex,
          activeIndex = swiper.activeIndex,
          rtl = swiper.rtlTranslate,
          wrapperEl = swiper.wrapperEl,
          enabled = swiper.enabled;

      if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }

      var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
      var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

      if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
        swiper.emit('beforeSlideChangeStart');
      }

      var translate = -snapGrid[snapIndex]; // Update progress

      swiper.updateProgress(translate); // Normalize slideIndex

      if (params.normalizeSlideIndex) {
        for (var i = 0; i < slidesGrid.length; i += 1) {
          var normalizedTranslate = -Math.floor(translate * 100);
          var normalizedGird = Math.floor(slidesGrid[i] * 100);
          var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);

          if (typeof slidesGrid[i + 1] !== 'undefined') {
            if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGird) / 2) {
              slideIndex = i;
            } else if (normalizedTranslate >= normalizedGird && normalizedTranslate < normalizedGridNext) {
              slideIndex = i + 1;
            }
          } else if (normalizedTranslate >= normalizedGird) {
            slideIndex = i;
          }
        }
      } // Directions locks


      if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
          return false;
        }

        if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) return false;
        }
      }

      var direction;
      if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index

      if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
        swiper.updateActiveIndex(slideIndex); // Update Height

        if (params.autoHeight) {
          swiper.updateAutoHeight();
        }

        swiper.updateSlidesClasses();

        if (params.effect !== 'slide') {
          swiper.setTranslate(translate);
        }

        if (direction !== 'reset') {
          swiper.transitionStart(runCallbacks, direction);
          swiper.transitionEnd(runCallbacks, direction);
        }

        return false;
      }

      if (params.cssMode) {
        var isH = swiper.isHorizontal();
        var t = -translate;

        if (rtl) {
          t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
        }

        if (speed === 0) {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        } else {
          // eslint-disable-next-line
          if (wrapperEl.scrollTo) {
            var _wrapperEl$scrollTo;

            wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _wrapperEl$scrollTo[isH ? 'left' : 'top'] = t, _wrapperEl$scrollTo.behavior = 'smooth', _wrapperEl$scrollTo));
          } else {
            wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
          }
        }

        return true;
      }

      if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      } else {
        swiper.setTransition(speed);
        swiper.setTranslate(translate);
        swiper.updateActiveIndex(slideIndex);
        swiper.updateSlidesClasses();
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.transitionStart(runCallbacks, direction);

        if (!swiper.animating) {
          swiper.animating = true;

          if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
              if (!swiper || swiper.destroyed) return;
              if (e.target !== this) return;
              swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
              swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
              swiper.onSlideToWrapperTransitionEnd = null;
              delete swiper.onSlideToWrapperTransitionEnd;
              swiper.transitionEnd(runCallbacks, direction);
            };
          }

          swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
          swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
        }
      }

      return true;
    }

    function slideToLoop(index, speed, runCallbacks, internal) {
      if (index === void 0) {
        index = 0;
      }

      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var newIndex = index;

      if (swiper.params.loop) {
        newIndex += swiper.loopedSlides;
      }

      return swiper.slideTo(newIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideNext(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var params = swiper.params,
          animating = swiper.animating,
          enabled = swiper.enabled;
      if (!enabled) return swiper;
      var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slidePrev(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      var params = swiper.params,
          animating = swiper.animating,
          snapGrid = swiper.snapGrid,
          slidesGrid = swiper.slidesGrid,
          rtlTranslate = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return swiper;

      if (params.loop) {
        if (animating && params.loopPreventsSlide) return false;
        swiper.loopFix(); // eslint-disable-next-line

        swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
      }

      var translate = rtlTranslate ? swiper.translate : -swiper.translate;

      function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }

      var normalizedTranslate = normalize(translate);
      var normalizedSnapGrid = snapGrid.map(function (val) {
        return normalize(val);
      });
      var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

      if (typeof prevSnap === 'undefined' && params.cssMode) {
        snapGrid.forEach(function (snap) {
          if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
        });
      }

      var prevIndex;

      if (typeof prevSnap !== 'undefined') {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
      }

      return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideReset(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      var swiper = this;
      return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
    }

    /* eslint no-unused-vars: "off" */
    function slideToClosest(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
        speed = this.params.speed;
      }

      if (runCallbacks === void 0) {
        runCallbacks = true;
      }

      if (threshold === void 0) {
        threshold = 0.5;
      }

      var swiper = this;
      var index = swiper.activeIndex;
      var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
      var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

      if (translate >= swiper.snapGrid[snapIndex]) {
        // The current translate is on or after the current snap index, so the choice
        // is between the current index and the one after it.
        var currentSnap = swiper.snapGrid[snapIndex];
        var nextSnap = swiper.snapGrid[snapIndex + 1];

        if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper.params.slidesPerGroup;
        }
      } else {
        // The current translate is before the current snap index, so the choice
        // is between the current index and the one before it.
        var prevSnap = swiper.snapGrid[snapIndex - 1];
        var _currentSnap = swiper.snapGrid[snapIndex];

        if (translate - prevSnap <= (_currentSnap - prevSnap) * threshold) {
          index -= swiper.params.slidesPerGroup;
        }
      }

      index = Math.max(index, 0);
      index = Math.min(index, swiper.slidesGrid.length - 1);
      return swiper.slideTo(index, speed, runCallbacks, internal);
    }

    function slideToClickedSlide() {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl;
      var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
      var slideToIndex = swiper.clickedIndex;
      var realIndex;

      if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

        if (params.centeredSlides) {
          if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
            swiper.loopFix();
            slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
            nextTick$1(function () {
              swiper.slideTo(slideToIndex);
            });
          } else {
            swiper.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
          nextTick$1(function () {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else {
        swiper.slideTo(slideToIndex);
      }
    }

    var slide = {
      slideTo: slideTo,
      slideToLoop: slideToLoop,
      slideNext: slideNext,
      slidePrev: slidePrev,
      slideReset: slideReset,
      slideToClosest: slideToClosest,
      slideToClickedSlide: slideToClickedSlide
    };

    function loopCreate() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
      var slides = $wrapperEl.children("." + params.slideClass);

      if (params.loopFillGroupWithBlank) {
        var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

        if (blankSlidesNum !== params.slidesPerGroup) {
          for (var i = 0; i < blankSlidesNum; i += 1) {
            var blankNode = $(document.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
            $wrapperEl.append(blankNode);
          }

          slides = $wrapperEl.children("." + params.slideClass);
        }
      }

      if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;
      swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
      swiper.loopedSlides += params.loopAdditionalSlides;

      if (swiper.loopedSlides > slides.length) {
        swiper.loopedSlides = slides.length;
      }

      var prependSlides = [];
      var appendSlides = [];
      slides.each(function (el, index) {
        var slide = $(el);

        if (index < swiper.loopedSlides) {
          appendSlides.push(el);
        }

        if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
          prependSlides.push(el);
        }

        slide.attr('data-swiper-slide-index', index);
      });

      for (var _i = 0; _i < appendSlides.length; _i += 1) {
        $wrapperEl.append($(appendSlides[_i].cloneNode(true)).addClass(params.slideDuplicateClass));
      }

      for (var _i2 = prependSlides.length - 1; _i2 >= 0; _i2 -= 1) {
        $wrapperEl.prepend($(prependSlides[_i2].cloneNode(true)).addClass(params.slideDuplicateClass));
      }
    }

    function loopFix() {
      var swiper = this;
      swiper.emit('beforeLoopFix');
      var activeIndex = swiper.activeIndex,
          slides = swiper.slides,
          loopedSlides = swiper.loopedSlides,
          allowSlidePrev = swiper.allowSlidePrev,
          allowSlideNext = swiper.allowSlideNext,
          snapGrid = swiper.snapGrid,
          rtl = swiper.rtlTranslate;
      var newIndex;
      swiper.allowSlidePrev = true;
      swiper.allowSlideNext = true;
      var snapTranslate = -snapGrid[activeIndex];
      var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

      if (activeIndex < loopedSlides) {
        newIndex = slides.length - loopedSlides * 3 + activeIndex;
        newIndex += loopedSlides;
        var slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      } else if (activeIndex >= slides.length - loopedSlides) {
        // Fix For Positive Oversliding
        newIndex = -slides.length + activeIndex + loopedSlides;
        newIndex += loopedSlides;

        var _slideChanged = swiper.slideTo(newIndex, 0, false, true);

        if (_slideChanged && diff !== 0) {
          swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
        }
      }

      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;
      swiper.emit('loopFix');
    }

    function loopDestroy() {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params,
          slides = swiper.slides;
      $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
      slides.removeAttr('data-swiper-slide-index');
    }

    var loop = {
      loopCreate: loopCreate,
      loopFix: loopFix,
      loopDestroy: loopDestroy
    };

    function setGrabCursor(moving) {
      var swiper = this;
      if (swiper.support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
      var el = swiper.el;
      el.style.cursor = 'move';
      el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
      el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
      el.style.cursor = moving ? 'grabbing' : 'grab';
    }

    function unsetGrabCursor() {
      var swiper = this;

      if (swiper.support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
      }

      swiper.el.style.cursor = '';
    }

    var grabCursor = {
      setGrabCursor: setGrabCursor,
      unsetGrabCursor: unsetGrabCursor
    };

    function appendSlide(slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params;

      if (params.loop) {
        swiper.loopDestroy();
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.append(slides[i]);
        }
      } else {
        $wrapperEl.append(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }
    }

    function prependSlide(slides) {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex;

      if (params.loop) {
        swiper.loopDestroy();
      }

      var newActiveIndex = activeIndex + 1;

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) $wrapperEl.prepend(slides[i]);
        }

        newActiveIndex = activeIndex + slides.length;
      } else {
        $wrapperEl.prepend(slides);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      swiper.slideTo(newActiveIndex, 0, false);
    }

    function addSlide(index, slides) {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl,
          params = swiper.params,
          activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
      }

      var baseLength = swiper.slides.length;

      if (index <= 0) {
        swiper.prependSlide(slides);
        return;
      }

      if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
      }

      var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
      var slidesBuffer = [];

      for (var i = baseLength - 1; i >= index; i -= 1) {
        var currentSlide = swiper.slides.eq(i);
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
      }

      if (typeof slides === 'object' && 'length' in slides) {
        for (var _i = 0; _i < slides.length; _i += 1) {
          if (slides[_i]) $wrapperEl.append(slides[_i]);
        }

        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
      } else {
        $wrapperEl.append(slides);
      }

      for (var _i2 = 0; _i2 < slidesBuffer.length; _i2 += 1) {
        $wrapperEl.append(slidesBuffer[_i2]);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeSlide(slidesIndexes) {
      var swiper = this;
      var params = swiper.params,
          $wrapperEl = swiper.$wrapperEl,
          activeIndex = swiper.activeIndex;
      var activeIndexBuffer = activeIndex;

      if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.slides = $wrapperEl.children("." + params.slideClass);
      }

      var newActiveIndex = activeIndexBuffer;
      var indexToRemove;

      if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
        for (var i = 0; i < slidesIndexes.length; i += 1) {
          indexToRemove = slidesIndexes[i];
          if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
          if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }

        newActiveIndex = Math.max(newActiveIndex, 0);
      } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
      }

      if (params.loop) {
        swiper.loopCreate();
      }

      if (!(params.observer && swiper.support.observer)) {
        swiper.update();
      }

      if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
      } else {
        swiper.slideTo(newActiveIndex, 0, false);
      }
    }

    function removeAllSlides() {
      var swiper = this;
      var slidesIndexes = [];

      for (var i = 0; i < swiper.slides.length; i += 1) {
        slidesIndexes.push(i);
      }

      swiper.removeSlide(slidesIndexes);
    }

    var manipulation = {
      appendSlide: appendSlide,
      prependSlide: prependSlide,
      addSlide: addSlide,
      removeSlide: removeSlide,
      removeAllSlides: removeAllSlides
    };

    function closestElement(selector, base) {
      if (base === void 0) {
        base = this;
      }

      function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        var found = el.closest(selector);
        return found || __closestFrom(el.getRootNode().host);
      }

      return __closestFrom(base);
    }

    function onTouchStart(event) {
      var swiper = this;
      var document = getDocument();
      var window = getWindow();
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          enabled = swiper.enabled;
      if (!enabled) return;

      if (swiper.animating && params.preventInteractionOnTransition) {
        return;
      }

      var e = event;
      if (e.originalEvent) e = e.originalEvent;
      var $targetEl = $(e.target);

      if (params.touchEventsTarget === 'wrapper') {
        if (!$targetEl.closest(swiper.wrapperEl).length) return;
      }

      data.isTouchEvent = e.type === 'touchstart';
      if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
      if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
      if (data.isTouched && data.isMoved) return; // change target el for shadow root component

      var swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== '';

      if (swipingClassHasValue && e.target && e.target.shadowRoot && event.path && event.path[0]) {
        $targetEl = $(event.path[0]);
      }

      var noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass;
      var isTargetShadow = !!(e.target && e.target.shadowRoot); // use closestElement for shadow root element to get the actual closest for nested shadow root element

      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, e.target) : $targetEl.closest(noSwipingSelector)[0])) {
        swiper.allowClick = true;
        return;
      }

      if (params.swipeHandler) {
        if (!$targetEl.closest(params.swipeHandler)[0]) return;
      }

      touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      var startX = touches.currentX;
      var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

      var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === 'prevent') {
          event.preventDefault();
        } else {
          return;
        }
      }

      extend$1(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: undefined,
        startMoving: undefined
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper.allowClick = true;
      swiper.updateSize();
      swiper.swipeDirection = undefined;
      if (params.threshold > 0) data.allowThresholdMove = false;

      if (e.type !== 'touchstart') {
        var preventDefault = true;
        if ($targetEl.is(data.focusableElements)) preventDefault = false;

        if (document.activeElement && $(document.activeElement).is(data.focusableElements) && document.activeElement !== $targetEl[0]) {
          document.activeElement.blur();
        }

        var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

        if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !$targetEl[0].isContentEditable) {
          e.preventDefault();
        }
      }

      swiper.emit('touchStart', e);
    }

    function onTouchMove(event) {
      var document = getDocument();
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          rtl = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper.emit('touchMoveOpposite', e);
        }

        return;
      }

      if (data.isTouchEvent && e.type !== 'touchmove') return;
      var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
      var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
      var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

      if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }

      if (!swiper.allowTouchMove) {
        // isMoved = true;
        swiper.allowClick = false;

        if (data.isTouched) {
          extend$1(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now();
        }

        return;
      }

      if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
          // Vertical
          if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
          return;
        }
      }

      if (data.isTouchEvent && document.activeElement) {
        if (e.target === document.activeElement && $(e.target).is(data.focusableElements)) {
          data.isMoved = true;
          swiper.allowClick = false;
          return;
        }
      }

      if (data.allowTouchCallbacks) {
        swiper.emit('touchMove', e);
      }

      if (e.targetTouches && e.targetTouches.length > 1) return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      var diffX = touches.currentX - touches.startX;
      var diffY = touches.currentY - touches.startY;
      if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;

      if (typeof data.isScrolling === 'undefined') {
        var touchAngle;

        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          // eslint-disable-next-line
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }

      if (data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      if (typeof data.startMoving === 'undefined') {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }

      if (data.isScrolling) {
        data.isTouched = false;
        return;
      }

      if (!data.startMoving) {
        return;
      }

      swiper.allowClick = false;

      if (!params.cssMode && e.cancelable) {
        e.preventDefault();
      }

      if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
      }

      if (!data.isMoved) {
        if (params.loop) {
          swiper.loopFix();
        }

        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);

        if (swiper.animating) {
          swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
        }

        data.allowMomentumBounce = false; // Grab Cursor

        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
          swiper.setGrabCursor(true);
        }

        swiper.emit('sliderFirstMove', e);
      }

      swiper.emit('sliderMove', e);
      data.isMoved = true;
      var diff = swiper.isHorizontal() ? diffX : diffY;
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) diff = -diff;
      swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
      data.currentTranslate = diff + data.startTranslate;
      var disableParentSwiper = true;
      var resistanceRatio = params.resistanceRatio;

      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }

      if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
      } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
        disableParentSwiper = false;
        if (params.resistance) data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
      }

      if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
      } // Directions locks


      if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }

      if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      } // Threshold


      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }

      if (!params.followFinger || params.cssMode) return; // Update active index in free mode

      if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      if (params.freeMode) {
        // Velocity
        if (data.velocities.length === 0) {
          data.velocities.push({
            position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
            time: data.touchStartTime
          });
        }

        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
          time: now()
        });
      } // Update progress


      swiper.updateProgress(data.currentTranslate); // Update translate

      swiper.setTranslate(data.currentTranslate);
    }

    function onTouchEnd(event) {
      var swiper = this;
      var data = swiper.touchEventsData;
      var params = swiper.params,
          touches = swiper.touches,
          rtl = swiper.rtlTranslate,
          $wrapperEl = swiper.$wrapperEl,
          slidesGrid = swiper.slidesGrid,
          snapGrid = swiper.snapGrid,
          enabled = swiper.enabled;
      if (!enabled) return;
      var e = event;
      if (e.originalEvent) e = e.originalEvent;

      if (data.allowTouchCallbacks) {
        swiper.emit('touchEnd', e);
      }

      data.allowTouchCallbacks = false;

      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper.setGrabCursor(false);
        }

        data.isMoved = false;
        data.startMoving = false;
        return;
      } // Return Grab Cursor


      if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
      } // Time diff


      var touchEndTime = now();
      var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

      if (swiper.allowClick) {
        swiper.updateClickedSlide(e);
        swiper.emit('tap click', e);

        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper.emit('doubleTap doubleClick', e);
        }
      }

      data.lastClickTime = now();
      nextTick$1(function () {
        if (!swiper.destroyed) swiper.allowClick = true;
      });

      if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }

      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      var currentPos;

      if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
      } else {
        currentPos = -data.currentTranslate;
      }

      if (params.cssMode) {
        return;
      }

      if (params.freeMode) {
        if (currentPos < -swiper.minTranslate()) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (currentPos > -swiper.maxTranslate()) {
          if (swiper.slides.length < snapGrid.length) {
            swiper.slideTo(snapGrid.length - 1);
          } else {
            swiper.slideTo(swiper.slides.length - 1);
          }

          return;
        }

        if (params.freeModeMomentum) {
          if (data.velocities.length > 1) {
            var lastMoveEvent = data.velocities.pop();
            var velocityEvent = data.velocities.pop();
            var distance = lastMoveEvent.position - velocityEvent.position;
            var time = lastMoveEvent.time - velocityEvent.time;
            swiper.velocity = distance / time;
            swiper.velocity /= 2;

            if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
              swiper.velocity = 0;
            } // this implies that the user stopped moving a finger then released.
            // There would be no events with distance zero, so the last event is stale.


            if (time > 150 || now() - lastMoveEvent.time > 300) {
              swiper.velocity = 0;
            }
          } else {
            swiper.velocity = 0;
          }

          swiper.velocity *= params.freeModeMomentumVelocityRatio;
          data.velocities.length = 0;
          var momentumDuration = 1000 * params.freeModeMomentumRatio;
          var momentumDistance = swiper.velocity * momentumDuration;
          var newPosition = swiper.translate + momentumDistance;
          if (rtl) newPosition = -newPosition;
          var doBounce = false;
          var afterBouncePosition;
          var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
          var needsLoopFix;

          if (newPosition < swiper.maxTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                newPosition = swiper.maxTranslate() - bounceAmount;
              }

              afterBouncePosition = swiper.maxTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.maxTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (newPosition > swiper.minTranslate()) {
            if (params.freeModeMomentumBounce) {
              if (newPosition - swiper.minTranslate() > bounceAmount) {
                newPosition = swiper.minTranslate() + bounceAmount;
              }

              afterBouncePosition = swiper.minTranslate();
              doBounce = true;
              data.allowMomentumBounce = true;
            } else {
              newPosition = swiper.minTranslate();
            }

            if (params.loop && params.centeredSlides) needsLoopFix = true;
          } else if (params.freeModeSticky) {
            var nextSlide;

            for (var j = 0; j < snapGrid.length; j += 1) {
              if (snapGrid[j] > -newPosition) {
                nextSlide = j;
                break;
              }
            }

            if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
              newPosition = snapGrid[nextSlide];
            } else {
              newPosition = snapGrid[nextSlide - 1];
            }

            newPosition = -newPosition;
          }

          if (needsLoopFix) {
            swiper.once('transitionEnd', function () {
              swiper.loopFix();
            });
          } // Fix duration


          if (swiper.velocity !== 0) {
            if (rtl) {
              momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
            } else {
              momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
            }

            if (params.freeModeSticky) {
              // If freeModeSticky is active and the user ends a swipe with a slow-velocity
              // event, then durations can be 20+ seconds to slide one (or zero!) slides.
              // It's easy to see this when simulating touch with mouse events. To fix this,
              // limit single-slide swipes to the default slide duration. This also has the
              // nice side effect of matching slide speed if the user stopped moving before
              // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
              // For faster swipes, also apply limits (albeit higher ones).
              var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
              var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

              if (moveDistance < currentSlideSize) {
                momentumDuration = params.speed;
              } else if (moveDistance < 2 * currentSlideSize) {
                momentumDuration = params.speed * 1.5;
              } else {
                momentumDuration = params.speed * 2.5;
              }
            }
          } else if (params.freeModeSticky) {
            swiper.slideToClosest();
            return;
          }

          if (params.freeModeMomentumBounce && doBounce) {
            swiper.updateProgress(afterBouncePosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);
            swiper.animating = true;
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
              swiper.emit('momentumBounce');
              swiper.setTransition(params.speed);
              setTimeout(function () {
                swiper.setTranslate(afterBouncePosition);
                $wrapperEl.transitionEnd(function () {
                  if (!swiper || swiper.destroyed) return;
                  swiper.transitionEnd();
                });
              }, 0);
            });
          } else if (swiper.velocity) {
            swiper.updateProgress(newPosition);
            swiper.setTransition(momentumDuration);
            swiper.setTranslate(newPosition);
            swiper.transitionStart(true, swiper.swipeDirection);

            if (!swiper.animating) {
              swiper.animating = true;
              $wrapperEl.transitionEnd(function () {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }
          } else {
            swiper.emit('_freeModeNoMomentumRelease');
            swiper.updateProgress(newPosition);
          }

          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        } else if (params.freeMode) {
          swiper.emit('_freeModeNoMomentumRelease');
        }

        if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        return;
      } // Find current slide


      var stopIndex = 0;
      var groupSize = swiper.slidesSizesGrid[0];

      for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        var _increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

        if (typeof slidesGrid[i + _increment] !== 'undefined') {
          if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + _increment]) {
            stopIndex = i;
            groupSize = slidesGrid[i + _increment] - slidesGrid[i];
          }
        } else if (currentPos >= slidesGrid[i]) {
          stopIndex = i;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      } // Find current slide size


      var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (timeDiff > params.longSwipesMs) {
        // Long touches
        if (!params.longSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        if (swiper.swipeDirection === 'next') {
          if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }

        if (swiper.swipeDirection === 'prev') {
          if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);
        }
      } else {
        // Short swipes
        if (!params.shortSwipes) {
          swiper.slideTo(swiper.activeIndex);
          return;
        }

        var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

        if (!isNavButtonTarget) {
          if (swiper.swipeDirection === 'next') {
            swiper.slideTo(stopIndex + increment);
          }

          if (swiper.swipeDirection === 'prev') {
            swiper.slideTo(stopIndex);
          }
        } else if (e.target === swiper.navigation.nextEl) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    }

    function onResize() {
      var swiper = this;
      var params = swiper.params,
          el = swiper.el;
      if (el && el.offsetWidth === 0) return; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      } // Save locks


      var allowSlideNext = swiper.allowSlideNext,
          allowSlidePrev = swiper.allowSlidePrev,
          snapGrid = swiper.snapGrid; // Disable locks on resize

      swiper.allowSlideNext = true;
      swiper.allowSlidePrev = true;
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateSlidesClasses();

      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
      } else {
        swiper.slideTo(swiper.activeIndex, 0, false, true);
      }

      if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        swiper.autoplay.run();
      } // Return locks after resize


      swiper.allowSlidePrev = allowSlidePrev;
      swiper.allowSlideNext = allowSlideNext;

      if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
    }

    function onClick(e) {
      var swiper = this;
      if (!swiper.enabled) return;

      if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();

        if (swiper.params.preventClicksPropagation && swiper.animating) {
          e.stopPropagation();
          e.stopImmediatePropagation();
        }
      }
    }

    function onScroll() {
      var swiper = this;
      var wrapperEl = swiper.wrapperEl,
          rtlTranslate = swiper.rtlTranslate,
          enabled = swiper.enabled;
      if (!enabled) return;
      swiper.previousTranslate = swiper.translate;

      if (swiper.isHorizontal()) {
        if (rtlTranslate) {
          swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
        } else {
          swiper.translate = -wrapperEl.scrollLeft;
        }
      } else {
        swiper.translate = -wrapperEl.scrollTop;
      } // eslint-disable-next-line


      if (swiper.translate === -0) swiper.translate = 0;
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
      var newProgress;
      var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
      }

      if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
      }

      swiper.emit('setTranslate', swiper.translate, false);
    }

    var dummyEventAttached = false;

    function dummyEventListener() {}

    function attachEvents() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          touchEvents = swiper.touchEvents,
          el = swiper.el,
          wrapperEl = swiper.wrapperEl,
          device = swiper.device,
          support = swiper.support;
      swiper.onTouchStart = onTouchStart.bind(swiper);
      swiper.onTouchMove = onTouchMove.bind(swiper);
      swiper.onTouchEnd = onTouchEnd.bind(swiper);

      if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
      }

      swiper.onClick = onClick.bind(swiper);
      var capture = !!params.nested; // Touch Events

      if (!support.touch && support.pointerEvents) {
        el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
        document.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (support.touch) {
          var passiveListener = touchEvents.start === 'touchstart' && support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.addEventListener(touchEvents.move, swiper.onTouchMove, support.passiveListener ? {
            passive: false,
            capture: capture
          } : capture);
          el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

          if (touchEvents.cancel) {
            el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }

          if (!dummyEventAttached) {
            document.addEventListener('touchstart', dummyEventListener);
            dummyEventAttached = true;
          }
        }

        if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
          el.addEventListener('mousedown', swiper.onTouchStart, false);
          document.addEventListener('mousemove', swiper.onTouchMove, capture);
          document.addEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el.addEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.addEventListener('scroll', swiper.onScroll);
      } // Resize handler


      if (params.updateOnWindowResize) {
        swiper.on(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
      } else {
        swiper.on('observerUpdate', onResize, true);
      }
    }

    function detachEvents() {
      var swiper = this;
      var document = getDocument();
      var params = swiper.params,
          touchEvents = swiper.touchEvents,
          el = swiper.el,
          wrapperEl = swiper.wrapperEl,
          device = swiper.device,
          support = swiper.support;
      var capture = !!params.nested; // Touch Events

      if (!support.touch && support.pointerEvents) {
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
        document.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        document.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
      } else {
        if (support.touch) {
          var passiveListener = touchEvents.start === 'onTouchStart' && support.passiveListener && params.passiveListeners ? {
            passive: true,
            capture: false
          } : false;
          el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
          el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
          el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

          if (touchEvents.cancel) {
            el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
          }
        }

        if (params.simulateTouch && !device.ios && !device.android || params.simulateTouch && !support.touch && device.ios) {
          el.removeEventListener('mousedown', swiper.onTouchStart, false);
          document.removeEventListener('mousemove', swiper.onTouchMove, capture);
          document.removeEventListener('mouseup', swiper.onTouchEnd, false);
        }
      } // Prevent Links Clicks


      if (params.preventClicks || params.preventClicksPropagation) {
        el.removeEventListener('click', swiper.onClick, true);
      }

      if (params.cssMode) {
        wrapperEl.removeEventListener('scroll', swiper.onScroll);
      } // Resize handler


      swiper.off(device.ios || device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
    }

    var events = {
      attachEvents: attachEvents,
      detachEvents: detachEvents
    };

    function setBreakpoint() {
      var swiper = this;
      var activeIndex = swiper.activeIndex,
          initialized = swiper.initialized,
          _swiper$loopedSlides = swiper.loopedSlides,
          loopedSlides = _swiper$loopedSlides === void 0 ? 0 : _swiper$loopedSlides,
          params = swiper.params,
          $el = swiper.$el;
      var breakpoints = params.breakpoints;
      if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) return; // Get breakpoint for window width and update parameters

      var breakpoint = swiper.getBreakpoint(breakpoints, swiper.params.breakpointsBase, swiper.el);
      if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

      if (breakpointOnlyParams) {
        ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
          var paramValue = breakpointOnlyParams[param];
          if (typeof paramValue === 'undefined') return;

          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
            breakpointOnlyParams[param] = 'auto';
          } else if (param === 'slidesPerView') {
            breakpointOnlyParams[param] = parseFloat(paramValue);
          } else {
            breakpointOnlyParams[param] = parseInt(paramValue, 10);
          }
        });
      }

      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
      var wasMultiRow = params.slidesPerColumn > 1;
      var isMultiRow = breakpointParams.slidesPerColumn > 1;
      var wasEnabled = params.enabled;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
        swiper.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(params.containerModifierClass + "multirow");

        if (breakpointParams.slidesPerColumnFill && breakpointParams.slidesPerColumnFill === 'column' || !breakpointParams.slidesPerColumnFill && params.slidesPerColumnFill === 'column') {
          $el.addClass(params.containerModifierClass + "multirow-column");
        }

        swiper.emitContainerClasses();
      }

      var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      extend$1(swiper.params, breakpointParams);
      var isEnabled = swiper.params.enabled;
      extend$1(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });

      if (wasEnabled && !isEnabled) {
        swiper.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper.enable();
      }

      swiper.currentBreakpoint = breakpoint;
      swiper.emit('_beforeBreakpoint', breakpointParams);

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }

    function getBreakpoint(breakpoints, base, containerEl) {
      if (base === void 0) {
        base = 'window';
      }

      if (!breakpoints || base === 'container' && !containerEl) return undefined;
      var breakpoint = false;
      var window = getWindow();
      var currentHeight = base === 'window' ? window.innerHeight : containerEl.clientHeight;
      var points = Object.keys(breakpoints).map(function (point) {
        if (typeof point === 'string' && point.indexOf('@') === 0) {
          var minRatio = parseFloat(point.substr(1));
          var value = currentHeight * minRatio;
          return {
            value: value,
            point: point
          };
        }

        return {
          value: point,
          point: point
        };
      });
      points.sort(function (a, b) {
        return parseInt(a.value, 10) - parseInt(b.value, 10);
      });

      for (var i = 0; i < points.length; i += 1) {
        var _points$i = points[i],
            point = _points$i.point,
            value = _points$i.value;

        if (base === 'window') {
          if (window.matchMedia("(min-width: " + value + "px)").matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }

      return breakpoint || 'max';
    }

    var breakpoints = {
      setBreakpoint: setBreakpoint,
      getBreakpoint: getBreakpoint
    };

    function prepareClasses(entries, prefix) {
      var resultClasses = [];
      entries.forEach(function (item) {
        if (typeof item === 'object') {
          Object.keys(item).forEach(function (classNames) {
            if (item[classNames]) {
              resultClasses.push(prefix + classNames);
            }
          });
        } else if (typeof item === 'string') {
          resultClasses.push(prefix + item);
        }
      });
      return resultClasses;
    }

    function addClasses() {
      var swiper = this;
      var classNames = swiper.classNames,
          params = swiper.params,
          rtl = swiper.rtl,
          $el = swiper.$el,
          device = swiper.device,
          support = swiper.support; // prettier-ignore

      var suffixes = prepareClasses(['initialized', params.direction, {
        'pointer-events': support.pointerEvents && !support.touch
      }, {
        'free-mode': params.freeMode
      }, {
        'autoheight': params.autoHeight
      }, {
        'rtl': rtl
      }, {
        'multirow': params.slidesPerColumn > 1
      }, {
        'multirow-column': params.slidesPerColumn > 1 && params.slidesPerColumnFill === 'column'
      }, {
        'android': device.android
      }, {
        'ios': device.ios
      }, {
        'css-mode': params.cssMode
      }], params.containerModifierClass);
      classNames.push.apply(classNames, suffixes);
      $el.addClass([].concat(classNames).join(' '));
      swiper.emitContainerClasses();
    }

    function removeClasses() {
      var swiper = this;
      var $el = swiper.$el,
          classNames = swiper.classNames;
      $el.removeClass(classNames.join(' '));
      swiper.emitContainerClasses();
    }

    var classes = {
      addClasses: addClasses,
      removeClasses: removeClasses
    };

    function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
      var window = getWindow();
      var image;

      function onReady() {
        if (callback) callback();
      }

      var isPicture = $(imageEl).parent('picture')[0];

      if (!isPicture && (!imageEl.complete || !checkForComplete)) {
        if (src) {
          image = new window.Image();
          image.onload = onReady;
          image.onerror = onReady;

          if (sizes) {
            image.sizes = sizes;
          }

          if (srcset) {
            image.srcset = srcset;
          }

          if (src) {
            image.src = src;
          }
        } else {
          onReady();
        }
      } else {
        // image already loaded...
        onReady();
      }
    }

    function preloadImages() {
      var swiper = this;
      swiper.imagesToLoad = swiper.$el.find('img');

      function onReady() {
        if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
        if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;

        if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
          if (swiper.params.updateOnImagesReady) swiper.update();
          swiper.emit('imagesReady');
        }
      }

      for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
        var imageEl = swiper.imagesToLoad[i];
        swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
      }
    }

    var images = {
      loadImage: loadImage,
      preloadImages: preloadImages
    };

    function checkOverflow() {
      var swiper = this;
      var params = swiper.params;
      var wasLocked = swiper.isLocked;
      var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

      if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
        swiper.isLocked = lastSlidePosition <= swiper.size;
      } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
      }

      swiper.allowSlideNext = !swiper.isLocked;
      swiper.allowSlidePrev = !swiper.isLocked; // events

      if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

      if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
        if (swiper.navigation) swiper.navigation.update();
      }
    }

    var checkOverflow$1 = {
      checkOverflow: checkOverflow
    };

    var defaults = {
      init: true,
      direction: 'horizontal',
      touchEventsTarget: 'container',
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: false,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: 'input, select, option, textarea, button, video, label',
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Free mode
      freeMode: false,
      freeModeMomentum: true,
      freeModeMomentumRatio: 1,
      freeModeMomentumBounce: true,
      freeModeMomentumBounceRatio: 1,
      freeModeMomentumVelocityRatio: 1,
      freeModeSticky: false,
      freeModeMinimumVelocity: 0.02,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: 'slide',
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: undefined,
      breakpointsBase: 'window',
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerColumn: 1,
      slidesPerColumnFill: 'column',
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: false,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 0,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      watchSlidesVisibility: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // Images
      preloadImages: true,
      updateOnImagesReady: true,
      // loop
      loop: false,
      loopAdditionalSlides: 0,
      loopedSlides: null,
      loopFillGroupWithBlank: false,
      loopPreventsSlide: true,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: 'swiper-no-swiping',
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      // NS
      containerModifierClass: 'swiper-container-',
      // NEW
      slideClass: 'swiper-slide',
      slideBlankClass: 'swiper-slide-invisible-blank',
      slideActiveClass: 'swiper-slide-active',
      slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
      slideVisibleClass: 'swiper-slide-visible',
      slideDuplicateClass: 'swiper-slide-duplicate',
      slideNextClass: 'swiper-slide-next',
      slideDuplicateNextClass: 'swiper-slide-duplicate-next',
      slidePrevClass: 'swiper-slide-prev',
      slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
      wrapperClass: 'swiper-wrapper',
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };

    function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }
    var prototypes = {
      modular: modular,
      eventsEmitter: eventsEmitter,
      update: update,
      translate: translate,
      transition: transition,
      slide: slide,
      loop: loop,
      grabCursor: grabCursor,
      manipulation: manipulation,
      events: events,
      breakpoints: breakpoints,
      checkOverflow: checkOverflow$1,
      classes: classes,
      images: images
    };
    var extendedDefaults = {};

    var Swiper$3 = /*#__PURE__*/function () {
      function Swiper() {
        var el;
        var params;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === 'Object') {
          params = args[0];
        } else {
          el = args[0];
          params = args[1];
        }

        if (!params) params = {};
        params = extend$1({}, params);
        if (el && !params.el) params.el = el;

        if (params.el && $(params.el).length > 1) {
          var swipers = [];
          $(params.el).each(function (containerEl) {
            var newParams = extend$1({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper(newParams));
          });
          return swipers;
        } // Swiper Instance


        var swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
          userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];

        if (typeof swiper.modules === 'undefined') {
          swiper.modules = {};
        }

        Object.keys(swiper.modules).forEach(function (moduleName) {
          var module = swiper.modules[moduleName];

          if (module.params) {
            var moduleParamName = Object.keys(module.params)[0];
            var moduleParams = module.params[moduleParamName];
            if (typeof moduleParams !== 'object' || moduleParams === null) return;

            if (['navigation', 'pagination', 'scrollbar'].indexOf(moduleParamName) >= 0 && params[moduleParamName] === true) {
              params[moduleParamName] = {
                auto: true
              };
            }

            if (!(moduleParamName in params && 'enabled' in moduleParams)) return;

            if (params[moduleParamName] === true) {
              params[moduleParamName] = {
                enabled: true
              };
            }

            if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
              params[moduleParamName].enabled = true;
            }

            if (!params[moduleParamName]) params[moduleParamName] = {
              enabled: false
            };
          }
        }); // Extend defaults with modules params

        var swiperParams = extend$1({}, defaults);
        swiper.useParams(swiperParams); // Extend defaults with passed params

        swiper.params = extend$1({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend$1({}, swiper.params);
        swiper.passedParams = extend$1({}, params); // add event listeners

        if (swiper.params && swiper.params.on) {
          Object.keys(swiper.params.on).forEach(function (eventName) {
            swiper.on(eventName, swiper.params.on[eventName]);
          });
        }

        if (swiper.params && swiper.params.onAny) {
          swiper.onAny(swiper.params.onAny);
        } // Save Dom lib


        swiper.$ = $; // Extend Swiper

        extend$1(swiper, {
          enabled: swiper.params.enabled,
          el: el,
          // Classes
          classNames: [],
          // Slides
          slides: $(),
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          // isDirection
          isHorizontal: function isHorizontal() {
            return swiper.params.direction === 'horizontal';
          },
          isVertical: function isVertical() {
            return swiper.params.direction === 'vertical';
          },
          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          // Locks
          allowSlideNext: swiper.params.allowSlideNext,
          allowSlidePrev: swiper.params.allowSlidePrev,
          // Touch Events
          touchEvents: function touchEvents() {
            var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
            var desktop = ['mousedown', 'mousemove', 'mouseup'];

            if (swiper.support.pointerEvents) {
              desktop = ['pointerdown', 'pointermove', 'pointerup'];
            }

            swiper.touchEventsTouch = {
              start: touch[0],
              move: touch[1],
              end: touch[2],
              cancel: touch[3]
            };
            swiper.touchEventsDesktop = {
              start: desktop[0],
              move: desktop[1],
              end: desktop[2]
            };
            return swiper.support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
          }(),
          touchEventsData: {
            isTouched: undefined,
            isMoved: undefined,
            allowTouchCallbacks: undefined,
            touchStartTime: undefined,
            isScrolling: undefined,
            currentTranslate: undefined,
            startTranslate: undefined,
            allowThresholdMove: undefined,
            // Form elements to match
            focusableElements: swiper.params.focusableElements,
            // Last click time
            lastClickTime: now(),
            clickTimeout: undefined,
            // Velocities
            velocities: [],
            allowMomentumBounce: undefined,
            isTouchEvent: undefined,
            startMoving: undefined
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        }); // Install Modules

        swiper.useModules();
        swiper.emit('_swiper'); // Init

        if (swiper.params.init) {
          swiper.init();
        } // Return app instance


        return swiper;
      }

      var _proto = Swiper.prototype;

      _proto.enable = function enable() {
        var swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;

        if (swiper.params.grabCursor) {
          swiper.setGrabCursor();
        }

        swiper.emit('enable');
      };

      _proto.disable = function disable() {
        var swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;

        if (swiper.params.grabCursor) {
          swiper.unsetGrabCursor();
        }

        swiper.emit('disable');
      };

      _proto.setProgress = function setProgress(progress, speed) {
        var swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        var min = swiper.minTranslate();
        var max = swiper.maxTranslate();
        var current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === 'undefined' ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      };

      _proto.emitContainerClasses = function emitContainerClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var classes = swiper.el.className.split(' ').filter(function (className) {
          return className.indexOf('swiper-container') === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit('_containerClasses', classes.join(' '));
      };

      _proto.getSlideClasses = function getSlideClasses(slideEl) {
        var swiper = this;
        return slideEl.className.split(' ').filter(function (className) {
          return className.indexOf('swiper-slide') === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(' ');
      };

      _proto.emitSlidesClasses = function emitSlidesClasses() {
        var swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        var updates = [];
        swiper.slides.each(function (slideEl) {
          var classNames = swiper.getSlideClasses(slideEl);
          updates.push({
            slideEl: slideEl,
            classNames: classNames
          });
          swiper.emit('_slideClass', slideEl, classNames);
        });
        swiper.emit('_slideClasses', updates);
      };

      _proto.slidesPerViewDynamic = function slidesPerViewDynamic() {
        var swiper = this;
        var params = swiper.params,
            slides = swiper.slides,
            slidesGrid = swiper.slidesGrid,
            swiperSize = swiper.size,
            activeIndex = swiper.activeIndex;
        var spv = 1;

        if (params.centeredSlides) {
          var slideSize = slides[activeIndex].swiperSlideSize;
          var breakLoop;

          for (var i = activeIndex + 1; i < slides.length; i += 1) {
            if (slides[i] && !breakLoop) {
              slideSize += slides[i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }

          for (var _i = activeIndex - 1; _i >= 0; _i -= 1) {
            if (slides[_i] && !breakLoop) {
              slideSize += slides[_i].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize) breakLoop = true;
            }
          }
        } else {
          for (var _i2 = activeIndex + 1; _i2 < slides.length; _i2 += 1) {
            if (slidesGrid[_i2] - slidesGrid[activeIndex] < swiperSize) {
              spv += 1;
            }
          }
        }

        return spv;
      };

      _proto.update = function update() {
        var swiper = this;
        if (!swiper || swiper.destroyed) return;
        var snapGrid = swiper.snapGrid,
            params = swiper.params; // Breakpoints

        if (params.breakpoints) {
          swiper.setBreakpoint();
        }

        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        function setTranslate() {
          var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
          var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
          swiper.setTranslate(newTranslate);
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();
        }

        var translated;

        if (swiper.params.freeMode) {
          setTranslate();

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        } else {
          if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
            translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
          } else {
            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
          }

          if (!translated) {
            setTranslate();
          }
        }

        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
          swiper.checkOverflow();
        }

        swiper.emit('update');
      };

      _proto.changeDirection = function changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
          needUpdate = true;
        }

        var swiper = this;
        var currentDirection = swiper.params.direction;

        if (!newDirection) {
          // eslint-disable-next-line
          newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
        }

        if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
          return swiper;
        }

        swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.each(function (slideEl) {
          if (newDirection === 'vertical') {
            slideEl.style.width = '';
          } else {
            slideEl.style.height = '';
          }
        });
        swiper.emit('changeDirection');
        if (needUpdate) swiper.update();
        return swiper;
      };

      _proto.mount = function mount(el) {
        var swiper = this;
        if (swiper.mounted) return true; // Find el

        var $el = $(el || swiper.params.el);
        el = $el[0];

        if (!el) {
          return false;
        }

        el.swiper = swiper;

        var getWrapperSelector = function getWrapperSelector() {
          return "." + (swiper.params.wrapperClass || '').trim().split(' ').join('.');
        };

        var getWrapper = function getWrapper() {
          if (el && el.shadowRoot && el.shadowRoot.querySelector) {
            var res = $(el.shadowRoot.querySelector(getWrapperSelector())); // Children needs to return slot items

            res.children = function (options) {
              return $el.children(options);
            };

            return res;
          }

          return $el.children(getWrapperSelector());
        }; // Find Wrapper


        var $wrapperEl = getWrapper();

        if ($wrapperEl.length === 0 && swiper.params.createElements) {
          var document = getDocument();
          var wrapper = document.createElement('div');
          $wrapperEl = $(wrapper);
          wrapper.className = swiper.params.wrapperClass;
          $el.append(wrapper);
          $el.children("." + swiper.params.slideClass).each(function (slideEl) {
            $wrapperEl.append(slideEl);
          });
        }

        extend$1(swiper, {
          $el: $el,
          el: el,
          $wrapperEl: $wrapperEl,
          wrapperEl: $wrapperEl[0],
          mounted: true,
          // RTL
          rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
          rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
          wrongRTL: $wrapperEl.css('display') === '-webkit-box'
        });
        return true;
      };

      _proto.init = function init(el) {
        var swiper = this;
        if (swiper.initialized) return swiper;
        var mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit('beforeInit'); // Set breakpoint

        if (swiper.params.breakpoints) {
          swiper.setBreakpoint();
        } // Add Classes


        swiper.addClasses(); // Create loop

        if (swiper.params.loop) {
          swiper.loopCreate();
        } // Update size


        swiper.updateSize(); // Update slides

        swiper.updateSlides();

        if (swiper.params.watchOverflow) {
          swiper.checkOverflow();
        } // Set Grab Cursor


        if (swiper.params.grabCursor && swiper.enabled) {
          swiper.setGrabCursor();
        }

        if (swiper.params.preloadImages) {
          swiper.preloadImages();
        } // Slide To Initial Slide


        if (swiper.params.loop) {
          swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
          swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        } // Attach events


        swiper.attachEvents(); // Init Flag

        swiper.initialized = true; // Emit

        swiper.emit('init');
        swiper.emit('afterInit');
        return swiper;
      };

      _proto.destroy = function destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
          deleteInstance = true;
        }

        if (cleanStyles === void 0) {
          cleanStyles = true;
        }

        var swiper = this;
        var params = swiper.params,
            $el = swiper.$el,
            $wrapperEl = swiper.$wrapperEl,
            slides = swiper.slides;

        if (typeof swiper.params === 'undefined' || swiper.destroyed) {
          return null;
        }

        swiper.emit('beforeDestroy'); // Init Flag

        swiper.initialized = false; // Detach events

        swiper.detachEvents(); // Destroy loop

        if (params.loop) {
          swiper.loopDestroy();
        } // Cleanup styles


        if (cleanStyles) {
          swiper.removeClasses();
          $el.removeAttr('style');
          $wrapperEl.removeAttr('style');

          if (slides && slides.length) {
            slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
          }
        }

        swiper.emit('destroy'); // Detach emitter events

        Object.keys(swiper.eventsListeners).forEach(function (eventName) {
          swiper.off(eventName);
        });

        if (deleteInstance !== false) {
          swiper.$el[0].swiper = null;
          deleteProps(swiper);
        }

        swiper.destroyed = true;
        return null;
      };

      Swiper.extendDefaults = function extendDefaults(newDefaults) {
        extend$1(extendedDefaults, newDefaults);
      };

      Swiper.installModule = function installModule(module) {
        if (!Swiper.prototype.modules) Swiper.prototype.modules = {};
        var name = module.name || Object.keys(Swiper.prototype.modules).length + "_" + now();
        Swiper.prototype.modules[name] = module;
      };

      Swiper.use = function use(module) {
        if (Array.isArray(module)) {
          module.forEach(function (m) {
            return Swiper.installModule(m);
          });
          return Swiper;
        }

        Swiper.installModule(module);
        return Swiper;
      };

      _createClass$1(Swiper, null, [{
        key: "extendedDefaults",
        get: function get() {
          return extendedDefaults;
        }
      }, {
        key: "defaults",
        get: function get() {
          return defaults;
        }
      }]);

      return Swiper;
    }();

    Object.keys(prototypes).forEach(function (prototypeGroup) {
      Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
        Swiper$3.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper$3.use([Resize, Observer$1]);
    var SwiperCore = Swiper$3;

    function _extends$2() { _extends$2 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$2.apply(this, arguments); }
    var Pagination$1 = {
      update: function update() {
        // Render || Update Pagination bullets/items
        var swiper = this;
        var rtl = swiper.rtl;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el; // Current/Total

        var current;
        var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        if (swiper.params.loop) {
          current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

          if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
            current -= slidesLength - swiper.loopedSlides * 2;
          }

          if (current > total - 1) current -= total;
          if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
        } else if (typeof swiper.snapIndex !== 'undefined') {
          current = swiper.snapIndex;
        } else {
          current = swiper.activeIndex || 0;
        } // Types


        if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
          var bullets = swiper.pagination.bullets;
          var firstIndex;
          var lastIndex;
          var midIndex;

          if (params.dynamicBullets) {
            swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
            $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

            if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
              swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

              if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
                swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (swiper.pagination.dynamicBulletIndex < 0) {
                swiper.pagination.dynamicBulletIndex = 0;
              }
            }

            firstIndex = current - swiper.pagination.dynamicBulletIndex;
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }

          bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

          if ($el.length > 1) {
            bullets.each(function (bullet) {
              var $bullet = $(bullet);
              var bulletIndex = $bullet.index();

              if (bulletIndex === current) {
                $bullet.addClass(params.bulletActiveClass);
              }

              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  $bullet.addClass(params.bulletActiveClass + "-main");
                }

                if (bulletIndex === firstIndex) {
                  $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                }

                if (bulletIndex === lastIndex) {
                  $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                }
              }
            });
          } else {
            var $bullet = bullets.eq(current);
            var bulletIndex = $bullet.index();
            $bullet.addClass(params.bulletActiveClass);

            if (params.dynamicBullets) {
              var $firstDisplayedBullet = bullets.eq(firstIndex);
              var $lastDisplayedBullet = bullets.eq(lastIndex);

              for (var i = firstIndex; i <= lastIndex; i += 1) {
                bullets.eq(i).addClass(params.bulletActiveClass + "-main");
              }

              if (swiper.params.loop) {
                if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                  for (var _i = params.dynamicMainBullets; _i >= 0; _i -= 1) {
                    bullets.eq(bullets.length - _i).addClass(params.bulletActiveClass + "-main");
                  }

                  bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
                } else {
                  $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                  $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
                }
              } else {
                $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
              }
            }
          }

          if (params.dynamicBullets) {
            var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
            var offsetProp = rtl ? 'right' : 'left';
            bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
          }
        }

        if (params.type === 'fraction') {
          $el.find(classesToSelector(params.currentClass)).text(params.formatFractionCurrent(current + 1));
          $el.find(classesToSelector(params.totalClass)).text(params.formatFractionTotal(total));
        }

        if (params.type === 'progressbar') {
          var progressbarDirection;

          if (params.progressbarOpposite) {
            progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
          } else {
            progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
          }

          var scale = (current + 1) / total;
          var scaleX = 1;
          var scaleY = 1;

          if (progressbarDirection === 'horizontal') {
            scaleX = scale;
          } else {
            scaleY = scale;
          }

          $el.find(classesToSelector(params.progressbarFillClass)).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
        }

        if (params.type === 'custom' && params.renderCustom) {
          $el.html(params.renderCustom(swiper, current + 1, total));
          swiper.emit('paginationRender', $el[0]);
        } else {
          swiper.emit('paginationUpdate', $el[0]);
        }

        if (swiper.params.watchOverflow && swiper.enabled) {
          $el[swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
        }
      },
      render: function render() {
        // Render Container
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        var $el = swiper.pagination.$el;
        var paginationHTML = '';

        if (params.type === 'bullets') {
          var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

          if (swiper.params.freeMode && !swiper.params.loop && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }

          for (var i = 0; i < numberOfBullets; i += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
            } else {
              paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
            }
          }

          $el.html(paginationHTML);
          swiper.pagination.bullets = $el.find(classesToSelector(params.bulletClass));
        }

        if (params.type === 'fraction') {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
          } else {
            paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + ("<span class=\"" + params.totalClass + "\"></span>");
          }

          $el.html(paginationHTML);
        }

        if (params.type === 'progressbar') {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
          } else {
            paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
          }

          $el.html(paginationHTML);
        }

        if (params.type !== 'custom') {
          swiper.emit('paginationRender', swiper.pagination.$el[0]);
        }
      },
      init: function init() {
        var swiper = this;
        swiper.params.pagination = createElementIfNotDefined(swiper.$el, swiper.params.pagination, swiper.params.createElements, {
          el: 'swiper-pagination'
        });
        var params = swiper.params.pagination;
        if (!params.el) return;
        var $el = $(params.el);
        if ($el.length === 0) return;

        if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1) {
          $el = swiper.$el.find(params.el);
        }

        if (params.type === 'bullets' && params.clickable) {
          $el.addClass(params.clickableClass);
        }

        $el.addClass(params.modifierClass + params.type);

        if (params.type === 'bullets' && params.dynamicBullets) {
          $el.addClass("" + params.modifierClass + params.type + "-dynamic");
          swiper.pagination.dynamicBulletIndex = 0;

          if (params.dynamicMainBullets < 1) {
            params.dynamicMainBullets = 1;
          }
        }

        if (params.type === 'progressbar' && params.progressbarOpposite) {
          $el.addClass(params.progressbarOppositeClass);
        }

        if (params.clickable) {
          $el.on('click', classesToSelector(params.bulletClass), function onClick(e) {
            e.preventDefault();
            var index = $(this).index() * swiper.params.slidesPerGroup;
            if (swiper.params.loop) index += swiper.loopedSlides;
            swiper.slideTo(index);
          });
        }

        extend$1(swiper.pagination, {
          $el: $el,
          el: $el[0]
        });

        if (!swiper.enabled) {
          $el.addClass(params.lockClass);
        }
      },
      destroy: function destroy() {
        var swiper = this;
        var params = swiper.params.pagination;
        if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
        var $el = swiper.pagination.$el;
        $el.removeClass(params.hiddenClass);
        $el.removeClass(params.modifierClass + params.type);
        if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);

        if (params.clickable) {
          $el.off('click', classesToSelector(params.bulletClass));
        }
      }
    };
    var Pagination$2 = {
      name: 'pagination',
      params: {
        pagination: {
          el: null,
          bulletElement: 'span',
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: 'bullets',
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: function formatFractionCurrent(number) {
            return number;
          },
          formatFractionTotal: function formatFractionTotal(number) {
            return number;
          },
          bulletClass: 'swiper-pagination-bullet',
          bulletActiveClass: 'swiper-pagination-bullet-active',
          modifierClass: 'swiper-pagination-',
          // NEW
          currentClass: 'swiper-pagination-current',
          totalClass: 'swiper-pagination-total',
          hiddenClass: 'swiper-pagination-hidden',
          progressbarFillClass: 'swiper-pagination-progressbar-fill',
          progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
          clickableClass: 'swiper-pagination-clickable',
          // NEW
          lockClass: 'swiper-pagination-lock'
        }
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          pagination: _extends$2({
            dynamicBulletIndex: 0
          }, Pagination$1)
        });
      },
      on: {
        init: function init(swiper) {
          swiper.pagination.init();
          swiper.pagination.render();
          swiper.pagination.update();
        },
        activeIndexChange: function activeIndexChange(swiper) {
          if (swiper.params.loop) {
            swiper.pagination.update();
          } else if (typeof swiper.snapIndex === 'undefined') {
            swiper.pagination.update();
          }
        },
        snapIndexChange: function snapIndexChange(swiper) {
          if (!swiper.params.loop) {
            swiper.pagination.update();
          }
        },
        slidesLengthChange: function slidesLengthChange(swiper) {
          if (swiper.params.loop) {
            swiper.pagination.render();
            swiper.pagination.update();
          }
        },
        snapGridLengthChange: function snapGridLengthChange(swiper) {
          if (!swiper.params.loop) {
            swiper.pagination.render();
            swiper.pagination.update();
          }
        },
        destroy: function destroy(swiper) {
          swiper.pagination.destroy();
        },
        'enable disable': function enableDisable(swiper) {
          var $el = swiper.pagination.$el;

          if ($el) {
            $el[swiper.enabled ? 'removeClass' : 'addClass'](swiper.params.pagination.lockClass);
          }
        },
        click: function click(swiper, e) {
          var targetEl = e.target;

          if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(targetEl).hasClass(swiper.params.pagination.bulletClass)) {
            if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
            var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

            if (isHidden === true) {
              swiper.emit('paginationShow');
            } else {
              swiper.emit('paginationHide');
            }

            swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
          }
        }
      }
    };

    function _extends$1() { _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends$1.apply(this, arguments); }
    var Controller$1 = {
      LinearSpline: function LinearSpline(x, y) {
        var binarySearch = function search() {
          var maxIndex;
          var minIndex;
          var guess;
          return function (array, val) {
            minIndex = -1;
            maxIndex = array.length;

            while (maxIndex - minIndex > 1) {
              guess = maxIndex + minIndex >> 1;

              if (array[guess] <= val) {
                minIndex = guess;
              } else {
                maxIndex = guess;
              }
            }

            return maxIndex;
          };
        }();

        this.x = x;
        this.y = y;
        this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
        // (x1,y1) is the known point before given value,
        // (x3,y3) is the known point after given value.

        var i1;
        var i3;

        this.interpolate = function interpolate(x2) {
          if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):

          i3 = binarySearch(this.x, x2);
          i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
          // y2 := ((x2x1)  (y3y1))  (x3x1) + y1

          return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
        };

        return this;
      },
      // xxx: for now i will just save one spline function to to
      getInterpolateFunction: function getInterpolateFunction(c) {
        var swiper = this;

        if (!swiper.controller.spline) {
          swiper.controller.spline = swiper.params.loop ? new Controller$1.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller$1.LinearSpline(swiper.snapGrid, c.snapGrid);
        }
      },
      setTranslate: function setTranslate(_setTranslate, byController) {
        var swiper = this;
        var controlled = swiper.controller.control;
        var multiplier;
        var controlledTranslate;
        var Swiper = swiper.constructor;

        function setControlledTranslate(c) {
          // this will create an Interpolate function based on the snapGrids
          // x is the Grid of the scrolled scroller and y will be the controlled scroller
          // it makes sense to create this only once and recall it for the interpolation
          // the function does a lot of value caching for performance
          var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

          if (swiper.params.controller.by === 'slide') {
            swiper.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
            // but it did not work out

            controlledTranslate = -swiper.controller.spline.interpolate(-translate);
          }

          if (!controlledTranslate || swiper.params.controller.by === 'container') {
            multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
            controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
          }

          if (swiper.params.controller.inverse) {
            controlledTranslate = c.maxTranslate() - controlledTranslate;
          }

          c.updateProgress(controlledTranslate);
          c.setTranslate(controlledTranslate, swiper);
          c.updateActiveIndex();
          c.updateSlidesClasses();
        }

        if (Array.isArray(controlled)) {
          for (var i = 0; i < controlled.length; i += 1) {
            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
              setControlledTranslate(controlled[i]);
            }
          }
        } else if (controlled instanceof Swiper && byController !== controlled) {
          setControlledTranslate(controlled);
        }
      },
      setTransition: function setTransition(duration, byController) {
        var swiper = this;
        var Swiper = swiper.constructor;
        var controlled = swiper.controller.control;
        var i;

        function setControlledTransition(c) {
          c.setTransition(duration, swiper);

          if (duration !== 0) {
            c.transitionStart();

            if (c.params.autoHeight) {
              nextTick$1(function () {
                c.updateAutoHeight();
              });
            }

            c.$wrapperEl.transitionEnd(function () {
              if (!controlled) return;

              if (c.params.loop && swiper.params.controller.by === 'slide') {
                c.loopFix();
              }

              c.transitionEnd();
            });
          }
        }

        if (Array.isArray(controlled)) {
          for (i = 0; i < controlled.length; i += 1) {
            if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
              setControlledTransition(controlled[i]);
            }
          }
        } else if (controlled instanceof Swiper && byController !== controlled) {
          setControlledTransition(controlled);
        }
      }
    };
    var Controller$2 = {
      name: 'controller',
      params: {
        controller: {
          control: undefined,
          inverse: false,
          by: 'slide' // or 'container'

        }
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          controller: _extends$1({
            control: swiper.params.controller.control
          }, Controller$1)
        });
      },
      on: {
        update: function update(swiper) {
          if (!swiper.controller.control) return;

          if (swiper.controller.spline) {
            swiper.controller.spline = undefined;
            delete swiper.controller.spline;
          }
        },
        resize: function resize(swiper) {
          if (!swiper.controller.control) return;

          if (swiper.controller.spline) {
            swiper.controller.spline = undefined;
            delete swiper.controller.spline;
          }
        },
        observerUpdate: function observerUpdate(swiper) {
          if (!swiper.controller.control) return;

          if (swiper.controller.spline) {
            swiper.controller.spline = undefined;
            delete swiper.controller.spline;
          }
        },
        setTranslate: function setTranslate(swiper, translate, byController) {
          if (!swiper.controller.control) return;
          swiper.controller.setTranslate(translate, byController);
        },
        setTransition: function setTransition(swiper, duration, byController) {
          if (!swiper.controller.control) return;
          swiper.controller.setTransition(duration, byController);
        }
      }
    };

    function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }
    var Fade$1 = {
      setTranslate: function setTranslate() {
        var swiper = this;
        var slides = swiper.slides;

        for (var i = 0; i < slides.length; i += 1) {
          var $slideEl = swiper.slides.eq(i);
          var offset = $slideEl[0].swiperSlideOffset;
          var tx = -offset;
          if (!swiper.params.virtualTranslate) tx -= swiper.translate;
          var ty = 0;

          if (!swiper.isHorizontal()) {
            ty = tx;
            tx = 0;
          }

          var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
          $slideEl.css({
            opacity: slideOpacity
          }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
        }
      },
      setTransition: function setTransition(duration) {
        var swiper = this;
        var slides = swiper.slides,
            $wrapperEl = swiper.$wrapperEl;
        slides.transition(duration);

        if (swiper.params.virtualTranslate && duration !== 0) {
          var eventTriggered = false;
          slides.transitionEnd(function () {
            if (eventTriggered) return;
            if (!swiper || swiper.destroyed) return;
            eventTriggered = true;
            swiper.animating = false;
            var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

            for (var i = 0; i < triggerEvents.length; i += 1) {
              $wrapperEl.trigger(triggerEvents[i]);
            }
          });
        }
      }
    };
    var EffectFade = {
      name: 'effect-fade',
      params: {
        fadeEffect: {
          crossFade: false
        }
      },
      create: function create() {
        var swiper = this;
        bindModuleMethods(swiper, {
          fadeEffect: _extends({}, Fade$1)
        });
      },
      on: {
        beforeInit: function beforeInit(swiper) {
          if (swiper.params.effect !== 'fade') return;
          swiper.classNames.push(swiper.params.containerModifierClass + "fade");
          var overwriteParams = {
            slidesPerView: 1,
            slidesPerColumn: 1,
            slidesPerGroup: 1,
            watchSlidesProgress: true,
            spaceBetween: 0,
            virtualTranslate: true
          };
          extend$1(swiper.params, overwriteParams);
          extend$1(swiper.originalParams, overwriteParams);
        },
        setTranslate: function setTranslate(swiper) {
          if (swiper.params.effect !== 'fade') return;
          swiper.fadeEffect.setTranslate();
        },
        setTransition: function setTransition(swiper, duration) {
          if (swiper.params.effect !== 'fade') return;
          swiper.fadeEffect.setTransition(duration);
        }
      }
    };

    function isObject$2(o) {
      return typeof o === 'object' && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === 'Object';
    }

    function extend(target, src) {
      var noExtend = ['__proto__', 'constructor', 'prototype'];
      Object.keys(src).filter(function (key) {
        return noExtend.indexOf(key) < 0;
      }).forEach(function (key) {
        if (typeof target[key] === 'undefined') target[key] = src[key];else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
          if (src[key].__swiper__) target[key] = src[key];else extend(target[key], src[key]);
        } else {
          target[key] = src[key];
        }
      });
    }

    function needsNavigation(params) {
      if (params === void 0) {
        params = {};
      }

      return params.navigation && typeof params.navigation.nextEl === 'undefined' && typeof params.navigation.prevEl === 'undefined';
    }

    function needsPagination(params) {
      if (params === void 0) {
        params = {};
      }

      return params.pagination && typeof params.pagination.el === 'undefined';
    }

    function needsScrollbar(params) {
      if (params === void 0) {
        params = {};
      }

      return params.scrollbar && typeof params.scrollbar.el === 'undefined';
    }

    function uniqueClasses(classNames) {
      if (classNames === void 0) {
        classNames = '';
      }

      var classes = classNames.split(' ').map(function (c) {
        return c.trim();
      }).filter(function (c) {
        return !!c;
      });
      var unique = [];
      classes.forEach(function (c) {
        if (unique.indexOf(c) < 0) unique.push(c);
      });
      return unique.join(' ');
    }

    /* underscore in name -> watch for changes */
    var paramsList = ['init', '_direction', 'touchEventsTarget', 'initialSlide', '_speed', 'cssMode', 'updateOnWindowResize', 'resizeObserver', 'nested', 'focusableElements', '_enabled', '_width', '_height', 'preventInteractionOnTransition', 'userAgent', 'url', '_edgeSwipeDetection', '_edgeSwipeThreshold', '_freeMode', '_freeModeMomentum', '_freeModeMomentumRatio', '_freeModeMomentumBounce', '_freeModeMomentumBounceRatio', '_freeModeMomentumVelocityRatio', '_freeModeSticky', '_freeModeMinimumVelocity', '_autoHeight', 'setWrapperSize', 'virtualTranslate', '_effect', 'breakpoints', '_spaceBetween', '_slidesPerView', '_slidesPerColumn', '_slidesPerColumnFill', '_slidesPerGroup', '_slidesPerGroupSkip', '_centeredSlides', '_centeredSlidesBounds', '_slidesOffsetBefore', '_slidesOffsetAfter', 'normalizeSlideIndex', '_centerInsufficientSlides', '_watchOverflow', 'roundLengths', 'touchRatio', 'touchAngle', 'simulateTouch', '_shortSwipes', '_longSwipes', 'longSwipesRatio', 'longSwipesMs', '_followFinger', 'allowTouchMove', '_threshold', 'touchMoveStopPropagation', 'touchStartPreventDefault', 'touchStartForcePreventDefault', 'touchReleaseOnEdges', 'uniqueNavElements', '_resistance', '_resistanceRatio', '_watchSlidesProgress', '_watchSlidesVisibility', '_grabCursor', 'preventClicks', 'preventClicksPropagation', '_slideToClickedSlide', '_preloadImages', 'updateOnImagesReady', '_loop', '_loopAdditionalSlides', '_loopedSlides', '_loopFillGroupWithBlank', 'loopPreventsSlide', '_allowSlidePrev', '_allowSlideNext', '_swipeHandler', '_noSwiping', 'noSwipingClass', 'noSwipingSelector', 'passiveListeners', 'containerModifierClass', 'slideClass', 'slideBlankClass', 'slideActiveClass', 'slideDuplicateActiveClass', 'slideVisibleClass', 'slideDuplicateClass', 'slideNextClass', 'slideDuplicateNextClass', 'slidePrevClass', 'slideDuplicatePrevClass', 'wrapperClass', 'runCallbacksOnInit', 'observer', 'observeParents', 'observeSlideChildren', // modules
    'a11y', 'autoplay', '_controller', 'coverflowEffect', 'cubeEffect', 'fadeEffect', 'flipEffect', 'hashNavigation', 'history', 'keyboard', 'lazy', 'mousewheel', '_navigation', '_pagination', 'parallax', '_scrollbar', '_thumbs', '_virtual', 'zoom'];

    // eslint-disable-next-line

    function getParams(obj) {
      if (obj === void 0) {
        obj = {};
      }

      var params = {
        on: {}
      };
      var passedParams = {};
      extend(params, SwiperCore.defaults);
      extend(params, SwiperCore.extendedDefaults);
      params._emitClasses = true;
      params.init = false;
      var rest = {};
      var allowedParams = paramsList.map(function (key) {
        return key.replace(/_/, '');
      });
      Object.keys(obj).forEach(function (key) {
        if (allowedParams.indexOf(key) >= 0) {
          if (isObject$2(obj[key])) {
            params[key] = {};
            passedParams[key] = {};
            extend(params[key], obj[key]);
            extend(passedParams[key], obj[key]);
          } else {
            params[key] = obj[key];
            passedParams[key] = obj[key];
          }
        } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === 'function') {
          params.on["" + key[2].toLowerCase() + key.substr(3)] = obj[key];
        } else {
          rest[key] = obj[key];
        }
      });
      ['navigation', 'pagination', 'scrollbar'].forEach(function (key) {
        if (params[key] === true) params[key] = {};
        if (params[key] === false) delete params[key];
      });
      return {
        params: params,
        passedParams: passedParams,
        rest: rest
      };
    }

    // eslint-disable-next-line

    function initSwiper(swiperParams, modules) {
      if (modules) SwiperCore.use(modules);
      return new SwiperCore(swiperParams);
    }

    function mountSwiper(_ref, swiperParams) {
      var el = _ref.el,
          nextEl = _ref.nextEl,
          prevEl = _ref.prevEl,
          paginationEl = _ref.paginationEl,
          scrollbarEl = _ref.scrollbarEl,
          swiper = _ref.swiper;

      if (needsNavigation(swiperParams) && nextEl && prevEl) {
        swiper.params.navigation.nextEl = nextEl;
        swiper.originalParams.navigation.nextEl = nextEl;
        swiper.params.navigation.prevEl = prevEl;
        swiper.originalParams.navigation.prevEl = prevEl;
      }

      if (needsPagination(swiperParams) && paginationEl) {
        swiper.params.pagination.el = paginationEl;
        swiper.originalParams.pagination.el = paginationEl;
      }

      if (needsScrollbar(swiperParams) && scrollbarEl) {
        swiper.params.scrollbar.el = scrollbarEl;
        swiper.originalParams.scrollbar.el = scrollbarEl;
      }

      swiper.init(el);
    }

    function getChangedParams(swiperParams, oldParams) {
      var keys = [];
      if (!oldParams) return keys;

      var addKey = function addKey(key) {
        if (keys.indexOf(key) < 0) keys.push(key);
      };

      var watchParams = paramsList.filter(function (key) {
        return key[0] === '_';
      }).map(function (key) {
        return key.replace(/_/, '');
      });
      watchParams.forEach(function (key) {
        if (key in swiperParams && key in oldParams) {
          if (isObject$2(swiperParams[key]) && isObject$2(oldParams[key])) {
            var newKeys = Object.keys(swiperParams[key]);
            var oldKeys = Object.keys(oldParams[key]);

            if (newKeys.length !== oldKeys.length) {
              addKey(key);
            } else {
              newKeys.forEach(function (newKey) {
                if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
                  addKey(key);
                }
              });
              oldKeys.forEach(function (oldKey) {
                if (swiperParams[key][oldKey] !== oldParams[key][oldKey]) addKey(key);
              });
            }
          } else if (swiperParams[key] !== oldParams[key]) {
            addKey(key);
          }
        }
      });
      return keys;
    }

    function updateSwiper(_ref) {
      var swiper = _ref.swiper,
          passedParams = _ref.passedParams,
          changedParams = _ref.changedParams,
          nextEl = _ref.nextEl,
          prevEl = _ref.prevEl,
          scrollbarEl = _ref.scrollbarEl,
          paginationEl = _ref.paginationEl;
      var updateParams = changedParams.filter(function (key) {
        return key !== 'children' && key !== 'direction';
      });
      var currentParams = swiper.params,
          pagination = swiper.pagination,
          navigation = swiper.navigation,
          scrollbar = swiper.scrollbar,
          thumbs = swiper.thumbs;
      var needThumbsInit;
      var needControllerInit;
      var needPaginationInit;
      var needScrollbarInit;
      var needNavigationInit;

      if (changedParams.includes('thumbs') && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
        needThumbsInit = true;
      }

      if (changedParams.includes('controller') && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
        needControllerInit = true;
      }

      if (changedParams.includes('pagination') && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
        needPaginationInit = true;
      }

      if (changedParams.includes('scrollbar') && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
        needScrollbarInit = true;
      }

      if (changedParams.includes('navigation') && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
        needNavigationInit = true;
      }

      if (changedParams.includes('virtual')) {
        if (passedParams.virtual && passedParams.virtual.slides && swiper.virtual) {
          swiper.virtual.slides = passedParams.virtual.slides;
          swiper.virtual.update();
        }
      }

      var destroyModule = function destroyModule(mod) {
        if (!swiper[mod]) return;
        swiper[mod].destroy();

        if (mod === 'navigation') {
          currentParams[mod].prevEl = undefined;
          currentParams[mod].nextEl = undefined;
          swiper[mod].prevEl = undefined;
          swiper[mod].nextEl = undefined;
        } else {
          currentParams[mod].el = undefined;
          swiper[mod].el = undefined;
        }
      };

      updateParams.forEach(function (key) {
        if (isObject$2(currentParams[key]) && isObject$2(passedParams[key])) {
          extend(currentParams[key], passedParams[key]);
        } else {
          var newValue = passedParams[key];

          if ((newValue === true || newValue === false) && (key === 'navigation' || key === 'pagination' || key === 'scrollbar')) {
            if (newValue === false) {
              destroyModule(key);
            }
          } else {
            currentParams[key] = passedParams[key];
          }
        }
      });

      if (needThumbsInit) {
        var initialized = thumbs.init();

        if (initialized) {
          thumbs.update(true);
        }
      }

      if (needControllerInit) {
        swiper.controller.control = currentParams.controller.control;
      }

      if (needPaginationInit) {
        if (paginationEl) currentParams.pagination.el = paginationEl;
        pagination.init();
        pagination.render();
        pagination.update();
      }

      if (needScrollbarInit) {
        if (scrollbarEl) currentParams.scrollbar.el = scrollbarEl;
        scrollbar.init();
        scrollbar.updateSize();
        scrollbar.setTranslate();
      }

      if (needNavigationInit) {
        if (nextEl) currentParams.navigation.nextEl = nextEl;
        if (prevEl) currentParams.navigation.prevEl = prevEl;
        navigation.init();
        navigation.update();
      }

      if (changedParams.includes('allowSlideNext')) {
        swiper.allowSlideNext = passedParams.allowSlideNext;
      }

      if (changedParams.includes('allowSlidePrev')) {
        swiper.allowSlidePrev = passedParams.allowSlidePrev;
      }

      if (changedParams.includes('direction')) {
        swiper.changeDirection(passedParams.direction, false);
      }

      swiper.update();
    }

    /* swiper.svelte generated by Svelte v3.38.2 */
    const get_container_end_slot_changes = dirty => ({ virtualData: dirty & /*virtualData*/ 512 });
    const get_container_end_slot_context = ctx => ({ virtualData: /*virtualData*/ ctx[9] });
    const get_wrapper_end_slot_changes = dirty => ({ virtualData: dirty & /*virtualData*/ 512 });
    const get_wrapper_end_slot_context = ctx => ({ virtualData: /*virtualData*/ ctx[9] });
    const get_default_slot_changes$2 = dirty => ({ virtualData: dirty & /*virtualData*/ 512 });
    const get_default_slot_context$2 = ctx => ({ virtualData: /*virtualData*/ ctx[9] });
    const get_wrapper_start_slot_changes = dirty => ({ virtualData: dirty & /*virtualData*/ 512 });
    const get_wrapper_start_slot_context = ctx => ({ virtualData: /*virtualData*/ ctx[9] });
    const get_container_start_slot_changes = dirty => ({ virtualData: dirty & /*virtualData*/ 512 });
    const get_container_start_slot_context = ctx => ({ virtualData: /*virtualData*/ ctx[9] });

    // (156:2) {#if needsNavigation(swiperParams)}
    function create_if_block_2$3(ctx) {
    	let div0;
    	let t;
    	let div1;

    	return {
    		c() {
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr$1(div0, "class", "swiper-button-prev");
    			attr$1(div1, "class", "swiper-button-next");
    		},
    		m(target, anchor) {
    			insert(target, div0, anchor);
    			/*div0_binding*/ ctx[14](div0);
    			insert(target, t, anchor);
    			insert(target, div1, anchor);
    			/*div1_binding*/ ctx[15](div1);
    		},
    		p: noop$1,
    		d(detaching) {
    			if (detaching) detach(div0);
    			/*div0_binding*/ ctx[14](null);
    			if (detaching) detach(t);
    			if (detaching) detach(div1);
    			/*div1_binding*/ ctx[15](null);
    		}
    	};
    }

    // (160:2) {#if needsScrollbar(swiperParams)}
    function create_if_block_1$3(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			attr$1(div, "class", "swiper-scrollbar");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			/*div_binding*/ ctx[16](div);
    		},
    		p: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    			/*div_binding*/ ctx[16](null);
    		}
    	};
    }

    // (163:2) {#if needsPagination(swiperParams)}
    function create_if_block$9(ctx) {
    	let div;

    	return {
    		c() {
    			div = element("div");
    			attr$1(div, "class", "swiper-pagination");
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			/*div_binding_1*/ ctx[17](div);
    		},
    		p: noop$1,
    		d(detaching) {
    			if (detaching) detach(div);
    			/*div_binding_1*/ ctx[17](null);
    		}
    	};
    }

    function create_fragment$i(ctx) {
    	let div1;
    	let t0;
    	let show_if_2 = needsNavigation(/*swiperParams*/ ctx[2]);
    	let t1;
    	let show_if_1 = needsScrollbar(/*swiperParams*/ ctx[2]);
    	let t2;
    	let show_if = needsPagination(/*swiperParams*/ ctx[2]);
    	let t3;
    	let div0;
    	let t4;
    	let t5;
    	let t6;
    	let div1_class_value;
    	let current;
    	const container_start_slot_template = /*#slots*/ ctx[13]["container-start"];
    	const container_start_slot = create_slot(container_start_slot_template, ctx, /*$$scope*/ ctx[12], get_container_start_slot_context);
    	let if_block0 = show_if_2 && create_if_block_2$3(ctx);
    	let if_block1 = show_if_1 && create_if_block_1$3(ctx);
    	let if_block2 = show_if && create_if_block$9(ctx);
    	const wrapper_start_slot_template = /*#slots*/ ctx[13]["wrapper-start"];
    	const wrapper_start_slot = create_slot(wrapper_start_slot_template, ctx, /*$$scope*/ ctx[12], get_wrapper_start_slot_context);
    	const default_slot_template = /*#slots*/ ctx[13].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context$2);
    	const wrapper_end_slot_template = /*#slots*/ ctx[13]["wrapper-end"];
    	const wrapper_end_slot = create_slot(wrapper_end_slot_template, ctx, /*$$scope*/ ctx[12], get_wrapper_end_slot_context);
    	const container_end_slot_template = /*#slots*/ ctx[13]["container-end"];
    	const container_end_slot = create_slot(container_end_slot_template, ctx, /*$$scope*/ ctx[12], get_container_end_slot_context);

    	let div1_levels = [
    		{
    			class: div1_class_value = uniqueClasses(`${/*containerClasses*/ ctx[1]}${/*className*/ ctx[0] ? ` ${/*className*/ ctx[0]}` : ""}`)
    		},
    		/*restProps*/ ctx[3]
    	];

    	let div1_data = {};

    	for (let i = 0; i < div1_levels.length; i += 1) {
    		div1_data = assign$1(div1_data, div1_levels[i]);
    	}

    	return {
    		c() {
    			div1 = element("div");
    			if (container_start_slot) container_start_slot.c();
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div0 = element("div");
    			if (wrapper_start_slot) wrapper_start_slot.c();
    			t4 = space();
    			if (default_slot) default_slot.c();
    			t5 = space();
    			if (wrapper_end_slot) wrapper_end_slot.c();
    			t6 = space();
    			if (container_end_slot) container_end_slot.c();
    			attr$1(div0, "class", "swiper-wrapper");
    			set_attributes(div1, div1_data);
    		},
    		m(target, anchor) {
    			insert(target, div1, anchor);

    			if (container_start_slot) {
    				container_start_slot.m(div1, null);
    			}

    			append$2(div1, t0);
    			if (if_block0) if_block0.m(div1, null);
    			append$2(div1, t1);
    			if (if_block1) if_block1.m(div1, null);
    			append$2(div1, t2);
    			if (if_block2) if_block2.m(div1, null);
    			append$2(div1, t3);
    			append$2(div1, div0);

    			if (wrapper_start_slot) {
    				wrapper_start_slot.m(div0, null);
    			}

    			append$2(div0, t4);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			append$2(div0, t5);

    			if (wrapper_end_slot) {
    				wrapper_end_slot.m(div0, null);
    			}

    			append$2(div1, t6);

    			if (container_end_slot) {
    				container_end_slot.m(div1, null);
    			}

    			/*div1_binding_1*/ ctx[18](div1);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			if (container_start_slot) {
    				if (container_start_slot.p && (!current || dirty & /*$$scope, virtualData*/ 4608)) {
    					update_slot(container_start_slot, container_start_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_container_start_slot_changes, get_container_start_slot_context);
    				}
    			}

    			if (dirty & /*swiperParams*/ 4) show_if_2 = needsNavigation(/*swiperParams*/ ctx[2]);

    			if (show_if_2) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					if_block0.m(div1, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*swiperParams*/ 4) show_if_1 = needsScrollbar(/*swiperParams*/ ctx[2]);

    			if (show_if_1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$3(ctx);
    					if_block1.c();
    					if_block1.m(div1, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty & /*swiperParams*/ 4) show_if = needsPagination(/*swiperParams*/ ctx[2]);

    			if (show_if) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$9(ctx);
    					if_block2.c();
    					if_block2.m(div1, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (wrapper_start_slot) {
    				if (wrapper_start_slot.p && (!current || dirty & /*$$scope, virtualData*/ 4608)) {
    					update_slot(wrapper_start_slot, wrapper_start_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_wrapper_start_slot_changes, get_wrapper_start_slot_context);
    				}
    			}

    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, virtualData*/ 4608)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_default_slot_changes$2, get_default_slot_context$2);
    				}
    			}

    			if (wrapper_end_slot) {
    				if (wrapper_end_slot.p && (!current || dirty & /*$$scope, virtualData*/ 4608)) {
    					update_slot(wrapper_end_slot, wrapper_end_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_wrapper_end_slot_changes, get_wrapper_end_slot_context);
    				}
    			}

    			if (container_end_slot) {
    				if (container_end_slot.p && (!current || dirty & /*$$scope, virtualData*/ 4608)) {
    					update_slot(container_end_slot, container_end_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_container_end_slot_changes, get_container_end_slot_context);
    				}
    			}

    			set_attributes(div1, div1_data = get_spread_update(div1_levels, [
    				(!current || dirty & /*containerClasses, className*/ 3 && div1_class_value !== (div1_class_value = uniqueClasses(`${/*containerClasses*/ ctx[1]}${/*className*/ ctx[0] ? ` ${/*className*/ ctx[0]}` : ""}`))) && { class: div1_class_value },
    				dirty & /*restProps*/ 8 && /*restProps*/ ctx[3]
    			]));
    		},
    		i(local) {
    			if (current) return;
    			transition_in(container_start_slot, local);
    			transition_in(wrapper_start_slot, local);
    			transition_in(default_slot, local);
    			transition_in(wrapper_end_slot, local);
    			transition_in(container_end_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(container_start_slot, local);
    			transition_out(wrapper_start_slot, local);
    			transition_out(default_slot, local);
    			transition_out(wrapper_end_slot, local);
    			transition_out(container_end_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div1);
    			if (container_start_slot) container_start_slot.d(detaching);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (wrapper_start_slot) wrapper_start_slot.d(detaching);
    			if (default_slot) default_slot.d(detaching);
    			if (wrapper_end_slot) wrapper_end_slot.d(detaching);
    			if (container_end_slot) container_end_slot.d(detaching);
    			/*div1_binding_1*/ ctx[18](null);
    		}
    	};
    }

    function instance$i($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class","modules","swiper"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	const dispatch = createEventDispatcher();
    	let { class: className = undefined } = $$props;
    	let { modules = null } = $$props;
    	let containerClasses = "swiper-container";
    	let breakpointChanged = false;
    	let swiperInstance = null;
    	let oldPassedParams = null;
    	let paramsData;
    	let swiperParams;
    	let passedParams;
    	let restProps;
    	let swiperEl = null;
    	let prevEl = null;
    	let nextEl = null;
    	let scrollbarEl = null;
    	let paginationEl = null;
    	let virtualData = { slides: [] };

    	function swiper() {
    		return swiperInstance;
    	}

    	const setVirtualData = data => {
    		$$invalidate(9, virtualData = data);

    		tick().then(() => {
    			swiperInstance.$wrapperEl.children(".swiper-slide").each(el => {
    				if (el.onSwiper) el.onSwiper(swiperInstance);
    			});

    			swiperInstance.updateSlides();
    			swiperInstance.updateProgress();
    			swiperInstance.updateSlidesClasses();

    			if (swiperInstance.lazy && swiperInstance.params.lazy.enabled) {
    				swiperInstance.lazy.load();
    			}
    		});
    	};

    	const calcParams = () => {
    		paramsData = getParams($$restProps);
    		$$invalidate(2, swiperParams = paramsData.params);
    		passedParams = paramsData.passedParams;
    		$$invalidate(3, restProps = paramsData.rest);
    	};

    	calcParams();
    	oldPassedParams = passedParams;

    	const onBeforeBreakpoint = () => {
    		breakpointChanged = true;
    	};

    	swiperParams.onAny = (event, ...args) => {
    		dispatch(event, [args]);
    	};

    	Object.assign(swiperParams.on, {
    		_beforeBreakpoint: onBeforeBreakpoint,
    		_containerClasses(_swiper, classes) {
    			$$invalidate(1, containerClasses = classes);
    		}
    	});

    	swiperInstance = initSwiper(swiperParams, modules);

    	if (swiperInstance.virtual && swiperInstance.params.virtual.enabled) {
    		const extendWith = {
    			cache: false,
    			renderExternal: data => {
    				setVirtualData(data);

    				if (swiperParams.virtual && swiperParams.virtual.renderExternal) {
    					swiperParams.virtual.renderExternal(data);
    				}
    			},
    			renderExternalUpdate: false
    		};

    		extend(swiperInstance.params.virtual, extendWith);
    		extend(swiperInstance.originalParams.virtual, extendWith);
    	}

    	onMount(() => {
    		if (!swiperEl) return;

    		mountSwiper(
    			{
    				el: swiperEl,
    				nextEl,
    				prevEl,
    				paginationEl,
    				scrollbarEl,
    				swiper: swiperInstance
    			},
    			swiperParams
    		);

    		dispatch("swiper", [swiperInstance]);
    		if (swiperParams.virtual) return;

    		swiperInstance.slides.each(el => {
    			if (el.onSwiper) el.onSwiper(swiperInstance);
    		});
    	});

    	afterUpdate(() => {
    		if (!swiperInstance) return;
    		calcParams();
    		const changedParams = getChangedParams(passedParams, oldPassedParams);

    		if ((changedParams.length || breakpointChanged) && swiperInstance && !swiperInstance.destroyed) {
    			updateSwiper({
    				swiper: swiperInstance,
    				passedParams,
    				changedParams,
    				nextEl,
    				prevEl,
    				scrollbarEl,
    				paginationEl
    			});
    		}

    		breakpointChanged = false;
    		oldPassedParams = passedParams;
    	});

    	onDestroy(() => {
    		if (typeof window !== "undefined" && swiperInstance && !swiperInstance.destroyed) {
    			swiperInstance.destroy(true, false);
    		}
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			prevEl = $$value;
    			$$invalidate(5, prevEl);
    		});
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			nextEl = $$value;
    			$$invalidate(6, nextEl);
    		});
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			scrollbarEl = $$value;
    			$$invalidate(7, scrollbarEl);
    		});
    	}

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			paginationEl = $$value;
    			$$invalidate(8, paginationEl);
    		});
    	}

    	function div1_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			swiperEl = $$value;
    			$$invalidate(4, swiperEl);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(28, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("class" in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ("modules" in $$new_props) $$invalidate(10, modules = $$new_props.modules);
    		if ("$$scope" in $$new_props) $$invalidate(12, $$scope = $$new_props.$$scope);
    	};

    	return [
    		className,
    		containerClasses,
    		swiperParams,
    		restProps,
    		swiperEl,
    		prevEl,
    		nextEl,
    		scrollbarEl,
    		paginationEl,
    		virtualData,
    		modules,
    		swiper,
    		$$scope,
    		slots,
    		div0_binding,
    		div1_binding,
    		div_binding,
    		div_binding_1,
    		div1_binding_1
    	];
    }

    class Swiper$1 extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { class: 0, modules: 10, swiper: 11 });
    	}

    	get swiper() {
    		return this.$$.ctx[11];
    	}
    }

    var Swiper$2 = Swiper$1;

    /* swiper.svelte generated by Svelte v3.38.2 */
    const get_default_slot_changes_1 = dirty => ({ data: dirty & /*slideData*/ 32 });
    const get_default_slot_context_1 = ctx => ({ data: /*slideData*/ ctx[5] });
    const get_default_slot_changes$1 = dirty => ({ data: dirty & /*slideData*/ 32 });
    const get_default_slot_context$1 = ctx => ({ data: /*slideData*/ ctx[5] });

    // (92:2) {:else}
    function create_else_block$3(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context_1);

    	return {
    		c() {
    			if (default_slot) default_slot.c();
    		},
    		m(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, slideData*/ 160)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_default_slot_changes_1, get_default_slot_context_1);
    				}
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    // (85:2) {#if zoom}
    function create_if_block$8(ctx) {
    	let div;
    	let div_data_swiper_zoom_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[8].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], get_default_slot_context$1);

    	return {
    		c() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr$1(div, "class", "swiper-zoom-container");

    			attr$1(div, "data-swiper-zoom", div_data_swiper_zoom_value = typeof /*zoom*/ ctx[0] === "number"
    			? /*zoom*/ ctx[0]
    			: undefined);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, slideData*/ 160)) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, get_default_slot_changes$1, get_default_slot_context$1);
    				}
    			}

    			if (!current || dirty & /*zoom*/ 1 && div_data_swiper_zoom_value !== (div_data_swiper_zoom_value = typeof /*zoom*/ ctx[0] === "number"
    			? /*zoom*/ ctx[0]
    			: undefined)) {
    				attr$1(div, "data-swiper-zoom", div_data_swiper_zoom_value);
    			}
    		},
    		i(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function create_fragment$h(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let div_class_value;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*zoom*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let div_levels = [
    		{
    			class: div_class_value = uniqueClasses(`${/*slideClasses*/ ctx[3]}${/*className*/ ctx[2] ? ` ${/*className*/ ctx[2]}` : ""}`)
    		},
    		{
    			"data-swiper-slide-index": /*virtualIndex*/ ctx[1]
    		},
    		/*$$restProps*/ ctx[6]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign$1(div_data, div_levels[i]);
    	}

    	return {
    		c() {
    			div = element("div");
    			if_block.c();
    			set_attributes(div, div_data);
    		},
    		m(target, anchor) {
    			insert(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[9](div);
    			current = true;
    		},
    		p(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*slideClasses, className*/ 12 && div_class_value !== (div_class_value = uniqueClasses(`${/*slideClasses*/ ctx[3]}${/*className*/ ctx[2] ? ` ${/*className*/ ctx[2]}` : ""}`))) && { class: div_class_value },
    				(!current || dirty & /*virtualIndex*/ 2) && {
    					"data-swiper-slide-index": /*virtualIndex*/ ctx[1]
    				},
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]
    			]));
    		},
    		i(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d(detaching) {
    			if (detaching) detach(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[9](null);
    		}
    	};
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let slideData;
    	const omit_props_names = ["zoom","virtualIndex","class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	let { zoom = undefined } = $$props;
    	let { virtualIndex = undefined } = $$props;
    	let { class: className = undefined } = $$props;
    	let slideEl = null;
    	let slideClasses = "swiper-slide";
    	let swiper = null;
    	let eventAttached = false;

    	const updateClasses = (_, el, classNames) => {
    		if (el === slideEl) {
    			$$invalidate(3, slideClasses = classNames);
    		}
    	};

    	const attachEvent = () => {
    		if (!swiper || eventAttached) return;
    		swiper.on("_slideClass", updateClasses);
    		eventAttached = true;
    	};

    	const detachEvent = () => {
    		if (!swiper) return;
    		swiper.off("_slideClass", updateClasses);
    		eventAttached = false;
    	};

    	onMount(() => {
    		if (typeof virtualIndex === "undefined") return;

    		$$invalidate(
    			4,
    			slideEl.onSwiper = _swiper => {
    				swiper = _swiper;
    				attachEvent();
    			},
    			slideEl
    		);

    		attachEvent();
    	});

    	afterUpdate(() => {
    		if (!slideEl || !swiper) return;

    		if (swiper.destroyed) {
    			if (slideClasses !== "swiper-slide") {
    				$$invalidate(3, slideClasses = "swiper-slide");
    			}

    			return;
    		}

    		attachEvent();
    	});

    	beforeUpdate(() => {
    		attachEvent();
    	});

    	onDestroy(() => {
    		if (!swiper) return;
    		detachEvent();
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			slideEl = $$value;
    			$$invalidate(4, slideEl);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("zoom" in $$new_props) $$invalidate(0, zoom = $$new_props.zoom);
    		if ("virtualIndex" in $$new_props) $$invalidate(1, virtualIndex = $$new_props.virtualIndex);
    		if ("class" in $$new_props) $$invalidate(2, className = $$new_props.class);
    		if ("$$scope" in $$new_props) $$invalidate(7, $$scope = $$new_props.$$scope);
    	};

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*slideClasses*/ 8) {
    			$$invalidate(5, slideData = {
    				isActive: slideClasses.indexOf("swiper-slide-active") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-active") >= 0,
    				isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
    				isDuplicate: slideClasses.indexOf("swiper-slide-duplicate") >= 0,
    				isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-prev") >= 0,
    				isNext: slideClasses.indexOf("swiper-slide-next") >= 0 || slideClasses.indexOf("swiper-slide-duplicate-next") >= 0
    			});
    		}
    	};

    	return [
    		zoom,
    		virtualIndex,
    		className,
    		slideClasses,
    		slideEl,
    		slideData,
    		$$restProps,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class Swiper extends SvelteComponent {
    	constructor(options) {
    		super();
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { zoom: 0, virtualIndex: 1, class: 2 });
    	}
    }

    var SwiperSlide = Swiper;

    /* src/components/slide-hero-swiper.svelte generated by Svelte v3.43.0 */

    const { document: document_1$2 } = globals;
    const file$f = "src/components/slide-hero-swiper.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    // (26:2) {#each contents.articles as article, i}
    function create_each_block_1$2(ctx) {
    	let link;
    	let link_href_value;

    	const block = {
    		c: function create() {
    			link = element("link");
    			attr_dev(link, "rel", "preload");
    			attr_dev(link, "href", link_href_value = "/img/" + /*article*/ ctx[11].imageId + "@" + /*preloadWidth*/ ctx[6][/*i*/ ctx[15]] + "w.webp");
    			attr_dev(link, "as", "image");
    			add_location(link, file$f, 26, 4, 1009);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && link_href_value !== (link_href_value = "/img/" + /*article*/ ctx[11].imageId + "@" + /*preloadWidth*/ ctx[6][/*i*/ ctx[15]] + "w.webp")) {
    				attr_dev(link, "href", link_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(26:2) {#each contents.articles as article, i}",
    		ctx
    	});

    	return block;
    }

    // (69:6) <SwiperSlide>
    function create_default_slot_1$2(ctx) {
    	let picture;
    	let t;
    	let current;

    	picture = new Picture({
    			props: {
    				imgClass: "slide-img",
    				sizes: "" + (/*standardWidth*/ ctx[2] / 16 * 9 / /*article*/ ctx[11].aspectRatio.height * /*article*/ ctx[11].aspectRatio.width + "vw"),
    				contents: /*contents*/ ctx[0],
    				globalSettings: /*globalSettings*/ ctx[1],
    				imageId: /*article*/ ctx[11].imageId,
    				width: /*article*/ ctx[11].aspectRatio.width,
    				height: /*article*/ ctx[11].aspectRatio.height,
    				useTiny: true,
    				loadLazy: false,
    				groupId: "slideHero",
    				groupImagesCount: /*contents*/ ctx[0].articles.length * 2
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(picture.$$.fragment);
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			mount_component(picture, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const picture_changes = {};
    			if (dirty & /*standardWidth, contents*/ 5) picture_changes.sizes = "" + (/*standardWidth*/ ctx[2] / 16 * 9 / /*article*/ ctx[11].aspectRatio.height * /*article*/ ctx[11].aspectRatio.width + "vw");
    			if (dirty & /*contents*/ 1) picture_changes.contents = /*contents*/ ctx[0];
    			if (dirty & /*globalSettings*/ 2) picture_changes.globalSettings = /*globalSettings*/ ctx[1];
    			if (dirty & /*contents*/ 1) picture_changes.imageId = /*article*/ ctx[11].imageId;
    			if (dirty & /*contents*/ 1) picture_changes.width = /*article*/ ctx[11].aspectRatio.width;
    			if (dirty & /*contents*/ 1) picture_changes.height = /*article*/ ctx[11].aspectRatio.height;
    			if (dirty & /*contents*/ 1) picture_changes.groupImagesCount = /*contents*/ ctx[0].articles.length * 2;
    			picture.$set(picture_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(picture.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(picture.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(picture, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(69:6) <SwiperSlide>",
    		ctx
    	});

    	return block;
    }

    // (68:4) {#each contents.articles as article}
    function create_each_block$5(ctx) {
    	let swiperslide;
    	let current;

    	swiperslide = new SwiperSlide({
    			props: {
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(swiperslide.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(swiperslide, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const swiperslide_changes = {};

    			if (dirty & /*$$scope, standardWidth, contents, globalSettings*/ 65543) {
    				swiperslide_changes.$$scope = { dirty, ctx };
    			}

    			swiperslide.$set(swiperslide_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(swiperslide.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(swiperslide.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(swiperslide, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(68:4) {#each contents.articles as article}",
    		ctx
    	});

    	return block;
    }

    // (35:2) <Swiper     centeredSlides={true}     spaceBetween={4}     slidesPerView={'auto'}     grabCursor={true}     speed={transitionDuration}     slideToClickedSlide={true}     loop={true}     pagination={{       clickable: true,       bulletClass: 'swiper-pagination-bullet-custom',       bulletActiveClass: 'swiper-pagination-bullet-custom-active'     }}     on:swiper={e => {       const [swiper] = e.detail;       window.addEventListener('pictureGroup_load', e => {         if(e.detail == 'slideHero'){           setTimeout(() => {             swiper.loopDestroy();             swiper.loopCreate();             swiper.update();             themeColor = contents.articles[swiper.realIndex].themeColor;           });         }       });     }}     on:realIndexChange={e => {       const [swiper] = e.detail[0];       themeColor = contents.articles[swiper.realIndex].themeColor;     }}     loopedSlides={contents.articles.length}     controller={{ control: controlledSwiper }}   >
    function create_default_slot$5(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*contents*/ ctx[0].articles;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*standardWidth, contents, globalSettings*/ 7) {
    				each_value = /*contents*/ ctx[0].articles;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(35:2) <Swiper     centeredSlides={true}     spaceBetween={4}     slidesPerView={'auto'}     grabCursor={true}     speed={transitionDuration}     slideToClickedSlide={true}     loop={true}     pagination={{       clickable: true,       bulletClass: 'swiper-pagination-bullet-custom',       bulletActiveClass: 'swiper-pagination-bullet-custom-active'     }}     on:swiper={e => {       const [swiper] = e.detail;       window.addEventListener('pictureGroup_load', e => {         if(e.detail == 'slideHero'){           setTimeout(() => {             swiper.loopDestroy();             swiper.loopCreate();             swiper.update();             themeColor = contents.articles[swiper.realIndex].themeColor;           });         }       });     }}     on:realIndexChange={e => {       const [swiper] = e.detail[0];       themeColor = contents.articles[swiper.realIndex].themeColor;     }}     loopedSlides={contents.articles.length}     controller={{ control: controlledSwiper }}   >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let link0;
    	let link1;
    	let t0;
    	let div;
    	let img0;
    	let img0_src_value;
    	let t1;
    	let swiper;
    	let t2;
    	let img1;
    	let img1_src_value;
    	let current;
    	let each_value_1 = /*contents*/ ctx[0].articles;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	swiper = new Swiper$2({
    			props: {
    				centeredSlides: true,
    				spaceBetween: 4,
    				slidesPerView: 'auto',
    				grabCursor: true,
    				speed: /*transitionDuration*/ ctx[5],
    				slideToClickedSlide: true,
    				loop: true,
    				pagination: {
    					clickable: true,
    					bulletClass: 'swiper-pagination-bullet-custom',
    					bulletActiveClass: 'swiper-pagination-bullet-custom-active'
    				},
    				loopedSlides: /*contents*/ ctx[0].articles.length,
    				controller: { control: /*controlledSwiper*/ ctx[4] },
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	swiper.$on("swiper", /*swiper_handler*/ ctx[8]);
    	swiper.$on("realIndexChange", /*realIndexChange_handler*/ ctx[9]);

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			link0 = element("link");
    			link1 = element("link");
    			t0 = space();
    			div = element("div");
    			img0 = element("img");
    			t1 = space();
    			create_component(swiper.$$.fragment);
    			t2 = space();
    			img1 = element("img");
    			attr_dev(link0, "rel", "preload");
    			attr_dev(link0, "href", "/swiper-bundle.min.css");
    			attr_dev(link0, "as", "style");
    			add_location(link0, file$f, 28, 2, 1107);
    			attr_dev(link1, "rel", "stylesheet");
    			attr_dev(link1, "type", "text/css");
    			attr_dev(link1, "href", "/swiper-bundle.min.css");
    			add_location(link1, file$f, 29, 2, 1171);
    			attr_dev(img0, "class", "arrow left svelte-c4762k");
    			if (!src_url_equal(img0.src, img0_src_value = "/img/arrow.svg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "");
    			attr_dev(img0, "width", "309.94");
    			attr_dev(img0, "height", "355.04");
    			add_location(img0, file$f, 33, 2, 1318);
    			attr_dev(img1, "class", "arrow right svelte-c4762k");
    			if (!src_url_equal(img1.src, img1_src_value = "/img/arrow.svg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "");
    			attr_dev(img1, "width", "309.94");
    			attr_dev(img1, "height", "355.04");
    			add_location(img1, file$f, 73, 2, 2850);
    			attr_dev(div, "class", "slide-hero svelte-c4762k");
    			set_style(div, "--themeColor", /*themeColor*/ ctx[3]);
    			add_location(div, file$f, 32, 0, 1257);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(document_1$2.head, null);
    			}

    			append_dev(document_1$2.head, link0);
    			append_dev(document_1$2.head, link1);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, img0);
    			append_dev(div, t1);
    			mount_component(swiper, div, null);
    			append_dev(div, t2);
    			append_dev(div, img1);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*contents, preloadWidth*/ 65) {
    				each_value_1 = /*contents*/ ctx[0].articles;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(link0.parentNode, link0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			const swiper_changes = {};
    			if (dirty & /*contents*/ 1) swiper_changes.loopedSlides = /*contents*/ ctx[0].articles.length;
    			if (dirty & /*controlledSwiper*/ 16) swiper_changes.controller = { control: /*controlledSwiper*/ ctx[4] };

    			if (dirty & /*$$scope, contents, standardWidth, globalSettings*/ 65543) {
    				swiper_changes.$$scope = { dirty, ctx };
    			}

    			swiper.$set(swiper_changes);

    			if (!current || dirty & /*themeColor*/ 8) {
    				set_style(div, "--themeColor", /*themeColor*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(swiper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(swiper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			detach_dev(link0);
    			detach_dev(link1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(swiper);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $sync;
    	validate_store(sync, 'sync');
    	component_subscribe($$self, sync, $$value => $$invalidate(10, $sync = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Slide_hero_swiper', slots, []);
    	let { contents, pairId, globalSettings, standardWidth } = $$props;
    	const transitionDuration = globalSettings.transitionDuration;
    	let themeColor;
    	SwiperCore.use([Controller$2, EffectFade, Pagination$2]);
    	let controlledSwiper = null;

    	addEventListener('controllee_load', e => {
    		setTimeout(() => {
    			$$invalidate(4, controlledSwiper = e.detail == pairId ? $sync.controlledSwiper : undefined);
    		});
    	});

    	const preloadWidth = contents.articles.map(u => {
    		return globalSettings.imageSizes.find(v => v > document.body.getBoundingClientRect().width * (standardWidth / 100) * (devicePixelRatio || 1) / 16 * 9 / u.aspectRatio.height * u.aspectRatio.width) || globalSettings.imageSizes.slice(-1)[0];
    	});

    	const writable_props = ['contents', 'pairId', 'globalSettings', 'standardWidth'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Slide_hero_swiper> was created with unknown prop '${key}'`);
    	});

    	const swiper_handler = e => {
    		const [swiper] = e.detail;

    		window.addEventListener('pictureGroup_load', e => {
    			if (e.detail == 'slideHero') {
    				setTimeout(() => {
    					swiper.loopDestroy();
    					swiper.loopCreate();
    					swiper.update();
    					$$invalidate(3, themeColor = contents.articles[swiper.realIndex].themeColor);
    				});
    			}
    		});
    	};

    	const realIndexChange_handler = e => {
    		const [swiper] = e.detail[0];
    		$$invalidate(3, themeColor = contents.articles[swiper.realIndex].themeColor);
    	};

    	$$self.$$set = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('pairId' in $$props) $$invalidate(7, pairId = $$props.pairId);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('standardWidth' in $$props) $$invalidate(2, standardWidth = $$props.standardWidth);
    	};

    	$$self.$capture_state = () => ({
    		Swiper: Swiper$2,
    		SwiperSlide,
    		SwiperCore,
    		Controller: Controller$2,
    		EffectFade,
    		Pagination: Pagination$2,
    		sync,
    		Picture,
    		contents,
    		pairId,
    		globalSettings,
    		standardWidth,
    		transitionDuration,
    		themeColor,
    		controlledSwiper,
    		preloadWidth,
    		$sync
    	});

    	$$self.$inject_state = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('pairId' in $$props) $$invalidate(7, pairId = $$props.pairId);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('standardWidth' in $$props) $$invalidate(2, standardWidth = $$props.standardWidth);
    		if ('themeColor' in $$props) $$invalidate(3, themeColor = $$props.themeColor);
    		if ('controlledSwiper' in $$props) $$invalidate(4, controlledSwiper = $$props.controlledSwiper);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		contents,
    		globalSettings,
    		standardWidth,
    		themeColor,
    		controlledSwiper,
    		transitionDuration,
    		preloadWidth,
    		pairId,
    		swiper_handler,
    		realIndexChange_handler
    	];
    }

    class Slide_hero_swiper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {
    			contents: 0,
    			pairId: 7,
    			globalSettings: 1,
    			standardWidth: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Slide_hero_swiper",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*contents*/ ctx[0] === undefined && !('contents' in props)) {
    			console.warn("<Slide_hero_swiper> was created without expected prop 'contents'");
    		}

    		if (/*pairId*/ ctx[7] === undefined && !('pairId' in props)) {
    			console.warn("<Slide_hero_swiper> was created without expected prop 'pairId'");
    		}

    		if (/*globalSettings*/ ctx[1] === undefined && !('globalSettings' in props)) {
    			console.warn("<Slide_hero_swiper> was created without expected prop 'globalSettings'");
    		}

    		if (/*standardWidth*/ ctx[2] === undefined && !('standardWidth' in props)) {
    			console.warn("<Slide_hero_swiper> was created without expected prop 'standardWidth'");
    		}
    	}

    	get contents() {
    		throw new Error("<Slide_hero_swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Slide_hero_swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pairId() {
    		throw new Error("<Slide_hero_swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pairId(value) {
    		throw new Error("<Slide_hero_swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get globalSettings() {
    		throw new Error("<Slide_hero_swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set globalSettings(value) {
    		throw new Error("<Slide_hero_swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get standardWidth() {
    		throw new Error("<Slide_hero_swiper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set standardWidth(value) {
    		throw new Error("<Slide_hero_swiper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var Sister;

    /**
    * @link https://github.com/gajus/sister for the canonical source repository
    * @license https://github.com/gajus/sister/blob/master/LICENSE BSD 3-Clause
    */
    Sister = function () {
        var sister = {},
            events = {};

        /**
         * @name handler
         * @function
         * @param {Object} data Event data.
         */

        /**
         * @param {String} name Event name.
         * @param {handler} handler
         * @return {listener}
         */
        sister.on = function (name, handler) {
            var listener = {name: name, handler: handler};
            events[name] = events[name] || [];
            events[name].unshift(listener);
            return listener;
        };

        /**
         * @param {listener}
         */
        sister.off = function (listener) {
            var index = events[listener.name].indexOf(listener);

            if (index !== -1) {
                events[listener.name].splice(index, 1);
            }
        };

        /**
         * @param {String} name Event name.
         * @param {Object} data Event data.
         */
        sister.trigger = function (name, data) {
            var listeners = events[name],
                i;

            if (listeners) {
                i = listeners.length;
                while (i--) {
                    listeners[i].handler(data);
                }
            }
        };

        return sister;
    };

    var sister = Sister;

    var loadScript = function load (src, opts, cb) {
      var head = document.head || document.getElementsByTagName('head')[0];
      var script = document.createElement('script');

      if (typeof opts === 'function') {
        cb = opts;
        opts = {};
      }

      opts = opts || {};
      cb = cb || function() {};

      script.type = opts.type || 'text/javascript';
      script.charset = opts.charset || 'utf8';
      script.async = 'async' in opts ? !!opts.async : true;
      script.src = src;

      if (opts.attrs) {
        setAttributes(script, opts.attrs);
      }

      if (opts.text) {
        script.text = '' + opts.text;
      }

      var onend = 'onload' in script ? stdOnEnd : ieOnEnd;
      onend(script, cb);

      // some good legacy browsers (firefox) fail the 'in' detection above
      // so as a fallback we always set onload
      // old IE will ignore this and new IE will set onload
      if (!script.onload) {
        stdOnEnd(script, cb);
      }

      head.appendChild(script);
    };

    function setAttributes(script, attrs) {
      for (var attr in attrs) {
        script.setAttribute(attr, attrs[attr]);
      }
    }

    function stdOnEnd (script, cb) {
      script.onload = function () {
        this.onerror = this.onload = null;
        cb(null, script);
      };
      script.onerror = function () {
        // this.onload = null here is necessary
        // because even IE9 works not like others
        this.onerror = this.onload = null;
        cb(new Error('Failed to load ' + this.src), script);
      };
    }

    function ieOnEnd (script, cb) {
      script.onreadystatechange = function () {
        if (this.readyState != 'complete' && this.readyState != 'loaded') return
        this.onreadystatechange = null;
        cb(null, script); // there is no way to catch loading errors in IE8
      };
    }

    var loadYouTubeIframeApi = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });



    var _loadScript2 = _interopRequireDefault(loadScript);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    exports.default = function (emitter) {
      /**
       * A promise that is resolved when window.onYouTubeIframeAPIReady is called.
       * The promise is resolved with a reference to window.YT object.
       */
      var iframeAPIReady = new Promise(function (resolve) {
        if (window.YT && window.YT.Player && window.YT.Player instanceof Function) {
          resolve(window.YT);

          return;
        } else {
          var protocol = window.location.protocol === 'http:' ? 'http:' : 'https:';

          (0, _loadScript2.default)(protocol + '//www.youtube.com/iframe_api', function (error) {
            if (error) {
              emitter.trigger('error', error);
            }
          });
        }

        var previous = window.onYouTubeIframeAPIReady;

        // The API will call this function when page has finished downloading
        // the JavaScript for the player API.
        window.onYouTubeIframeAPIReady = function () {
          if (previous) {
            previous();
          }

          resolve(window.YT);
        };
      });

      return iframeAPIReady;
    };

    module.exports = exports['default'];
    });

    /**
     * Helpers.
     */
    var s = 1000;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;

    /**
     * Parse or format the given `val`.
     *
     * Options:
     *
     *  - `long` verbose formatting [false]
     *
     * @param {String|Number} val
     * @param {Object} [options]
     * @throws {Error} throw an error if val is not a non-empty string or a number
     * @return {String|Number}
     * @api public
     */

    var ms = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === 'string' && val.length > 0) {
        return parse(val);
      } else if (type === 'number' && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        'val is not a non-empty string or a valid number. val=' +
          JSON.stringify(val)
      );
    };

    /**
     * Parse the given `str` and return milliseconds.
     *
     * @param {String} str
     * @return {Number}
     * @api private
     */

    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || 'ms').toLowerCase();
      switch (type) {
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
          return n * y;
        case 'days':
        case 'day':
        case 'd':
          return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
          return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
          return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
          return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
          return n;
        default:
          return undefined;
      }
    }

    /**
     * Short format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + 'd';
      }
      if (ms >= h) {
        return Math.round(ms / h) + 'h';
      }
      if (ms >= m) {
        return Math.round(ms / m) + 'm';
      }
      if (ms >= s) {
        return Math.round(ms / s) + 's';
      }
      return ms + 'ms';
    }

    /**
     * Long format for `ms`.
     *
     * @param {Number} ms
     * @return {String}
     * @api private
     */

    function fmtLong(ms) {
      return plural(ms, d, 'day') ||
        plural(ms, h, 'hour') ||
        plural(ms, m, 'minute') ||
        plural(ms, s, 'second') ||
        ms + ' ms';
    }

    /**
     * Pluralization helper.
     */

    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + ' ' + name;
      }
      return Math.ceil(ms / n) + ' ' + name + 's';
    }

    var debug = createCommonjsModule(function (module, exports) {
    /**
     * This is the common logic for both the Node.js and web browser
     * implementations of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    exports = module.exports = createDebug.debug = createDebug['default'] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = ms;

    /**
     * The currently active debug mode names, and names to skip.
     */

    exports.names = [];
    exports.skips = [];

    /**
     * Map of special "%n" handling functions, for the debug "format" argument.
     *
     * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
     */

    exports.formatters = {};

    /**
     * Previous log timestamp.
     */

    var prevTime;

    /**
     * Select a color.
     * @param {String} namespace
     * @return {Number}
     * @api private
     */

    function selectColor(namespace) {
      var hash = 0, i;

      for (i in namespace) {
        hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }

      return exports.colors[Math.abs(hash) % exports.colors.length];
    }

    /**
     * Create a debugger with the given `namespace`.
     *
     * @param {String} namespace
     * @return {Function}
     * @api public
     */

    function createDebug(namespace) {

      function debug() {
        // disabled?
        if (!debug.enabled) return;

        var self = debug;

        // set `diff` timestamp
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;

        // turn the `arguments` into a proper Array
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        args[0] = exports.coerce(args[0]);

        if ('string' !== typeof args[0]) {
          // anything else let's inspect with %O
          args.unshift('%O');
        }

        // apply any `formatters` transformations
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          // if we encounter an escaped % then don't increase the array index
          if (match === '%%') return match;
          index++;
          var formatter = exports.formatters[format];
          if ('function' === typeof formatter) {
            var val = args[index];
            match = formatter.call(self, val);

            // now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });

        // apply env-specific formatting (colors, etc.)
        exports.formatArgs.call(self, args);

        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self, args);
      }

      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);

      // env-specific initialization logic for debug instances
      if ('function' === typeof exports.init) {
        exports.init(debug);
      }

      return debug;
    }

    /**
     * Enables a debug mode by namespaces. This can include modes
     * separated by a colon and wildcards.
     *
     * @param {String} namespaces
     * @api public
     */

    function enable(namespaces) {
      exports.save(namespaces);

      exports.names = [];
      exports.skips = [];

      var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      var len = split.length;

      for (var i = 0; i < len; i++) {
        if (!split[i]) continue; // ignore empty strings
        namespaces = split[i].replace(/\*/g, '.*?');
        if (namespaces[0] === '-') {
          exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          exports.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }

    /**
     * Disable debug output.
     *
     * @api public
     */

    function disable() {
      exports.enable('');
    }

    /**
     * Returns true if the given mode name is enabled, false otherwise.
     *
     * @param {String} name
     * @return {Boolean}
     * @api public
     */

    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }

    /**
     * Coerce `val`.
     *
     * @param {Mixed} val
     * @return {Mixed}
     * @api private
     */

    function coerce(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
    });

    /**
     * This is the web browser implementation of `debug()`.
     *
     * Expose `debug()` as the module.
     */

    var browser = createCommonjsModule(function (module, exports) {
    exports = module.exports = debug;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = 'undefined' != typeof chrome
                   && 'undefined' != typeof chrome.storage
                      ? chrome.storage.local
                      : localstorage();

    /**
     * Colors.
     */

    exports.colors = [
      'lightseagreen',
      'forestgreen',
      'goldenrod',
      'dodgerblue',
      'darkorchid',
      'crimson'
    ];

    /**
     * Currently only WebKit-based Web Inspectors, Firefox >= v31,
     * and the Firebug extension (any Firefox version) are known
     * to support "%c" CSS customizations.
     *
     * TODO: add a `localStorage` variable to explicitly enable/disable colors
     */

    function useColors() {
      // NB: In an Electron preload script, document will be defined but not fully
      // initialized. Since we know we're in Chrome, we'll just detect this case
      // explicitly
      if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {
        return true;
      }

      // is webkit? http://stackoverflow.com/a/16459606/376773
      // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
      return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
        // is firebug? http://stackoverflow.com/a/398120/376773
        (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
        // is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
        // double check webkit in userAgent just in case we are in a worker
        (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
    }

    /**
     * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
     */

    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return '[UnexpectedJSONParseError]: ' + err.message;
      }
    };


    /**
     * Colorize log arguments if enabled.
     *
     * @api public
     */

    function formatArgs(args) {
      var useColors = this.useColors;

      args[0] = (useColors ? '%c' : '')
        + this.namespace
        + (useColors ? ' %c' : ' ')
        + args[0]
        + (useColors ? '%c ' : ' ')
        + '+' + exports.humanize(this.diff);

      if (!useColors) return;

      var c = 'color: ' + this.color;
      args.splice(1, 0, c, 'color: inherit');

      // the final "%c" is somewhat tricky, because there could be other
      // arguments passed either before or after the %c, so we need to
      // figure out the correct index to insert the CSS into
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ('%%' === match) return;
        index++;
        if ('%c' === match) {
          // we only are interested in the *last* %c
          // (the user may have provided their own)
          lastC = index;
        }
      });

      args.splice(lastC, 0, c);
    }

    /**
     * Invokes `console.log()` when available.
     * No-op when `console.log` is not a "function".
     *
     * @api public
     */

    function log() {
      // this hackery is required for IE8/9, where
      // the `console.log` function doesn't have 'apply'
      return 'object' === typeof console
        && console.log
        && Function.prototype.apply.call(console.log, console, arguments);
    }

    /**
     * Save `namespaces`.
     *
     * @param {String} namespaces
     * @api private
     */

    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem('debug');
        } else {
          exports.storage.debug = namespaces;
        }
      } catch(e) {}
    }

    /**
     * Load `namespaces`.
     *
     * @return {String} returns the previously persisted debug modes
     * @api private
     */

    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch(e) {}

      // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
      if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
      }

      return r;
    }

    /**
     * Enable namespaces listed in `localStorage.debug` initially.
     */

    exports.enable(load());

    /**
     * Localstorage attempts to return the localstorage.
     *
     * This is necessary because safari throws
     * when a user disables cookies/localstorage
     * and you attempt to access it.
     *
     * @return {LocalStorage}
     * @api private
     */

    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {}
    }
    });

    var functionNames = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });


    /**
     * @see https://developers.google.com/youtube/iframe_api_reference#Functions
     */
    exports.default = ['cueVideoById', 'loadVideoById', 'cueVideoByUrl', 'loadVideoByUrl', 'playVideo', 'pauseVideo', 'stopVideo', 'getVideoLoadedFraction', 'cuePlaylist', 'loadPlaylist', 'nextVideo', 'previousVideo', 'playVideoAt', 'setShuffle', 'setLoop', 'getPlaylist', 'getPlaylistIndex', 'setOption', 'mute', 'unMute', 'isMuted', 'setVolume', 'getVolume', 'seekTo', 'getPlayerState', 'getPlaybackRate', 'setPlaybackRate', 'getAvailablePlaybackRates', 'getPlaybackQuality', 'setPlaybackQuality', 'getAvailableQualityLevels', 'getCurrentTime', 'getDuration', 'removeEventListener', 'getVideoUrl', 'getVideoEmbedCode', 'getOptions', 'getOption', 'addEventListener', 'destroy', 'setSize', 'getIframe'];
    module.exports = exports['default'];
    });

    var eventNames = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });


    /**
     * @see https://developers.google.com/youtube/iframe_api_reference#Events
     * `volumeChange` is not officially supported but seems to work
     * it emits an object: `{volume: 82.6923076923077, muted: false}`
     */
    exports.default = ['ready', 'stateChange', 'playbackQualityChange', 'playbackRateChange', 'error', 'apiChange', 'volumeChange'];
    module.exports = exports['default'];
    });

    var PlayerStates = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {
      BUFFERING: 3,
      ENDED: 0,
      PAUSED: 2,
      PLAYING: 1,
      UNSTARTED: -1,
      VIDEO_CUED: 5
    };
    module.exports = exports["default"];
    });

    var FunctionStateMap = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });



    var _PlayerStates2 = _interopRequireDefault(PlayerStates);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    exports.default = {
      pauseVideo: {
        acceptableStates: [_PlayerStates2.default.ENDED, _PlayerStates2.default.PAUSED],
        stateChangeRequired: false
      },
      playVideo: {
        acceptableStates: [_PlayerStates2.default.ENDED, _PlayerStates2.default.PLAYING],
        stateChangeRequired: false
      },
      seekTo: {
        acceptableStates: [_PlayerStates2.default.ENDED, _PlayerStates2.default.PLAYING, _PlayerStates2.default.PAUSED],
        stateChangeRequired: true,

        // TRICKY: `seekTo` may not cause a state change if no buffering is
        // required.
        timeout: 3000
      }
    };
    module.exports = exports['default'];
    });

    var YouTubePlayer_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });



    var _debug2 = _interopRequireDefault(browser);



    var _functionNames2 = _interopRequireDefault(functionNames);



    var _eventNames2 = _interopRequireDefault(eventNames);



    var _FunctionStateMap2 = _interopRequireDefault(FunctionStateMap);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /* eslint-disable promise/prefer-await-to-then */

    var debug = (0, _debug2.default)('youtube-player');

    var YouTubePlayer = {};

    /**
     * Construct an object that defines an event handler for all of the YouTube
     * player events. Proxy captured events through an event emitter.
     *
     * @todo Capture event parameters.
     * @see https://developers.google.com/youtube/iframe_api_reference#Events
     */
    YouTubePlayer.proxyEvents = function (emitter) {
      var events = {};

      var _loop = function _loop(eventName) {
        var onEventName = 'on' + eventName.slice(0, 1).toUpperCase() + eventName.slice(1);

        events[onEventName] = function (event) {
          debug('event "%s"', onEventName, event);

          emitter.trigger(eventName, event);
        };
      };

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = _eventNames2.default[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var eventName = _step.value;

          _loop(eventName);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return events;
    };

    /**
     * Delays player API method execution until player state is ready.
     *
     * @todo Proxy all of the methods using Object.keys.
     * @todo See TRICKY below.
     * @param playerAPIReady Promise that resolves when player is ready.
     * @param strictState A flag designating whether or not to wait for
     * an acceptable state when calling supported functions.
     * @returns {Object}
     */
    YouTubePlayer.promisifyPlayer = function (playerAPIReady) {
      var strictState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var functions = {};

      var _loop2 = function _loop2(functionName) {
        if (strictState && _FunctionStateMap2.default[functionName]) {
          functions[functionName] = function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            return playerAPIReady.then(function (player) {
              var stateInfo = _FunctionStateMap2.default[functionName];
              var playerState = player.getPlayerState();

              // eslint-disable-next-line no-warning-comments
              // TODO: Just spread the args into the function once Babel is fixed:
              // https://github.com/babel/babel/issues/4270
              //
              // eslint-disable-next-line prefer-spread
              var value = player[functionName].apply(player, args);

              // TRICKY: For functions like `seekTo`, a change in state must be
              // triggered given that the resulting state could match the initial
              // state.
              if (stateInfo.stateChangeRequired ||

              // eslint-disable-next-line no-extra-parens
              Array.isArray(stateInfo.acceptableStates) && stateInfo.acceptableStates.indexOf(playerState) === -1) {
                return new Promise(function (resolve) {
                  var onPlayerStateChange = function onPlayerStateChange() {
                    var playerStateAfterChange = player.getPlayerState();

                    var timeout = void 0;

                    if (typeof stateInfo.timeout === 'number') {
                      timeout = setTimeout(function () {
                        player.removeEventListener('onStateChange', onPlayerStateChange);

                        resolve();
                      }, stateInfo.timeout);
                    }

                    if (Array.isArray(stateInfo.acceptableStates) && stateInfo.acceptableStates.indexOf(playerStateAfterChange) !== -1) {
                      player.removeEventListener('onStateChange', onPlayerStateChange);

                      clearTimeout(timeout);

                      resolve();
                    }
                  };

                  player.addEventListener('onStateChange', onPlayerStateChange);
                }).then(function () {
                  return value;
                });
              }

              return value;
            });
          };
        } else {
          functions[functionName] = function () {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            return playerAPIReady.then(function (player) {
              // eslint-disable-next-line no-warning-comments
              // TODO: Just spread the args into the function once Babel is fixed:
              // https://github.com/babel/babel/issues/4270
              //
              // eslint-disable-next-line prefer-spread
              return player[functionName].apply(player, args);
            });
          };
        }
      };

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _functionNames2.default[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var functionName = _step2.value;

          _loop2(functionName);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return functions;
    };

    exports.default = YouTubePlayer;
    module.exports = exports['default'];
    });

    var dist = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };



    var _sister2 = _interopRequireDefault(sister);



    var _loadYouTubeIframeApi2 = _interopRequireDefault(loadYouTubeIframeApi);



    var _YouTubePlayer2 = _interopRequireDefault(YouTubePlayer_1);

    function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

    /**
     * @typedef YT.Player
     * @see https://developers.google.com/youtube/iframe_api_reference
     * */

    /**
     * @see https://developers.google.com/youtube/iframe_api_reference#Loading_a_Video_Player
     */
    var youtubeIframeAPI = void 0;

    /**
     * A factory function used to produce an instance of YT.Player and queue function calls and proxy events of the resulting object.
     *
     * @param maybeElementId Either An existing YT.Player instance,
     * the DOM element or the id of the HTML element where the API will insert an <iframe>.
     * @param options See `options` (Ignored when using an existing YT.Player instance).
     * @param strictState A flag designating whether or not to wait for
     * an acceptable state when calling supported functions. Default: `false`.
     * See `FunctionStateMap.js` for supported functions and acceptable states.
     */

    exports.default = function (maybeElementId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var strictState = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var emitter = (0, _sister2.default)();

      if (!youtubeIframeAPI) {
        youtubeIframeAPI = (0, _loadYouTubeIframeApi2.default)(emitter);
      }

      if (options.events) {
        throw new Error('Event handlers cannot be overwritten.');
      }

      if (typeof maybeElementId === 'string' && !document.getElementById(maybeElementId)) {
        throw new Error('Element "' + maybeElementId + '" does not exist.');
      }

      options.events = _YouTubePlayer2.default.proxyEvents(emitter);

      var playerAPIReady = new Promise(function (resolve) {
        if ((typeof maybeElementId === 'undefined' ? 'undefined' : _typeof(maybeElementId)) === 'object' && maybeElementId.playVideo instanceof Function) {
          var player = maybeElementId;

          resolve(player);
        } else {
          // asume maybeElementId can be rendered inside
          // eslint-disable-next-line promise/catch-or-return
          youtubeIframeAPI.then(function (YT) {
            // eslint-disable-line promise/prefer-await-to-then
            var player = new YT.Player(maybeElementId, options);

            emitter.on('ready', function () {
              resolve(player);
            });

            return null;
          });
        }
      });

      var playerApi = _YouTubePlayer2.default.promisifyPlayer(playerAPIReady, strictState);

      playerApi.on = emitter.on;
      playerApi.off = emitter.off;

      return playerApi;
    };

    module.exports = exports['default'];
    });

    var YoutubePlayer = /*@__PURE__*/getDefaultExportFromCjs(dist);

    /* node_modules/.pnpm/svelte-youtube@0.0.2_svelte@3.43.0/node_modules/svelte-youtube/src/index.svelte generated by Svelte v3.43.0 */
    const file$e = "node_modules/.pnpm/svelte-youtube@0.0.2_svelte@3.43.0/node_modules/svelte-youtube/src/index.svelte";

    function create_fragment$f(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "id", /*id*/ ctx[0]);
    			add_location(div0, file$e, 143, 2, 4083);
    			attr_dev(div1, "class", /*className*/ ctx[1]);
    			add_location(div1, file$e, 142, 0, 4057);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			/*div0_binding*/ ctx[5](div0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*id*/ 1) {
    				attr_dev(div0, "id", /*id*/ ctx[0]);
    			}

    			if (dirty & /*className*/ 2) {
    				attr_dev(div1, "class", /*className*/ ctx[1]);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*div0_binding*/ ctx[5](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const PlayerState = {
    	UNSTARTED: -1,
    	ENDED: 0,
    	PLAYING: 1,
    	PAUSED: 2,
    	BUFFERING: 3,
    	CUED: 5
    };

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Src', slots, []);
    	let { id = undefined } = $$props;
    	let { videoId } = $$props;
    	let { options = undefined } = $$props;
    	let { class: className } = $$props;
    	let playerElem; // player DOM element reference
    	let player; // player API instance

    	// Create and tear down player as component mounts or unmounts
    	onMount(() => createPlayer());

    	function createPlayer() {
    		player = YoutubePlayer(playerElem, options);

    		// Register event handlers
    		player.on('ready', onPlayerReady);

    		player.on('error', onPlayerError);
    		player.on('stateChange', onPlayerStateChange);
    		player.on('playbackRateChange', onPlayerPlaybackRateChange);
    		player.on('playbackQualityChange', onPlayerPlaybackQualityChange);

    		// Tear down player when done
    		return () => player.destroy();
    	}

    	function play(videoId) {
    		// this is needed because the loadVideoById function always starts playing,
    		// even if you have set autoplay to 1 whereas the cueVideoById function
    		// never starts autoplaying
    		if (player && videoId) {
    			if (options && options.playerVars && options.playerVars.autoplay === 1) {
    				player.loadVideoById(videoId);
    			} else {
    				player.cueVideoById(videoId);
    			}
    		}
    	}

    	// -------------------------------------------
    	// Event handling
    	// -------------------------------------------
    	const dispatch = createEventDispatcher();

    	/**
     * https://developers.google.com/youtube/iframe_api_reference#onReady
     *
     * @param {Object} event
     *   @param {Object} target - player object
     */
    	function onPlayerReady(event) {
    		dispatch('ready', event);

    		// Start playing
    		play(videoId);
    	}

    	/**
     * https://developers.google.com/youtube/iframe_api_reference#onError
     *
     * @param {Object} event
     *   @param {Integer} data  - error type
     *   @param {Object} target - player object
     */
    	function onPlayerError(event) {
    		dispatch('error', event);
    	}

    	/**
     * https://developers.google.com/youtube/iframe_api_reference#onStateChange
     *
     * @param {Object} event
     *   @param {Integer} data  - status change type
     *   @param {Object} target - actual YT player
     */
    	function onPlayerStateChange(event) {
    		dispatch('stateChange', event);

    		switch (event.data) {
    			case PlayerState.ENDED:
    				dispatch('end', event);
    				break;
    			case PlayerState.PLAYING:
    				dispatch('play', event);
    				break;
    			case PlayerState.PAUSED:
    				dispatch('pause', event);
    				break;
    		}
    	}

    	/**
     * https://developers.google.com/youtube/iframe_api_reference#onPlaybackRateChange
     *
     * @param {Object} event
     *   @param {Float} data    - playback rate
     *   @param {Object} target - actual YT player
     */
    	function onPlayerPlaybackRateChange(event) {
    		dispatch('playbackRateChange', event);
    	}

    	/**
     * https://developers.google.com/youtube/iframe_api_reference#onPlaybackQualityChange
     *
     * @param {Object} event
     *   @param {String} data   - playback quality
     *   @param {Object} target - actual YT player
     */
    	function onPlayerPlaybackQualityChange(event) {
    		dispatch('playbackQualityChange', event);
    	}

    	const writable_props = ['id', 'videoId', 'options', 'class'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Src> was created with unknown prop '${key}'`);
    	});

    	function div0_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			playerElem = $$value;
    			$$invalidate(2, playerElem);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ('id' in $$props) $$invalidate(0, id = $$props.id);
    		if ('videoId' in $$props) $$invalidate(3, videoId = $$props.videoId);
    		if ('options' in $$props) $$invalidate(4, options = $$props.options);
    		if ('class' in $$props) $$invalidate(1, className = $$props.class);
    	};

    	$$self.$capture_state = () => ({
    		PlayerState,
    		onMount,
    		createEventDispatcher,
    		YoutubePlayer,
    		id,
    		videoId,
    		options,
    		className,
    		playerElem,
    		player,
    		createPlayer,
    		play,
    		dispatch,
    		onPlayerReady,
    		onPlayerError,
    		onPlayerStateChange,
    		onPlayerPlaybackRateChange,
    		onPlayerPlaybackQualityChange
    	});

    	$$self.$inject_state = $$props => {
    		if ('id' in $$props) $$invalidate(0, id = $$props.id);
    		if ('videoId' in $$props) $$invalidate(3, videoId = $$props.videoId);
    		if ('options' in $$props) $$invalidate(4, options = $$props.options);
    		if ('className' in $$props) $$invalidate(1, className = $$props.className);
    		if ('playerElem' in $$props) $$invalidate(2, playerElem = $$props.playerElem);
    		if ('player' in $$props) player = $$props.player;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*videoId*/ 8) {
    			// Update videoId and load new video if URL changes
    			play(videoId);
    		}
    	};

    	return [id, className, playerElem, videoId, options, div0_binding];
    }

    class Src extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { id: 0, videoId: 3, options: 4, class: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Src",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*videoId*/ ctx[3] === undefined && !('videoId' in props)) {
    			console.warn("<Src> was created without expected prop 'videoId'");
    		}

    		if (/*className*/ ctx[1] === undefined && !('class' in props)) {
    			console.warn("<Src> was created without expected prop 'class'");
    		}
    	}

    	get id() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get videoId() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set videoId(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get class() {
    		throw new Error("<Src>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<Src>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/youtube-iframe.svelte generated by Svelte v3.43.0 */
    const file$d = "src/components/youtube-iframe.svelte";

    // (11:2) {#if load}
    function create_if_block$7(ctx) {
    	let youtube;
    	let current;

    	youtube = new Src({
    			props: {
    				videoId: /*id*/ ctx[2],
    				class: "description-youtube-iframe",
    				options: {
    					width: '640',
    					height: '360',
    					playerVars: { autoplay: 1, playsinline: 1 }
    				}
    			},
    			$$inline: true
    		});

    	youtube.$on("ready", /*ready_handler*/ ctx[5]);

    	const block = {
    		c: function create() {
    			create_component(youtube.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(youtube, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const youtube_changes = {};
    			if (dirty & /*id*/ 4) youtube_changes.videoId = /*id*/ ctx[2];
    			youtube.$set(youtube_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(youtube.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(youtube.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(youtube, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(11:2) {#if load}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let picture;
    	let t0;
    	let img;
    	let img_src_value;
    	let t1;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	picture = new Picture({
    			props: {
    				imgClass: "description-youtube-thumbnail",
    				contents: /*contents*/ ctx[0],
    				globalSettings: /*globalSettings*/ ctx[1],
    				sizes: /*sizes*/ ctx[3],
    				imageId: /*id*/ ctx[2],
    				width: "16",
    				height: "9"
    			},
    			$$inline: true
    		});

    	let if_block = /*load*/ ctx[4] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(picture.$$.fragment);
    			t0 = space();
    			img = element("img");
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(img, "class", "play-icon svelte-1vh6ykm");
    			if (!src_url_equal(img.src, img_src_value = "/img/youtube.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "YouTube");
    			attr_dev(img, "width", "44");
    			attr_dev(img, "height", "31");
    			add_location(img, file$d, 9, 2, 379);
    			attr_dev(div, "class", div_class_value = "youtube-wrapper " + (/*load*/ ctx[4] ? 'load' : '') + " svelte-1vh6ykm");
    			add_location(div, file$d, 7, 0, 171);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(picture, div, null);
    			append_dev(div, t0);
    			append_dev(div, img);
    			append_dev(div, t1);
    			if (if_block) if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const picture_changes = {};
    			if (dirty & /*contents*/ 1) picture_changes.contents = /*contents*/ ctx[0];
    			if (dirty & /*globalSettings*/ 2) picture_changes.globalSettings = /*globalSettings*/ ctx[1];
    			if (dirty & /*sizes*/ 8) picture_changes.sizes = /*sizes*/ ctx[3];
    			if (dirty & /*id*/ 4) picture_changes.imageId = /*id*/ ctx[2];
    			picture.$set(picture_changes);

    			if (/*load*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*load*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*load*/ 16 && div_class_value !== (div_class_value = "youtube-wrapper " + (/*load*/ ctx[4] ? 'load' : '') + " svelte-1vh6ykm")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(picture.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(picture.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(picture);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Youtube_iframe', slots, []);
    	let { contents, globalSettings, id, sizes } = $$props;
    	let load = false;
    	const writable_props = ['contents', 'globalSettings', 'id', 'sizes'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Youtube_iframe> was created with unknown prop '${key}'`);
    	});

    	const ready_handler = e => {
    		window.addEventListener('slide', () => {
    			e.detail.target.pauseVideo();
    		});
    	};

    	const click_handler = () => $$invalidate(4, load = true);

    	$$self.$$set = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('id' in $$props) $$invalidate(2, id = $$props.id);
    		if ('sizes' in $$props) $$invalidate(3, sizes = $$props.sizes);
    	};

    	$$self.$capture_state = () => ({
    		YouTube: Src,
    		Picture,
    		contents,
    		globalSettings,
    		id,
    		sizes,
    		load
    	});

    	$$self.$inject_state = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('id' in $$props) $$invalidate(2, id = $$props.id);
    		if ('sizes' in $$props) $$invalidate(3, sizes = $$props.sizes);
    		if ('load' in $$props) $$invalidate(4, load = $$props.load);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [contents, globalSettings, id, sizes, load, ready_handler, click_handler];
    }

    class Youtube_iframe extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
    			contents: 0,
    			globalSettings: 1,
    			id: 2,
    			sizes: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Youtube_iframe",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*contents*/ ctx[0] === undefined && !('contents' in props)) {
    			console.warn("<Youtube_iframe> was created without expected prop 'contents'");
    		}

    		if (/*globalSettings*/ ctx[1] === undefined && !('globalSettings' in props)) {
    			console.warn("<Youtube_iframe> was created without expected prop 'globalSettings'");
    		}

    		if (/*id*/ ctx[2] === undefined && !('id' in props)) {
    			console.warn("<Youtube_iframe> was created without expected prop 'id'");
    		}

    		if (/*sizes*/ ctx[3] === undefined && !('sizes' in props)) {
    			console.warn("<Youtube_iframe> was created without expected prop 'sizes'");
    		}
    	}

    	get contents() {
    		throw new Error("<Youtube_iframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Youtube_iframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get globalSettings() {
    		throw new Error("<Youtube_iframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set globalSettings(value) {
    		throw new Error("<Youtube_iframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error("<Youtube_iframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<Youtube_iframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sizes() {
    		throw new Error("<Youtube_iframe>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sizes(value) {
    		throw new Error("<Youtube_iframe>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/slide-description.svelte generated by Svelte v3.43.0 */

    const { document: document_1$1 } = globals;
    const file$c = "src/components/slide-description.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    function get_each_context_6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[25] = list[i];
    	return child_ctx;
    }

    function get_each_context_7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    function get_each_context_10(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	return child_ctx;
    }

    // (73:14) {:else}
    function create_else_block_4(ctx) {
    	let t_value = /*article*/ ctx[10].subtitle + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*article*/ ctx[10].subtitle + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_4.name,
    		type: "else",
    		source: "(73:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (69:14) {#if Array.isArray(article.subtitle)}
    function create_if_block_14(ctx) {
    	let each_1_anchor;
    	let each_value_10 = /*article*/ ctx[10].subtitle;
    	validate_each_argument(each_value_10);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_10.length; i += 1) {
    		each_blocks[i] = create_each_block_10(get_each_context_10(ctx, each_value_10, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2) {
    				each_value_10 = /*article*/ ctx[10].subtitle;
    				validate_each_argument(each_value_10);
    				let i;

    				for (i = 0; i < each_value_10.length; i += 1) {
    					const child_ctx = get_each_context_10(ctx, each_value_10, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_10(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_10.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(69:14) {#if Array.isArray(article.subtitle)}",
    		ctx
    	});

    	return block;
    }

    // (70:16) {#each article.subtitle as subtitle}
    function create_each_block_10(ctx) {
    	let t_value = /*subtitle*/ ctx[34] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*subtitle*/ ctx[34] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_10.name,
    		type: "each",
    		source: "(70:16) {#each article.subtitle as subtitle}",
    		ctx
    	});

    	return block;
    }

    // (82:14) {:else}
    function create_else_block_3(ctx) {
    	let t_value = /*article*/ ctx[10].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*article*/ ctx[10].title + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(82:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (78:14) {#if Array.isArray(article.title)}
    function create_if_block_13(ctx) {
    	let each_1_anchor;
    	let each_value_9 = /*article*/ ctx[10].title;
    	validate_each_argument(each_value_9);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_9.length; i += 1) {
    		each_blocks[i] = create_each_block_9(get_each_context_9(ctx, each_value_9, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2) {
    				each_value_9 = /*article*/ ctx[10].title;
    				validate_each_argument(each_value_9);
    				let i;

    				for (i = 0; i < each_value_9.length; i += 1) {
    					const child_ctx = get_each_context_9(ctx, each_value_9, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_9(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_9.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(78:14) {#if Array.isArray(article.title)}",
    		ctx
    	});

    	return block;
    }

    // (79:16) {#each article.title as title}
    function create_each_block_9(ctx) {
    	let t_value = /*title*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*title*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_9.name,
    		type: "each",
    		source: "(79:16) {#each article.title as title}",
    		ctx
    	});

    	return block;
    }

    // (89:14) {#if button.popup}
    function create_if_block_12(ctx) {
    	let div;
    	let t_value = /*button*/ ctx[13].popup + "";
    	let t;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text$1(t_value);
    			attr_dev(div, "class", div_class_value = "popup " + (/*button*/ ctx[13].disabled ? 'disabled' : '') + " svelte-1fj2vis");
    			add_location(div, file$c, 89, 16, 3374);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*button*/ ctx[13].popup + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*contents*/ 2 && div_class_value !== (div_class_value = "popup " + (/*button*/ ctx[13].disabled ? 'disabled' : '') + " svelte-1fj2vis")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(89:14) {#if button.popup}",
    		ctx
    	});

    	return block;
    }

    // (97:16) {:else}
    function create_else_block_2(ctx) {
    	let t_value = /*button*/ ctx[13].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*button*/ ctx[13].title + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(97:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (93:16) {#if Array.isArray(button.title)}
    function create_if_block_11(ctx) {
    	let each_1_anchor;
    	let each_value_8 = /*button*/ ctx[13].title;
    	validate_each_argument(each_value_8);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_8.length; i += 1) {
    		each_blocks[i] = create_each_block_8(get_each_context_8(ctx, each_value_8, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2) {
    				each_value_8 = /*button*/ ctx[13].title;
    				validate_each_argument(each_value_8);
    				let i;

    				for (i = 0; i < each_value_8.length; i += 1) {
    					const child_ctx = get_each_context_8(ctx, each_value_8, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_8.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(93:16) {#if Array.isArray(button.title)}",
    		ctx
    	});

    	return block;
    }

    // (94:18) {#each button.title as title}
    function create_each_block_8(ctx) {
    	let span;
    	let t_value = /*title*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "break-scope svelte-1fj2vis");
    			add_location(span, file$c, 94, 20, 3712);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*title*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_8.name,
    		type: "each",
    		source: "(94:18) {#each button.title as title}",
    		ctx
    	});

    	return block;
    }

    // (92:14) <Button target={button.target} bg="#0a6afa" width="auto" disabled={button.disabled} spaMode={button.spaMode}>
    function create_default_slot_5$1(ctx) {
    	let show_if;
    	let t;

    	function select_block_type_2(ctx, dirty) {
    		if (show_if == null || dirty[0] & /*contents*/ 2) show_if = !!Array.isArray(/*button*/ ctx[13].title);
    		if (show_if) return create_if_block_11;
    		return create_else_block_2;
    	}

    	let current_block_type = select_block_type_2(ctx, [-1, -1]);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_2(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(92:14) <Button target={button.target} bg=\\\"#0a6afa\\\" width=\\\"auto\\\" disabled={button.disabled} spaMode={button.spaMode}>",
    		ctx
    	});

    	return block;
    }

    // (88:12) {#each article.buttons as button}
    function create_each_block_7(ctx) {
    	let t;
    	let button;
    	let current;
    	let if_block = /*button*/ ctx[13].popup && create_if_block_12(ctx);

    	button = new Button({
    			props: {
    				target: /*button*/ ctx[13].target,
    				bg: "#0a6afa",
    				width: "auto",
    				disabled: /*button*/ ctx[13].disabled,
    				spaMode: /*button*/ ctx[13].spaMode,
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*button*/ ctx[13].popup) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_12(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const button_changes = {};
    			if (dirty[0] & /*contents*/ 2) button_changes.target = /*button*/ ctx[13].target;
    			if (dirty[0] & /*contents*/ 2) button_changes.disabled = /*button*/ ctx[13].disabled;
    			if (dirty[0] & /*contents*/ 2) button_changes.spaMode = /*button*/ ctx[13].spaMode;

    			if (dirty[0] & /*contents*/ 2 | dirty[1] & /*$$scope*/ 64) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_7.name,
    		type: "each",
    		source: "(88:12) {#each article.buttons as button}",
    		ctx
    	});

    	return block;
    }

    // (105:10) {#if article.slides}
    function create_if_block_9(ctx) {
    	let div;
    	let swiper;
    	let current;

    	swiper = new Swiper$2({
    			props: {
    				centeredSlides: true,
    				autoHeight: true,
    				spaceBetween: 0,
    				slidesPerView: 1,
    				speed: /*transitionDuration*/ ctx[3],
    				updateOnImagesReady: true,
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	swiper.$on("snapIndexChange", /*snapIndexChange_handler*/ ctx[7]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(swiper.$$.fragment);
    			attr_dev(div, "class", "slide svelte-1fj2vis");
    			add_location(div, file$c, 105, 12, 4021);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(swiper, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const swiper_changes = {};

    			if (dirty[0] & /*contents, globalSettings, standardWidth*/ 7 | dirty[1] & /*$$scope*/ 64) {
    				swiper_changes.$$scope = { dirty, ctx };
    			}

    			swiper.$set(swiper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(swiper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(swiper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(swiper);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(105:10) {#if article.slides}",
    		ctx
    	});

    	return block;
    }

    // (118:20) {#if slide.type == "youtube"}
    function create_if_block_10(ctx) {
    	let yframe;
    	let current;

    	yframe = new Youtube_iframe({
    			props: {
    				contents: /*contents*/ ctx[1],
    				globalSettings: /*globalSettings*/ ctx[0],
    				id: /*slide*/ ctx[25].id,
    				sizes: "@media (orientation: portrait) " + /*standardWidth*/ ctx[2] + "vw, " + /*standardWidth*/ ctx[2] * 0.975 / 2 + "vw"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(yframe.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(yframe, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const yframe_changes = {};
    			if (dirty[0] & /*contents*/ 2) yframe_changes.contents = /*contents*/ ctx[1];
    			if (dirty[0] & /*globalSettings*/ 1) yframe_changes.globalSettings = /*globalSettings*/ ctx[0];
    			if (dirty[0] & /*contents*/ 2) yframe_changes.id = /*slide*/ ctx[25].id;
    			if (dirty[0] & /*standardWidth*/ 4) yframe_changes.sizes = "@media (orientation: portrait) " + /*standardWidth*/ ctx[2] + "vw, " + /*standardWidth*/ ctx[2] * 0.975 / 2 + "vw";
    			yframe.$set(yframe_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(yframe.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(yframe.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(yframe, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(118:20) {#if slide.type == \\\"youtube\\\"}",
    		ctx
    	});

    	return block;
    }

    // (117:18) <SwiperSlide>
    function create_default_slot_4$1(ctx) {
    	let t;
    	let current;
    	let if_block = /*slide*/ ctx[25].type == "youtube" && create_if_block_10(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*slide*/ ctx[25].type == "youtube") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*contents*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_10(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(117:18) <SwiperSlide>",
    		ctx
    	});

    	return block;
    }

    // (116:16) {#each article.slides as slide}
    function create_each_block_6(ctx) {
    	let swiperslide;
    	let current;

    	swiperslide = new SwiperSlide({
    			props: {
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(swiperslide.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(swiperslide, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const swiperslide_changes = {};

    			if (dirty[0] & /*contents, globalSettings, standardWidth*/ 7 | dirty[1] & /*$$scope*/ 64) {
    				swiperslide_changes.$$scope = { dirty, ctx };
    			}

    			swiperslide.$set(swiperslide_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(swiperslide.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(swiperslide.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(swiperslide, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_6.name,
    		type: "each",
    		source: "(116:16) {#each article.slides as slide}",
    		ctx
    	});

    	return block;
    }

    // (107:14) <Swiper                 centeredSlides={true}                 autoHeight={true}                 spaceBetween={0}                 slidesPerView={1}                 speed={transitionDuration}                 updateOnImagesReady={true}                 on:snapIndexChange={() => window.dispatchEvent(new CustomEvent('slide'))}               >
    function create_default_slot_3$1(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_6 = /*article*/ ctx[10].slides;
    	validate_each_argument(each_value_6);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_6.length; i += 1) {
    		each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents, globalSettings, standardWidth*/ 7) {
    				each_value_6 = /*article*/ ctx[10].slides;
    				validate_each_argument(each_value_6);
    				let i;

    				for (i = 0; i < each_value_6.length; i += 1) {
    					const child_ctx = get_each_context_6(ctx, each_value_6, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_6.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_6.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(107:14) <Swiper                 centeredSlides={true}                 autoHeight={true}                 spaceBetween={0}                 slidesPerView={1}                 speed={transitionDuration}                 updateOnImagesReady={true}                 on:snapIndexChange={() => window.dispatchEvent(new CustomEvent('slide'))}               >",
    		ctx
    	});

    	return block;
    }

    // (132:14) {:else}
    function create_else_block_1(ctx) {
    	let t_value = /*article*/ ctx[10].description + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*article*/ ctx[10].description + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(132:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (128:14) {#if Array.isArray(article.description)}
    function create_if_block_8(ctx) {
    	let each_1_anchor;
    	let each_value_5 = /*article*/ ctx[10].description;
    	validate_each_argument(each_value_5);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_5.length; i += 1) {
    		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2) {
    				each_value_5 = /*article*/ ctx[10].description;
    				validate_each_argument(each_value_5);
    				let i;

    				for (i = 0; i < each_value_5.length; i += 1) {
    					const child_ctx = get_each_context_5(ctx, each_value_5, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_5.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(128:14) {#if Array.isArray(article.description)}",
    		ctx
    	});

    	return block;
    }

    // (129:16) {#each article.description as p, i}
    function create_each_block_5(ctx) {
    	let p;
    	let t_value = /*p*/ ctx[23] + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text$1(t_value);
    			attr_dev(p, "class", "" + (null_to_empty(/*i*/ ctx[12] == 0 ? 'first-line' : '') + " svelte-1fj2vis"));
    			add_location(p, file$c, 129, 18, 5013);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*p*/ ctx[23] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_5.name,
    		type: "each",
    		source: "(129:16) {#each article.description as p, i}",
    		ctx
    	});

    	return block;
    }

    // (136:12) {#if article.specs}
    function create_if_block_2$2(ctx) {
    	let div;
    	let t;
    	let if_block0 = /*article*/ ctx[10].specs.times && create_if_block_4$2(ctx);
    	let if_block1 = /*article*/ ctx[10].specs.platforms && create_if_block_3$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "specs svelte-1fj2vis");
    			add_location(div, file$c, 136, 14, 5232);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*article*/ ctx[10].specs.times) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$2(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*article*/ ctx[10].specs.platforms) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$2(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(136:12) {#if article.specs}",
    		ctx
    	});

    	return block;
    }

    // (138:16) {#if article.specs.times}
    function create_if_block_4$2(ctx) {
    	let div;
    	let span;
    	let t1;
    	let each_value_4 = /*article*/ ctx[10].specs.times;
    	validate_each_argument(each_value_4);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_4.length; i += 1) {
    		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span, "class", "tag svelte-1fj2vis");
    			add_location(span, file$c, 139, 20, 5352);
    			attr_dev(div, "class", "times svelte-1fj2vis");
    			add_location(div, file$c, 138, 18, 5312);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2) {
    				each_value_4 = /*article*/ ctx[10].specs.times;
    				validate_each_argument(each_value_4);
    				let i;

    				for (i = 0; i < each_value_4.length; i += 1) {
    					const child_ctx = get_each_context_4(ctx, each_value_4, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_4.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(138:16) {#if article.specs.times}",
    		ctx
    	});

    	return block;
    }

    // (144:24) {#if time.year}
    function create_if_block_7$1(ctx) {
    	let t0_value = /*time*/ ctx[21].year + "";
    	let t0;
    	let t1;

    	let t2_value = (!(/*time*/ ctx[21].month || /*time*/ ctx[21].day)
    	? /*time*/ ctx[21].annotation
    	: '') + "";

    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text$1(t0_value);
    			t1 = text$1("");
    			t2 = text$1(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t0_value !== (t0_value = /*time*/ ctx[21].year + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*contents*/ 2 && t2_value !== (t2_value = (!(/*time*/ ctx[21].month || /*time*/ ctx[21].day)
    			? /*time*/ ctx[21].annotation
    			: '') + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(144:24) {#if time.year}",
    		ctx
    	});

    	return block;
    }

    // (147:24) {#if time.month}
    function create_if_block_6$1(ctx) {
    	let t0_value = /*time*/ ctx[21].month + "";
    	let t0;
    	let t1;
    	let t2_value = (!/*time*/ ctx[21].day ? /*time*/ ctx[21].annotation : '') + "";
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text$1(t0_value);
    			t1 = text$1("");
    			t2 = text$1(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t0_value !== (t0_value = /*time*/ ctx[21].month + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*contents*/ 2 && t2_value !== (t2_value = (!/*time*/ ctx[21].day ? /*time*/ ctx[21].annotation : '') + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(147:24) {#if time.month}",
    		ctx
    	});

    	return block;
    }

    // (150:24) {#if time.day}
    function create_if_block_5$2(ctx) {
    	let t0_value = /*time*/ ctx[21].day + "";
    	let t0;
    	let t1;
    	let t2_value = /*time*/ ctx[21].annotation + "";
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text$1(t0_value);
    			t1 = text$1("");
    			t2 = text$1(t2_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t0_value !== (t0_value = /*time*/ ctx[21].day + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*contents*/ 2 && t2_value !== (t2_value = /*time*/ ctx[21].annotation + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(150:24) {#if time.day}",
    		ctx
    	});

    	return block;
    }

    // (141:20) {#each article.specs.times as time, i}
    function create_each_block_4(ctx) {
    	let time;
    	let t0;
    	let t1;
    	let time_datetime_value;
    	let t2;

    	let t3_value = (/*i*/ ctx[12] + 1 != /*article*/ ctx[10].specs.times.length
    	? ', '
    	: '') + "";

    	let t3;
    	let if_block0 = /*time*/ ctx[21].year && create_if_block_7$1(ctx);
    	let if_block1 = /*time*/ ctx[21].month && create_if_block_6$1(ctx);
    	let if_block2 = /*time*/ ctx[21].day && create_if_block_5$2(ctx);

    	const block = {
    		c: function create() {
    			time = element("time");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			t3 = text$1(t3_value);
    			attr_dev(time, "class", "break-scope svelte-1fj2vis");

    			attr_dev(time, "datetime", time_datetime_value = (/*time*/ ctx[21].year
    			? ("0000" + /*time*/ ctx[21].year).slice(-4)
    			: "") + (/*time*/ ctx[21].month
    			? "-" + ("00" + /*time*/ ctx[21].month).slice(-2)
    			: "") + (/*time*/ ctx[21].day
    			? "-" + ("00" + /*time*/ ctx[21].day).slice(-2)
    			: ""));

    			add_location(time, file$c, 142, 22, 5533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, time, anchor);
    			if (if_block0) if_block0.m(time, null);
    			append_dev(time, t0);
    			if (if_block1) if_block1.m(time, null);
    			append_dev(time, t1);
    			if (if_block2) if_block2.m(time, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*time*/ ctx[21].year) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_7$1(ctx);
    					if_block0.c();
    					if_block0.m(time, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*time*/ ctx[21].month) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_6$1(ctx);
    					if_block1.c();
    					if_block1.m(time, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*time*/ ctx[21].day) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_5$2(ctx);
    					if_block2.c();
    					if_block2.m(time, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*contents*/ 2 && time_datetime_value !== (time_datetime_value = (/*time*/ ctx[21].year
    			? ("0000" + /*time*/ ctx[21].year).slice(-4)
    			: "") + (/*time*/ ctx[21].month
    			? "-" + ("00" + /*time*/ ctx[21].month).slice(-2)
    			: "") + (/*time*/ ctx[21].day
    			? "-" + ("00" + /*time*/ ctx[21].day).slice(-2)
    			: ""))) {
    				attr_dev(time, "datetime", time_datetime_value);
    			}

    			if (dirty[0] & /*contents*/ 2 && t3_value !== (t3_value = (/*i*/ ctx[12] + 1 != /*article*/ ctx[10].specs.times.length
    			? ', '
    			: '') + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(time);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_4.name,
    		type: "each",
    		source: "(141:20) {#each article.specs.times as time, i}",
    		ctx
    	});

    	return block;
    }

    // (158:16) {#if article.specs.platforms}
    function create_if_block_3$2(ctx) {
    	let div;
    	let span;
    	let t1;
    	let each_value_3 = /*article*/ ctx[10].specs.platforms;
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span, "class", "tag svelte-1fj2vis");
    			add_location(span, file$c, 159, 20, 6440);
    			attr_dev(div, "class", "platforms svelte-1fj2vis");
    			add_location(div, file$c, 158, 18, 6396);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2) {
    				each_value_3 = /*article*/ ctx[10].specs.platforms;
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(158:16) {#if article.specs.platforms}",
    		ctx
    	});

    	return block;
    }

    // (161:20) {#each article.specs.platforms as platform, i}
    function create_each_block_3(ctx) {
    	let span;
    	let t0_value = /*platform*/ ctx[19].name + "";
    	let t0;
    	let t1;
    	let t2_value = (/*platform*/ ctx[19].version || "") + "";
    	let t2;
    	let t3_value = (/*platform*/ ctx[19].orLater ? "" : "") + "";
    	let t3;

    	let t4_value = (/*i*/ ctx[12] + 1 != /*article*/ ctx[10].specs.platforms.length
    	? ','
    	: '') + "";

    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text$1(t0_value);
    			t1 = space();
    			t2 = text$1(t2_value);
    			t3 = text$1(t3_value);
    			t4 = text$1(t4_value);
    			t5 = space();
    			attr_dev(span, "class", "break-scope svelte-1fj2vis");
    			add_location(span, file$c, 161, 22, 6565);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    			append_dev(span, t3);
    			append_dev(span, t4);
    			append_dev(span, t5);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t0_value !== (t0_value = /*platform*/ ctx[19].name + "")) set_data_dev(t0, t0_value);
    			if (dirty[0] & /*contents*/ 2 && t2_value !== (t2_value = (/*platform*/ ctx[19].version || "") + "")) set_data_dev(t2, t2_value);
    			if (dirty[0] & /*contents*/ 2 && t3_value !== (t3_value = (/*platform*/ ctx[19].orLater ? "" : "") + "")) set_data_dev(t3, t3_value);

    			if (dirty[0] & /*contents*/ 2 && t4_value !== (t4_value = (/*i*/ ctx[12] + 1 != /*article*/ ctx[10].specs.platforms.length
    			? ','
    			: '') + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(161:20) {#each article.specs.platforms as platform, i}",
    		ctx
    	});

    	return block;
    }

    // (174:12) {#if button.popup}
    function create_if_block_1$2(ctx) {
    	let div;
    	let t_value = /*button*/ ctx[13].popup + "";
    	let t;
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text$1(t_value);
    			attr_dev(div, "class", div_class_value = "popup " + (/*button*/ ctx[13].disabled ? 'disabled' : '') + " svelte-1fj2vis");
    			add_location(div, file$c, 174, 14, 7039);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*button*/ ctx[13].popup + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*contents*/ 2 && div_class_value !== (div_class_value = "popup " + (/*button*/ ctx[13].disabled ? 'disabled' : '') + " svelte-1fj2vis")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(174:12) {#if button.popup}",
    		ctx
    	});

    	return block;
    }

    // (182:14) {:else}
    function create_else_block$2(ctx) {
    	let t_value = /*button*/ ctx[13].title + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*button*/ ctx[13].title + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(182:14) {:else}",
    		ctx
    	});

    	return block;
    }

    // (178:14) {#if Array.isArray(button.title)}
    function create_if_block$6(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*button*/ ctx[13].title;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2) {
    				each_value_2 = /*button*/ ctx[13].title;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(178:14) {#if Array.isArray(button.title)}",
    		ctx
    	});

    	return block;
    }

    // (179:16) {#each button.title as title}
    function create_each_block_2$1(ctx) {
    	let span;
    	let t_value = /*title*/ ctx[16] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "break-scope svelte-1fj2vis");
    			add_location(span, file$c, 179, 18, 7396);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contents*/ 2 && t_value !== (t_value = /*title*/ ctx[16] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(179:16) {#each button.title as title}",
    		ctx
    	});

    	return block;
    }

    // (177:12) <Button target={button.target} bg="#0a6afa" width="calc(var(--standardWidth) * 0.45)" disabled={button.disabled} spaMode={button.spaMode}>
    function create_default_slot_2$1(ctx) {
    	let show_if;
    	let t;

    	function select_block_type_4(ctx, dirty) {
    		if (show_if == null || dirty[0] & /*contents*/ 2) show_if = !!Array.isArray(/*button*/ ctx[13].title);
    		if (show_if) return create_if_block$6;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type_4(ctx, [-1, -1]);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_4(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(177:12) <Button target={button.target} bg=\\\"#0a6afa\\\" width=\\\"calc(var(--standardWidth) * 0.45)\\\" disabled={button.disabled} spaMode={button.spaMode}>",
    		ctx
    	});

    	return block;
    }

    // (173:10) {#each article.buttons as button}
    function create_each_block_1$1(ctx) {
    	let t;
    	let button;
    	let current;
    	let if_block = /*button*/ ctx[13].popup && create_if_block_1$2(ctx);

    	button = new Button({
    			props: {
    				target: /*button*/ ctx[13].target,
    				bg: "#0a6afa",
    				width: "calc(var(--standardWidth) * 0.45)",
    				disabled: /*button*/ ctx[13].disabled,
    				spaMode: /*button*/ ctx[13].spaMode,
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*button*/ ctx[13].popup) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const button_changes = {};
    			if (dirty[0] & /*contents*/ 2) button_changes.target = /*button*/ ctx[13].target;
    			if (dirty[0] & /*contents*/ 2) button_changes.disabled = /*button*/ ctx[13].disabled;
    			if (dirty[0] & /*contents*/ 2) button_changes.spaMode = /*button*/ ctx[13].spaMode;

    			if (dirty[0] & /*contents*/ 2 | dirty[1] & /*$$scope*/ 64) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(173:10) {#each article.buttons as button}",
    		ctx
    	});

    	return block;
    }

    // (64:4) <SwiperSlide>
    function create_default_slot_1$1(ctx) {
    	let div6;
    	let div2;
    	let div0;
    	let span0;
    	let show_if_2;
    	let t0;
    	let span1;
    	let show_if_1;
    	let t1;
    	let div1;
    	let t2;
    	let div4;
    	let t3;
    	let div3;
    	let article;
    	let show_if;
    	let t4;
    	let t5;
    	let div5;
    	let t6;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (show_if_2 == null || dirty[0] & /*contents*/ 2) show_if_2 = !!Array.isArray(/*article*/ ctx[10].subtitle);
    		if (show_if_2) return create_if_block_14;
    		return create_else_block_4;
    	}

    	let current_block_type = select_block_type(ctx, [-1, -1]);
    	let if_block0 = current_block_type(ctx);

    	function select_block_type_1(ctx, dirty) {
    		if (show_if_1 == null || dirty[0] & /*contents*/ 2) show_if_1 = !!Array.isArray(/*article*/ ctx[10].title);
    		if (show_if_1) return create_if_block_13;
    		return create_else_block_3;
    	}

    	let current_block_type_1 = select_block_type_1(ctx, [-1, -1]);
    	let if_block1 = current_block_type_1(ctx);
    	let each_value_7 = /*article*/ ctx[10].buttons;
    	validate_each_argument(each_value_7);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_7.length; i += 1) {
    		each_blocks_1[i] = create_each_block_7(get_each_context_7(ctx, each_value_7, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let if_block2 = /*article*/ ctx[10].slides && create_if_block_9(ctx);

    	function select_block_type_3(ctx, dirty) {
    		if (show_if == null || dirty[0] & /*contents*/ 2) show_if = !!Array.isArray(/*article*/ ctx[10].description);
    		if (show_if) return create_if_block_8;
    		return create_else_block_1;
    	}

    	let current_block_type_2 = select_block_type_3(ctx, [-1, -1]);
    	let if_block3 = current_block_type_2(ctx);
    	let if_block4 = /*article*/ ctx[10].specs && create_if_block_2$2(ctx);
    	let each_value_1 = /*article*/ ctx[10].buttons;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			if_block0.c();
    			t0 = space();
    			span1 = element("span");
    			if_block1.c();
    			t1 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t2 = space();
    			div4 = element("div");
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div3 = element("div");
    			article = element("article");
    			if_block3.c();
    			t4 = space();
    			if (if_block4) if_block4.c();
    			t5 = space();
    			div5 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			attr_dev(span0, "class", "subtitle svelte-1fj2vis");
    			add_location(span0, file$c, 67, 12, 2677);
    			attr_dev(span1, "class", "title svelte-1fj2vis");
    			add_location(span1, file$c, 76, 12, 2966);
    			attr_dev(div0, "class", "headline svelte-1fj2vis");
    			add_location(div0, file$c, 66, 10, 2642);
    			attr_dev(div1, "class", "buttons pc svelte-1fj2vis");
    			add_location(div1, file$c, 86, 10, 3254);
    			attr_dev(div2, "class", "title-container svelte-1fj2vis");
    			add_location(div2, file$c, 65, 8, 2602);
    			attr_dev(article, "class", "svelte-1fj2vis");
    			add_location(article, file$c, 126, 12, 4878);
    			attr_dev(div3, "class", "description svelte-1fj2vis");
    			add_location(div3, file$c, 125, 10, 4840);
    			attr_dev(div4, "class", "description-container svelte-1fj2vis");
    			add_location(div4, file$c, 103, 8, 3942);
    			attr_dev(div5, "class", "buttons mobile svelte-1fj2vis");
    			add_location(div5, file$c, 171, 8, 6921);
    			attr_dev(div6, "class", "slide-container svelte-1fj2vis");
    			set_style(div6, "--backgroundColor", /*backgroundColor*/ ctx[4][/*i*/ ctx[12]]);
    			set_style(div6, "--themeColor", /*contents*/ ctx[1].articles[/*i*/ ctx[12]].themeColor);
    			add_location(div6, file$c, 64, 6, 2468);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div2);
    			append_dev(div2, div0);
    			append_dev(div0, span0);
    			if_block0.m(span0, null);
    			append_dev(div0, t0);
    			append_dev(div0, span1);
    			if_block1.m(span1, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div1, null);
    			}

    			append_dev(div6, t2);
    			append_dev(div6, div4);
    			if (if_block2) if_block2.m(div4, null);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, article);
    			if_block3.m(article, null);
    			append_dev(div3, t4);
    			if (if_block4) if_block4.m(div3, null);
    			append_dev(div6, t5);
    			append_dev(div6, div5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div5, null);
    			}

    			insert_dev(target, t6, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(span0, null);
    				}
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx, dirty)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type_1(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(span1, null);
    				}
    			}

    			if (dirty[0] & /*contents*/ 2) {
    				each_value_7 = /*article*/ ctx[10].buttons;
    				validate_each_argument(each_value_7);
    				let i;

    				for (i = 0; i < each_value_7.length; i += 1) {
    					const child_ctx = get_each_context_7(ctx, each_value_7, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_7(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(div1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_7.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*article*/ ctx[10].slides) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*contents*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_9(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div4, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (current_block_type_2 === (current_block_type_2 = select_block_type_3(ctx, dirty)) && if_block3) {
    				if_block3.p(ctx, dirty);
    			} else {
    				if_block3.d(1);
    				if_block3 = current_block_type_2(ctx);

    				if (if_block3) {
    					if_block3.c();
    					if_block3.m(article, null);
    				}
    			}

    			if (/*article*/ ctx[10].specs) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);
    				} else {
    					if_block4 = create_if_block_2$2(ctx);
    					if_block4.c();
    					if_block4.m(div3, null);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (dirty[0] & /*contents*/ 2) {
    				each_value_1 = /*article*/ ctx[10].buttons;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div5, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty[0] & /*contents*/ 2) {
    				set_style(div6, "--themeColor", /*contents*/ ctx[1].articles[/*i*/ ctx[12]].themeColor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_7.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(if_block2);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(if_block2);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if_block0.d();
    			if_block1.d();
    			destroy_each(each_blocks_1, detaching);
    			if (if_block2) if_block2.d();
    			if_block3.d();
    			if (if_block4) if_block4.d();
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(64:4) <SwiperSlide>",
    		ctx
    	});

    	return block;
    }

    // (63:2) {#each contents.articles as article, i}
    function create_each_block$4(ctx) {
    	let swiperslide;
    	let current;

    	swiperslide = new SwiperSlide({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(swiperslide.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(swiperslide, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const swiperslide_changes = {};

    			if (dirty[0] & /*contents, globalSettings, standardWidth*/ 7 | dirty[1] & /*$$scope*/ 64) {
    				swiperslide_changes.$$scope = { dirty, ctx };
    			}

    			swiperslide.$set(swiperslide_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(swiperslide.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(swiperslide.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(swiperslide, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(63:2) {#each contents.articles as article, i}",
    		ctx
    	});

    	return block;
    }

    // (48:0) <Swiper   allowSlideNext={false}   allowSlidePrev={false}   allowTouchMove={false}   autoHeight={true}   spaceBetween={0}   slidesPerView={1}   speed={transitionDuration}   loop={true}   loopAdditionalSlides={contents.articles.length - 1}   effect='fade'   fadeEffect={{crossFade: true}}   on:swiper={setControlledSwiper}   on:snapIndexChange={() => window.dispatchEvent(new CustomEvent('slide'))} >
    function create_default_slot$4(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*contents*/ ctx[1].articles;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*backgroundColor, contents, transitionDuration, globalSettings, standardWidth*/ 31) {
    				each_value = /*contents*/ ctx[1].articles;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(48:0) <Swiper   allowSlideNext={false}   allowSlidePrev={false}   allowTouchMove={false}   autoHeight={true}   spaceBetween={0}   slidesPerView={1}   speed={transitionDuration}   loop={true}   loopAdditionalSlides={contents.articles.length - 1}   effect='fade'   fadeEffect={{crossFade: true}}   on:swiper={setControlledSwiper}   on:snapIndexChange={() => window.dispatchEvent(new CustomEvent('slide'))} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let link0;
    	let link1;
    	let link2;
    	let t;
    	let swiper;
    	let current;

    	swiper = new Swiper$2({
    			props: {
    				allowSlideNext: false,
    				allowSlidePrev: false,
    				allowTouchMove: false,
    				autoHeight: true,
    				spaceBetween: 0,
    				slidesPerView: 1,
    				speed: /*transitionDuration*/ ctx[3],
    				loop: true,
    				loopAdditionalSlides: /*contents*/ ctx[1].articles.length - 1,
    				effect: "fade",
    				fadeEffect: { crossFade: true },
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	swiper.$on("swiper", /*setControlledSwiper*/ ctx[5]);
    	swiper.$on("snapIndexChange", /*snapIndexChange_handler_1*/ ctx[8]);

    	const block = {
    		c: function create() {
    			link0 = element("link");
    			link1 = element("link");
    			link2 = element("link");
    			t = space();
    			create_component(swiper.$$.fragment);
    			attr_dev(link0, "rel", "preconnect");
    			attr_dev(link0, "href", "https://p.typekit.net/");
    			attr_dev(link0, "class", "svelte-1fj2vis");
    			add_location(link0, file$c, 42, 2, 1796);
    			attr_dev(link1, "rel", "preload");
    			attr_dev(link1, "href", "/swiper-bundle.min.css");
    			attr_dev(link1, "as", "style");
    			attr_dev(link1, "class", "svelte-1fj2vis");
    			add_location(link1, file$c, 43, 2, 1852);
    			attr_dev(link2, "rel", "stylesheet");
    			attr_dev(link2, "type", "text/css");
    			attr_dev(link2, "href", "/swiper-bundle.min.css");
    			attr_dev(link2, "class", "svelte-1fj2vis");
    			add_location(link2, file$c, 44, 2, 1916);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1$1.head, link0);
    			append_dev(document_1$1.head, link1);
    			append_dev(document_1$1.head, link2);
    			insert_dev(target, t, anchor);
    			mount_component(swiper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const swiper_changes = {};
    			if (dirty[0] & /*contents*/ 2) swiper_changes.loopAdditionalSlides = /*contents*/ ctx[1].articles.length - 1;

    			if (dirty[0] & /*contents, globalSettings, standardWidth*/ 7 | dirty[1] & /*$$scope*/ 64) {
    				swiper_changes.$$scope = { dirty, ctx };
    			}

    			swiper.$set(swiper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(swiper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(swiper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(link0);
    			detach_dev(link1);
    			detach_dev(link2);
    			if (detaching) detach_dev(t);
    			destroy_component(swiper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $sync;
    	validate_store(sync, 'sync');
    	component_subscribe($$self, sync, $$value => $$invalidate(9, $sync = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Slide_description', slots, []);
    	let { pairId, globalSettings, contents, standardWidth } = $$props;

    	const transitionDuration = globalSettings.transitionDuration,
    		backgroundColor = contents.articles.map(v => color(v.themeColor).lightness(95).desaturate(0.3).hex());

    	SwiperCore.use([Controller$2, EffectFade]);

    	const setControlledSwiper = e => {
    		const [swiper] = e.detail;
    		set_store_value(sync, $sync.controlledSwiper = null, $sync);

    		// set Controller swiper instance
    		window.addEventListener('pictureGroup_load', e => {
    			if (e.detail == 'slideHero') {
    				swiper.update();
    				set_store_value(sync, $sync.controlledSwiper = swiper, $sync);
    				dispatchEvent(new CustomEvent('controllee_load', { detail: pairId }));
    			}
    		});
    	};

    	//Adobe font loading
    	addEventListener('pictureGroup_load', e => {
    		if (e.detail == 'slideHero') {
    			(d => {
    				var config = {
    						kitId: 'egn6fhp',
    						scriptTimeout: 3000,
    						async: !0
    					},
    					h = d.documentElement,
    					t = setTimeout(
    						() => {
    							h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
    						},
    						config.scriptTimeout
    					),
    					tk = d.createElement("script"),
    					f = !1,
    					s = d.getElementsByTagName("script")[0],
    					a;

    				h.className += " wf-loading";
    				tk.src = 'https://use.typekit.net/' + config.kitId + '.js';
    				tk.async = !0;

    				tk.onload = tk.onreadystatechange = function () {
    					a = this.readyState;
    					if (f || a && a != "complete" && a != "loaded") return;
    					f = !0;
    					clearTimeout(t);

    					try {
    						Typekit.load(config);
    					} catch(e) {
    						
    					}
    				};

    				s.parentNode.insertBefore(tk, s);
    			})(document);
    		}
    	});

    	const writable_props = ['pairId', 'globalSettings', 'contents', 'standardWidth'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Slide_description> was created with unknown prop '${key}'`);
    	});

    	const snapIndexChange_handler = () => window.dispatchEvent(new CustomEvent('slide'));
    	const snapIndexChange_handler_1 = () => window.dispatchEvent(new CustomEvent('slide'));

    	$$self.$$set = $$props => {
    		if ('pairId' in $$props) $$invalidate(6, pairId = $$props.pairId);
    		if ('globalSettings' in $$props) $$invalidate(0, globalSettings = $$props.globalSettings);
    		if ('contents' in $$props) $$invalidate(1, contents = $$props.contents);
    		if ('standardWidth' in $$props) $$invalidate(2, standardWidth = $$props.standardWidth);
    	};

    	$$self.$capture_state = () => ({
    		Button,
    		Yframe: Youtube_iframe,
    		Swiper: Swiper$2,
    		SwiperSlide,
    		SwiperCore,
    		Controller: Controller$2,
    		EffectFade,
    		sync,
    		Color: color,
    		pairId,
    		globalSettings,
    		contents,
    		standardWidth,
    		transitionDuration,
    		backgroundColor,
    		setControlledSwiper,
    		$sync
    	});

    	$$self.$inject_state = $$props => {
    		if ('pairId' in $$props) $$invalidate(6, pairId = $$props.pairId);
    		if ('globalSettings' in $$props) $$invalidate(0, globalSettings = $$props.globalSettings);
    		if ('contents' in $$props) $$invalidate(1, contents = $$props.contents);
    		if ('standardWidth' in $$props) $$invalidate(2, standardWidth = $$props.standardWidth);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		globalSettings,
    		contents,
    		standardWidth,
    		transitionDuration,
    		backgroundColor,
    		setControlledSwiper,
    		pairId,
    		snapIndexChange_handler,
    		snapIndexChange_handler_1
    	];
    }

    class Slide_description extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$d,
    			create_fragment$d,
    			safe_not_equal,
    			{
    				pairId: 6,
    				globalSettings: 0,
    				contents: 1,
    				standardWidth: 2
    			},
    			null,
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Slide_description",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*pairId*/ ctx[6] === undefined && !('pairId' in props)) {
    			console.warn("<Slide_description> was created without expected prop 'pairId'");
    		}

    		if (/*globalSettings*/ ctx[0] === undefined && !('globalSettings' in props)) {
    			console.warn("<Slide_description> was created without expected prop 'globalSettings'");
    		}

    		if (/*contents*/ ctx[1] === undefined && !('contents' in props)) {
    			console.warn("<Slide_description> was created without expected prop 'contents'");
    		}

    		if (/*standardWidth*/ ctx[2] === undefined && !('standardWidth' in props)) {
    			console.warn("<Slide_description> was created without expected prop 'standardWidth'");
    		}
    	}

    	get pairId() {
    		throw new Error("<Slide_description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pairId(value) {
    		throw new Error("<Slide_description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get globalSettings() {
    		throw new Error("<Slide_description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set globalSettings(value) {
    		throw new Error("<Slide_description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contents() {
    		throw new Error("<Slide_description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Slide_description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get standardWidth() {
    		throw new Error("<Slide_description>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set standardWidth(value) {
    		throw new Error("<Slide_description>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/footer.svelte generated by Svelte v3.43.0 */

    const { Object: Object_1 } = globals;
    const file$b = "src/components/footer.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (42:2) {#if contents.copyright}
    function create_if_block_4$1(ctx) {
    	let section;
    	let div;
    	let show_if;
    	let t0;
    	let span0;
    	let t2;
    	let span1;

    	function select_block_type(ctx, dirty) {
    		if (show_if == null || dirty & /*contents*/ 1) show_if = !!Array.isArray(/*contents*/ ctx[0].copyright);
    		if (show_if) return create_if_block_5$1;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div = element("div");
    			if_block.c();
    			t0 = space();
    			span0 = element("span");
    			span0.textContent = "Hash: 561cbd";
    			t2 = space();
    			span1 = element("span");
    			span1.textContent = "Build: 22/11/24-9:54";
    			attr_dev(span0, "class", "break-scope");
    			add_location(span0, file$b, 51, 8, 2388);
    			attr_dev(span1, "class", "break-scope");
    			add_location(span1, file$b, 52, 8, 2442);
    			add_location(div, file$b, 43, 6, 2046);
    			attr_dev(section, "class", "copyright svelte-13gzqik");
    			add_location(section, file$b, 42, 4, 2012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div);
    			if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, span0);
    			append_dev(div, t2);
    			append_dev(div, span1);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, t0);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(42:2) {#if contents.copyright}",
    		ctx
    	});

    	return block;
    }

    // (49:8) {:else}
    function create_else_block$1(ctx) {
    	let span;
    	let raw_value = /*contents*/ ctx[0].copyright + "";

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "break-scope");
    			add_location(span, file$b, 49, 10, 2306);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			span.innerHTML = raw_value;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && raw_value !== (raw_value = /*contents*/ ctx[0].copyright + "")) span.innerHTML = raw_value;		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(49:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (45:8) {#if Array.isArray(contents.copyright)}
    function create_if_block_5$1(ctx) {
    	let each_1_anchor;
    	let each_value = /*contents*/ ctx[0].copyright;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1) {
    				each_value = /*contents*/ ctx[0].copyright;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(45:8) {#if Array.isArray(contents.copyright)}",
    		ctx
    	});

    	return block;
    }

    // (46:10) {#each contents.copyright as copyright, i}
    function create_each_block$3(ctx) {
    	let span;
    	let html_tag;
    	let raw_value = /*copyright*/ ctx[3] + "";

    	let t_value = (/*i*/ ctx[5] + 1 != /*contents*/ ctx[0].copyright.length
    	? ', '
    	: '') + "";

    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			html_tag = new HtmlTag();
    			t = text$1(t_value);
    			html_tag.a = t;
    			attr_dev(span, "class", "break-scope");
    			add_location(span, file$b, 46, 12, 2165);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			html_tag.m(raw_value, span);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && raw_value !== (raw_value = /*copyright*/ ctx[3] + "")) html_tag.p(raw_value);

    			if (dirty & /*contents*/ 1 && t_value !== (t_value = (/*i*/ ctx[5] + 1 != /*contents*/ ctx[0].copyright.length
    			? ', '
    			: '') + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(46:10) {#each contents.copyright as copyright, i}",
    		ctx
    	});

    	return block;
    }

    // (57:2) {#if contents.codeLicense}
    function create_if_block_1$1(ctx) {
    	let section0;
    	let div0;
    	let t0;
    	let t1_value = /*licenses*/ ctx[1][/*contents*/ ctx[0].codeLicense.license] + "";
    	let t1;

    	let t2_value = (/*contents*/ ctx[0].codeLicense.linkLabel && /*contents*/ ctx[0].codeLicense.url
    	? ' and available at '
    	: '.') + "";

    	let t2;
    	let t3;
    	let t4;
    	let section1;
    	let div1;
    	let t5;
    	let t6_value = /*licenses*/ ctx[1][/*contents*/ ctx[0].codeLicense.license] + "";
    	let t6;
    	let t7;

    	let t8_value = (/*contents*/ ctx[0].codeLicense.linkLabel && /*contents*/ ctx[0].codeLicense.url
    	? ''
    	: '') + "";

    	let t8;
    	let t9;
    	let if_block0 = /*contents*/ ctx[0].codeLicense.linkLabel && /*contents*/ ctx[0].codeLicense.url && create_if_block_3$1(ctx);
    	let if_block1 = /*contents*/ ctx[0].codeLicense.linkLabel && /*contents*/ ctx[0].codeLicense.url && create_if_block_2$1(ctx);

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div0 = element("div");
    			t0 = text$1("The source code of this web site is licensed under a ");
    			t1 = text$1(t1_value);
    			t2 = text$1(t2_value);
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			section1 = element("section");
    			div1 = element("div");
    			t5 = text$1("Web");
    			t6 = text$1(t6_value);
    			t7 = text$1("");
    			t8 = text$1(t8_value);
    			t9 = space();
    			if (if_block1) if_block1.c();
    			add_location(div0, file$b, 58, 6, 2597);
    			attr_dev(section0, "class", "license svelte-13gzqik");
    			add_location(section0, file$b, 57, 4, 2565);
    			add_location(div1, file$b, 66, 6, 3099);
    			attr_dev(section1, "class", "license svelte-13gzqik");
    			add_location(section1, file$b, 65, 4, 3067);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			append_dev(div0, t3);
    			if (if_block0) if_block0.m(div0, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div1);
    			append_dev(div1, t5);
    			append_dev(div1, t6);
    			append_dev(div1, t7);
    			append_dev(div1, t8);
    			append_dev(div1, t9);
    			if (if_block1) if_block1.m(div1, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && t1_value !== (t1_value = /*licenses*/ ctx[1][/*contents*/ ctx[0].codeLicense.license] + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*contents*/ 1 && t2_value !== (t2_value = (/*contents*/ ctx[0].codeLicense.linkLabel && /*contents*/ ctx[0].codeLicense.url
    			? ' and available at '
    			: '.') + "")) set_data_dev(t2, t2_value);

    			if (/*contents*/ ctx[0].codeLicense.linkLabel && /*contents*/ ctx[0].codeLicense.url) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*contents*/ 1 && t6_value !== (t6_value = /*licenses*/ ctx[1][/*contents*/ ctx[0].codeLicense.license] + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*contents*/ 1 && t8_value !== (t8_value = (/*contents*/ ctx[0].codeLicense.linkLabel && /*contents*/ ctx[0].codeLicense.url
    			? ''
    			: '') + "")) set_data_dev(t8, t8_value);

    			if (/*contents*/ ctx[0].codeLicense.linkLabel && /*contents*/ ctx[0].codeLicense.url) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_2$1(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (if_block0) if_block0.d();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(section1);
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(57:2) {#if contents.codeLicense}",
    		ctx
    	});

    	return block;
    }

    // (61:8) {#if contents.codeLicense.linkLabel && contents.codeLicense.url}
    function create_if_block_3$1(ctx) {
    	let a;
    	let t0_value = /*contents*/ ctx[0].codeLicense.linkLabel + "";
    	let t0;
    	let a_href_value;
    	let a_style_value;
    	let t1;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = text$1(t0_value);
    			t1 = text$1(".");
    			attr_dev(a, "href", a_href_value = /*contents*/ ctx[0].codeLicense.url);

    			attr_dev(a, "style", a_style_value = /*contents*/ ctx[0].anchorColor
    			? `color: ${/*contents*/ ctx[0].anchorColor}`
    			: '');

    			add_location(a, file$b, 61, 10, 2877);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t0);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && t0_value !== (t0_value = /*contents*/ ctx[0].codeLicense.linkLabel + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*contents*/ 1 && a_href_value !== (a_href_value = /*contents*/ ctx[0].codeLicense.url)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*contents*/ 1 && a_style_value !== (a_style_value = /*contents*/ ctx[0].anchorColor
    			? `color: ${/*contents*/ ctx[0].anchorColor}`
    			: '')) {
    				attr_dev(a, "style", a_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(61:8) {#if contents.codeLicense.linkLabel && contents.codeLicense.url}",
    		ctx
    	});

    	return block;
    }

    // (69:8) {#if contents.codeLicense.linkLabel && contents.codeLicense.url}
    function create_if_block_2$1(ctx) {
    	let a;
    	let t0_value = /*contents*/ ctx[0].codeLicense.linkLabel + "";
    	let t0;
    	let a_href_value;
    	let a_style_value;
    	let t1;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = text$1(t0_value);
    			t1 = text$1("");
    			attr_dev(a, "href", a_href_value = /*contents*/ ctx[0].codeLicense.url);

    			attr_dev(a, "style", a_style_value = /*contents*/ ctx[0].anchorColor
    			? `color: ${/*contents*/ ctx[0].anchorColor}`
    			: '');

    			add_location(a, file$b, 69, 10, 3343);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t0);
    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && t0_value !== (t0_value = /*contents*/ ctx[0].codeLicense.linkLabel + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*contents*/ 1 && a_href_value !== (a_href_value = /*contents*/ ctx[0].codeLicense.url)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*contents*/ 1 && a_style_value !== (a_style_value = /*contents*/ ctx[0].anchorColor
    			? `color: ${/*contents*/ ctx[0].anchorColor}`
    			: '')) {
    				attr_dev(a, "style", a_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(69:8) {#if contents.codeLicense.linkLabel && contents.codeLicense.url}",
    		ctx
    	});

    	return block;
    }

    // (75:2) {#if contents.assetsLicense.ccType}
    function create_if_block$5(ctx) {
    	let section0;
    	let div0;
    	let a0;
    	let img0;
    	let img0_src_value;
    	let a0_href_value;
    	let t0;
    	let a1;
    	let t1;

    	let t2_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/by/i)
    	? 'Attribution'
    	: '') + "";

    	let t2;

    	let t3_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 1
    	? '-'
    	: '') + "";

    	let t3;

    	let t4_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/nc/i)
    	? 'NonCommercial'
    	: '') + "";

    	let t4;

    	let t5_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 2
    	? '-'
    	: '') + "";

    	let t5;

    	let t6_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/nd/i)
    	? 'NoDerivatives'
    	: '') + "";

    	let t6;

    	let t7_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 3
    	? '-'
    	: '') + "";

    	let t7;

    	let t8_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/sa/i)
    	? 'ShareAlike'
    	: '') + "";

    	let t8;
    	let t9;
    	let a1_href_value;
    	let a1_style_value;
    	let t10;
    	let t11;
    	let section1;
    	let div1;
    	let a2;
    	let img1;
    	let img1_src_value;
    	let a2_href_value;
    	let t12;
    	let a3;
    	let t13;

    	let t14_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/by/i)
    	? ''
    	: '') + "";

    	let t14;

    	let t15_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 1
    	? ' - '
    	: '') + "";

    	let t15;

    	let t16_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/nc/i)
    	? ''
    	: '') + "";

    	let t16;

    	let t17_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 2
    	? ' - '
    	: '') + "";

    	let t17;

    	let t18_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/nd/i)
    	? ''
    	: '') + "";

    	let t18;

    	let t19_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 3
    	? ' - '
    	: '') + "";

    	let t19;

    	let t20_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/sa/i)
    	? ''
    	: '') + "";

    	let t20;
    	let t21;
    	let a3_style_value;
    	let t22;

    	const block = {
    		c: function create() {
    			section0 = element("section");
    			div0 = element("div");
    			a0 = element("a");
    			img0 = element("img");
    			t0 = text$1("All non-source code resources such as images and videos are licensed under a ");
    			a1 = element("a");
    			t1 = text$1("Creative Commons ");
    			t2 = text$1(t2_value);
    			t3 = text$1(t3_value);
    			t4 = text$1(t4_value);
    			t5 = text$1(t5_value);
    			t6 = text$1(t6_value);
    			t7 = text$1(t7_value);
    			t8 = text$1(t8_value);
    			t9 = text$1(" 4.0 International License");
    			t10 = text$1(".");
    			t11 = space();
    			section1 = element("section");
    			div1 = element("div");
    			a2 = element("a");
    			img1 = element("img");
    			t12 = text$1(" ");
    			a3 = element("a");
    			t13 = text$1(" ");
    			t14 = text$1(t14_value);
    			t15 = text$1(t15_value);
    			t16 = text$1(t16_value);
    			t17 = text$1(t17_value);
    			t18 = text$1(t18_value);
    			t19 = text$1(t19_value);
    			t20 = text$1(t20_value);
    			t21 = text$1(" 4.0  ");
    			t22 = text$1("");
    			attr_dev(img0, "alt", "Creative Commons License");
    			set_style(img0, "border-width", "0");
    			set_style(img0, "display", "inline-block");
    			set_style(img0, "vertical-align", "middle");
    			set_style(img0, "margin-right", "1ch");
    			if (!src_url_equal(img0.src, img0_src_value = "https://i.creativecommons.org/l/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/80x15.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "width", "80");
    			attr_dev(img0, "height", "15");
    			attr_dev(img0, "loading", "lazy");
    			add_location(img0, file$b, 77, 105, 3743);
    			attr_dev(a0, "rel", "license");
    			attr_dev(a0, "href", a0_href_value = "http://creativecommons.org/licenses/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/");
    			add_location(a0, file$b, 77, 8, 3646);
    			attr_dev(a1, "rel", "license");
    			attr_dev(a1, "href", a1_href_value = "http://creativecommons.org/licenses/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/");

    			attr_dev(a1, "style", a1_style_value = /*contents*/ ctx[0].anchorColor
    			? `color: ${/*contents*/ ctx[0].anchorColor}`
    			: '');

    			add_location(a1, file$b, 77, 430, 4068);
    			add_location(div0, file$b, 76, 6, 3632);
    			attr_dev(section0, "class", "creative-commons svelte-13gzqik");
    			add_location(section0, file$b, 75, 4, 3591);
    			attr_dev(img1, "alt", "");
    			set_style(img1, "border-width", "0");
    			set_style(img1, "display", "inline-block");
    			set_style(img1, "vertical-align", "middle");
    			set_style(img1, "margin-right", "1ch");
    			if (!src_url_equal(img1.src, img1_src_value = "https://i.creativecommons.org/l/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/80x15.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "width", "80");
    			attr_dev(img1, "height", "15");
    			attr_dev(img1, "loading", "lazy");
    			add_location(img1, file$b, 82, 113, 4941);
    			attr_dev(a2, "rel", "license");
    			attr_dev(a2, "href", a2_href_value = "https://creativecommons.org/licenses/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/deed.ja");
    			add_location(a2, file$b, 82, 8, 4836);
    			attr_dev(a3, "rel", "license");
    			attr_dev(a3, "href", "https://creativecommons.org/licenses/by-nd/4.0/deed.ja");

    			attr_dev(a3, "style", a3_style_value = /*contents*/ ctx[0].anchorColor
    			? `color: ${/*contents*/ ctx[0].anchorColor}`
    			: '');

    			add_location(a3, file$b, 82, 381, 5209);
    			add_location(div1, file$b, 81, 6, 4822);
    			attr_dev(section1, "class", "creative-commons svelte-13gzqik");
    			add_location(section1, file$b, 80, 4, 4781);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img0);
    			append_dev(div0, t0);
    			append_dev(div0, a1);
    			append_dev(a1, t1);
    			append_dev(a1, t2);
    			append_dev(a1, t3);
    			append_dev(a1, t4);
    			append_dev(a1, t5);
    			append_dev(a1, t6);
    			append_dev(a1, t7);
    			append_dev(a1, t8);
    			append_dev(a1, t9);
    			append_dev(div0, t10);
    			insert_dev(target, t11, anchor);
    			insert_dev(target, section1, anchor);
    			append_dev(section1, div1);
    			append_dev(div1, a2);
    			append_dev(a2, img1);
    			append_dev(div1, t12);
    			append_dev(div1, a3);
    			append_dev(a3, t13);
    			append_dev(a3, t14);
    			append_dev(a3, t15);
    			append_dev(a3, t16);
    			append_dev(a3, t17);
    			append_dev(a3, t18);
    			append_dev(a3, t19);
    			append_dev(a3, t20);
    			append_dev(a3, t21);
    			append_dev(div1, t22);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && !src_url_equal(img0.src, img0_src_value = "https://i.creativecommons.org/l/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/80x15.png")) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty & /*contents*/ 1 && a0_href_value !== (a0_href_value = "http://creativecommons.org/licenses/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/")) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*contents*/ 1 && t2_value !== (t2_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/by/i)
    			? 'Attribution'
    			: '') + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*contents*/ 1 && t3_value !== (t3_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 1
    			? '-'
    			: '') + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*contents*/ 1 && t4_value !== (t4_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/nc/i)
    			? 'NonCommercial'
    			: '') + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*contents*/ 1 && t5_value !== (t5_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 2
    			? '-'
    			: '') + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*contents*/ 1 && t6_value !== (t6_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/nd/i)
    			? 'NoDerivatives'
    			: '') + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*contents*/ 1 && t7_value !== (t7_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 3
    			? '-'
    			: '') + "")) set_data_dev(t7, t7_value);

    			if (dirty & /*contents*/ 1 && t8_value !== (t8_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/sa/i)
    			? 'ShareAlike'
    			: '') + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*contents*/ 1 && a1_href_value !== (a1_href_value = "http://creativecommons.org/licenses/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/")) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*contents*/ 1 && a1_style_value !== (a1_style_value = /*contents*/ ctx[0].anchorColor
    			? `color: ${/*contents*/ ctx[0].anchorColor}`
    			: '')) {
    				attr_dev(a1, "style", a1_style_value);
    			}

    			if (dirty & /*contents*/ 1 && !src_url_equal(img1.src, img1_src_value = "https://i.creativecommons.org/l/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/80x15.png")) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			if (dirty & /*contents*/ 1 && a2_href_value !== (a2_href_value = "https://creativecommons.org/licenses/" + /*contents*/ ctx[0].assetsLicense.ccType + "/4.0/deed.ja")) {
    				attr_dev(a2, "href", a2_href_value);
    			}

    			if (dirty & /*contents*/ 1 && t14_value !== (t14_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/by/i)
    			? ''
    			: '') + "")) set_data_dev(t14, t14_value);

    			if (dirty & /*contents*/ 1 && t15_value !== (t15_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 1
    			? ' - '
    			: '') + "")) set_data_dev(t15, t15_value);

    			if (dirty & /*contents*/ 1 && t16_value !== (t16_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/nc/i)
    			? ''
    			: '') + "")) set_data_dev(t16, t16_value);

    			if (dirty & /*contents*/ 1 && t17_value !== (t17_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 2
    			? ' - '
    			: '') + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*contents*/ 1 && t18_value !== (t18_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/nd/i)
    			? ''
    			: '') + "")) set_data_dev(t18, t18_value);

    			if (dirty & /*contents*/ 1 && t19_value !== (t19_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/-/gi).length >= 3
    			? ' - '
    			: '') + "")) set_data_dev(t19, t19_value);

    			if (dirty & /*contents*/ 1 && t20_value !== (t20_value = (/*contents*/ ctx[0].assetsLicense.ccType.match(/sa/i)
    			? ''
    			: '') + "")) set_data_dev(t20, t20_value);

    			if (dirty & /*contents*/ 1 && a3_style_value !== (a3_style_value = /*contents*/ ctx[0].anchorColor
    			? `color: ${/*contents*/ ctx[0].anchorColor}`
    			: '')) {
    				attr_dev(a3, "style", a3_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t11);
    			if (detaching) detach_dev(section1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(75:2) {#if contents.assetsLicense.ccType}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let footer;
    	let t0;
    	let t1;
    	let footer_style_value;
    	let if_block0 = /*contents*/ ctx[0].copyright && create_if_block_4$1(ctx);
    	let if_block1 = /*contents*/ ctx[0].codeLicense && create_if_block_1$1(ctx);
    	let if_block2 = /*contents*/ ctx[0].assetsLicense.ccType && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();

    			attr_dev(footer, "style", footer_style_value = "--itemsCount: " + /*func*/ ctx[2]() + ";" + (/*contents*/ ctx[0].transparent || /*contents*/ ctx[0].backgroundColor
    			? `--ui-bg: ${/*contents*/ ctx[0].transparent
				? "transparent"
				: /*contents*/ ctx[0].backgroundColor};`
    			: ''));

    			attr_dev(footer, "class", "svelte-13gzqik");
    			add_location(footer, file$b, 40, 0, 1702);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);
    			if (if_block0) if_block0.m(footer, null);
    			append_dev(footer, t0);
    			if (if_block1) if_block1.m(footer, null);
    			append_dev(footer, t1);
    			if (if_block2) if_block2.m(footer, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*contents*/ ctx[0].copyright) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					if_block0.m(footer, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*contents*/ ctx[0].codeLicense) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$1(ctx);
    					if_block1.c();
    					if_block1.m(footer, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*contents*/ ctx[0].assetsLicense.ccType) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block$5(ctx);
    					if_block2.c();
    					if_block2.m(footer, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty & /*contents*/ 1 && footer_style_value !== (footer_style_value = "--itemsCount: " + /*func*/ ctx[2]() + ";" + (/*contents*/ ctx[0].transparent || /*contents*/ ctx[0].backgroundColor
    			? `--ui-bg: ${/*contents*/ ctx[0].transparent
				? "transparent"
				: /*contents*/ ctx[0].backgroundColor};`
    			: ''))) {
    				attr_dev(footer, "style", footer_style_value);
    			}
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Footer', slots, []);
    	let { contents } = $$props;

    	const licenses = {
    		'afl-3.0': 'Academic Free License v3.0',
    		'apache-2.0': 'Apache license 2.0',
    		'artistic-2.0': 'Artistic license 2.0',
    		'bsl-1.0': 'Boost Software License 1.0',
    		'bsd-2-clause': 'BSD 2-clause "Simplified" license',
    		'bsd-3-clause': 'BSD 3-clause "New" or "Revised" license',
    		'bsd-3-clause-clear': 'BSD 3-clause Clear license',
    		'cc': 'Creative Commons license family',
    		'cc0-1.0': 'Creative Commons Zero v1.0 Universal',
    		'cc-by-4.0': 'Creative Commons Attribution 4.0',
    		'cc-by-sa-4.0': 'Creative Commons Attribution Share Alike 4.0',
    		'wtfpl': 'Do What The F*ck You Want To Public License',
    		'ecl-2.0': 'Educational Community License v2.0',
    		'epl-1.0': 'Eclipse Public License 1.0',
    		'epl-2.0': 'Eclipse Public License 2.0',
    		'eupl-1.1': 'European Union Public License 1.1',
    		'agpl-3.0': 'GNU Affero General Public License v3.0',
    		'gpl': 'GNU General Public License family',
    		'gpl-2.0': 'GNU General Public License v2.0',
    		'gpl-3.0': 'GNU General Public License v3.0',
    		'lgpl': 'GNU Lesser General Public License family',
    		'lgpl-2.1': 'GNU Lesser General Public License v2.1',
    		'lgpl-3.0': 'GNU Lesser General Public License v3.0',
    		'isc': 'ISC',
    		'lppl-1.3c': 'LaTeX Project Public License v1.3c',
    		'ms-pl': 'Microsoft Public License',
    		'mit': 'MIT',
    		'mpl-2.0': 'Mozilla Public License 2.0',
    		'osl-3.0': 'Open Software License 3.0',
    		'postgresql': 'PostgreSQL License',
    		'ofl-1.1': 'SIL Open Font License 1.1',
    		'ncsa': 'University of Illinois/NCSA Open Source License',
    		'unlicense': 'The Unlicense',
    		'zlib': 'zLib License'
    	};

    	const writable_props = ['contents'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	const func = () => {
    		let count = 0;
    		Object.keys(contents).forEach(v => count += v == 'copyright' ? 1 : 2);
    		return count;
    	};

    	$$self.$$set = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    	};

    	$$self.$capture_state = () => ({ contents, licenses });

    	$$self.$inject_state = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [contents, licenses, func];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { contents: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*contents*/ ctx[0] === undefined && !('contents' in props)) {
    			console.warn("<Footer> was created without expected prop 'contents'");
    		}
    	}

    	get contents() {
    		throw new Error("<Footer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Footer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/components/cards.svelte generated by Svelte v3.43.0 */
    const file$a = "src/components/cards.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (62:10) {#if card.imageId}
    function create_if_block$4(ctx) {
    	let div;
    	let picture;
    	let current;

    	picture = new Picture({
    			props: {
    				imgClass: "card_left-img card_img",
    				contents: /*contents*/ ctx[0],
    				globalSettings: /*globalSettings*/ ctx[1],
    				imageId: /*card*/ ctx[11].imageId,
    				sizes: "(min-aspect-ratio: 16/9) " + /*standardWidth*/ ctx[2] / 3 / 3 + "vw, " + /*standardWidth*/ ctx[2] / 2 / 3 + "vw, (max-aspect-ratio: 1/1) " + /*standardWidth*/ ctx[2] * 0.8 / 3 + "vw, (max-aspect-ratio: 3/4) " + /*standardWidth*/ ctx[2] / 3 + "vw",
    				width: "1",
    				height: "1"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(picture.$$.fragment);
    			attr_dev(div, "class", "left svelte-uyh0sc");
    			add_location(div, file$a, 62, 12, 2618);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(picture, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const picture_changes = {};
    			if (dirty & /*contents*/ 1) picture_changes.contents = /*contents*/ ctx[0];
    			if (dirty & /*globalSettings*/ 2) picture_changes.globalSettings = /*globalSettings*/ ctx[1];
    			if (dirty & /*contents*/ 1) picture_changes.imageId = /*card*/ ctx[11].imageId;
    			if (dirty & /*standardWidth*/ 4) picture_changes.sizes = "(min-aspect-ratio: 16/9) " + /*standardWidth*/ ctx[2] / 3 / 3 + "vw, " + /*standardWidth*/ ctx[2] / 2 / 3 + "vw, (max-aspect-ratio: 1/1) " + /*standardWidth*/ ctx[2] * 0.8 / 3 + "vw, (max-aspect-ratio: 3/4) " + /*standardWidth*/ ctx[2] / 3 + "vw";
    			picture.$set(picture_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(picture.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(picture.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(picture);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(62:10) {#if card.imageId}",
    		ctx
    	});

    	return block;
    }

    // (70:14) {#each card.post as post}
    function create_each_block_2(ctx) {
    	let span;
    	let t_value = /*post*/ ctx[17] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "svelte-uyh0sc");
    			add_location(span, file$a, 70, 16, 3186);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*contents*/ 1 && t_value !== (t_value = /*post*/ ctx[17] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(70:14) {#each card.post as post}",
    		ctx
    	});

    	return block;
    }

    // (81:10) {#each card.accounts as account}
    function create_each_block_1(ctx) {
    	let a;
    	let img;
    	let img_src_value;
    	let img_alt_value;
    	let img_width_value;
    	let img_height_value;
    	let t0;
    	let span;
    	let t1_value = /*account*/ ctx[14].id + "";
    	let t1;
    	let t2;
    	let a_class_value;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			t0 = space();
    			span = element("span");
    			t1 = text$1(t1_value);
    			t2 = space();

    			if (!src_url_equal(img.src, img_src_value = "" + (/*globalSettings*/ ctx[1].imageDirectory + (/*account*/ ctx[14].name == 'youtube'
    			? 'youtube-white'
    			: /*account*/ ctx[14].name) + ".svg"))) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "alt", img_alt_value = "" + (/*account*/ ctx[14].name + ""));
    			attr_dev(img, "width", img_width_value = /*socialConsts*/ ctx[7].aspectRatios[/*account*/ ctx[14].name].width);
    			attr_dev(img, "height", img_height_value = /*socialConsts*/ ctx[7].aspectRatios[/*account*/ ctx[14].name].height);
    			attr_dev(img, "class", "svelte-uyh0sc");
    			add_location(img, file$a, 83, 14, 4095);
    			attr_dev(span, "class", "id svelte-uyh0sc");
    			add_location(span, file$a, 84, 14, 4353);
    			attr_dev(a, "class", a_class_value = "social-button " + /*account*/ ctx[14].name + " " + (/*card*/ ctx[11].accounts.length > 2 ? 'iconOnly' : '') + " svelte-uyh0sc");

    			attr_dev(a, "href", a_href_value = /*account*/ ctx[14].customUrl
    			? /*account*/ ctx[14].customUrl
    			: `https://${/*socialConsts*/ ctx[7].urls[/*account*/ ctx[14].name]}/${/*account*/ ctx[14].id}`);

    			set_style(a, "--popupContent", "'" + ((/*account*/ ctx[14].name == 'twitter' ? '@' : '') + /*account*/ ctx[14].id) + "'");
    			add_location(a, file$a, 81, 12, 3795);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    			append_dev(a, t0);
    			append_dev(a, span);
    			append_dev(span, t1);
    			append_dev(a, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*globalSettings, contents*/ 3 && !src_url_equal(img.src, img_src_value = "" + (/*globalSettings*/ ctx[1].imageDirectory + (/*account*/ ctx[14].name == 'youtube'
    			? 'youtube-white'
    			: /*account*/ ctx[14].name) + ".svg"))) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*contents*/ 1 && img_alt_value !== (img_alt_value = "" + (/*account*/ ctx[14].name + ""))) {
    				attr_dev(img, "alt", img_alt_value);
    			}

    			if (dirty & /*contents*/ 1 && img_width_value !== (img_width_value = /*socialConsts*/ ctx[7].aspectRatios[/*account*/ ctx[14].name].width)) {
    				attr_dev(img, "width", img_width_value);
    			}

    			if (dirty & /*contents*/ 1 && img_height_value !== (img_height_value = /*socialConsts*/ ctx[7].aspectRatios[/*account*/ ctx[14].name].height)) {
    				attr_dev(img, "height", img_height_value);
    			}

    			if (dirty & /*contents*/ 1 && t1_value !== (t1_value = /*account*/ ctx[14].id + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*contents*/ 1 && a_class_value !== (a_class_value = "social-button " + /*account*/ ctx[14].name + " " + (/*card*/ ctx[11].accounts.length > 2 ? 'iconOnly' : '') + " svelte-uyh0sc")) {
    				attr_dev(a, "class", a_class_value);
    			}

    			if (dirty & /*contents*/ 1 && a_href_value !== (a_href_value = /*account*/ ctx[14].customUrl
    			? /*account*/ ctx[14].customUrl
    			: `https://${/*socialConsts*/ ctx[7].urls[/*account*/ ctx[14].name]}/${/*account*/ ctx[14].id}`)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*contents*/ 1) {
    				set_style(a, "--popupContent", "'" + ((/*account*/ ctx[14].name == 'twitter' ? '@' : '') + /*account*/ ctx[14].id) + "'");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(81:10) {#each card.accounts as account}",
    		ctx
    	});

    	return block;
    }

    // (32:2) {#each contents.cards as card}
    function create_each_block$2(ctx) {
    	let div9;
    	let div7;
    	let div5;
    	let t0;
    	let div4;
    	let div0;
    	let t1_value = /*card*/ ctx[11].name + "";
    	let t1;
    	let t2;
    	let div1;
    	let t3;
    	let div3;
    	let div2;
    	let t4;
    	let picture0;
    	let div4_class_value;
    	let t5;
    	let div6;
    	let t6;
    	let div8;
    	let picture1;
    	let t7;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*card*/ ctx[11].imageId && create_if_block$4(ctx);
    	let each_value_2 = /*card*/ ctx[11].post;
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	picture0 = new Picture({
    			props: {
    				imgClass: "card_img",
    				contents: /*contents*/ ctx[0],
    				globalSettings: /*globalSettings*/ ctx[1],
    				imageDirectory: /*globalSettings*/ ctx[1].imageDirectory,
    				imageId: /*contents*/ ctx[0].logoImageId,
    				imageExtensionsShort: /*contents*/ ctx[0].logoImageExtensionsShort,
    				sizes: "" + (3 * /*ch*/ ctx[4] + "px"),
    				width: /*contents*/ ctx[0].logoAspectRatio.width,
    				height: /*contents*/ ctx[0].logoAspectRatio.height
    			},
    			$$inline: true
    		});

    	let each_value_1 = /*card*/ ctx[11].accounts;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	picture1 = new Picture({
    			props: {
    				pictureClass: "backface_logo_picture",
    				imgClass: "backface_logo",
    				contents: /*contents*/ ctx[0],
    				globalSettings: /*globalSettings*/ ctx[1],
    				imageDirectory: /*globalSettings*/ ctx[1].imageDirectory,
    				imageId: /*contents*/ ctx[0].backfaceLogoImageId,
    				imageExtensionsShort: /*contents*/ ctx[0].backfaceLogoImageExtensionsShort,
    				width: /*contents*/ ctx[0].backfaceLogoAspectRatio.width,
    				height: /*contents*/ ctx[0].backfaceLogoAspectRatio.height
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div7 = element("div");
    			div5 = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			div4 = element("div");
    			div0 = element("div");
    			t1 = text$1(t1_value);
    			t2 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t3 = space();
    			div3 = element("div");
    			div2 = element("div");
    			t4 = space();
    			create_component(picture0.$$.fragment);
    			t5 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			div8 = element("div");
    			create_component(picture1.$$.fragment);
    			t7 = space();
    			attr_dev(div0, "class", "name svelte-uyh0sc");
    			add_location(div0, file$a, 67, 12, 3063);
    			attr_dev(div1, "class", "post svelte-uyh0sc");
    			add_location(div1, file$a, 68, 12, 3111);
    			set_style(div2, "opacity", "0");
    			set_style(div2, "width", "1ch");
    			add_location(div2, file$a, 74, 14, 3292);
    			attr_dev(div3, "class", "logo svelte-uyh0sc");
    			add_location(div3, file$a, 73, 12, 3259);
    			attr_dev(div4, "class", div4_class_value = "right " + (/*card*/ ctx[11].imageId ? '' : 'noImage') + " svelte-uyh0sc");
    			add_location(div4, file$a, 66, 10, 2999);
    			attr_dev(div5, "class", "upper svelte-uyh0sc");
    			add_location(div5, file$a, 60, 8, 2557);
    			attr_dev(div6, "class", "lower svelte-uyh0sc");
    			add_location(div6, file$a, 79, 8, 3720);
    			attr_dev(div7, "class", "card svelte-uyh0sc");
    			add_location(div7, file$a, 59, 6, 2530);
    			attr_dev(div8, "class", "backface svelte-uyh0sc");
    			add_location(div8, file$a, 91, 6, 4491);
    			attr_dev(div9, "class", "card_wrapper svelte-uyh0sc");
    			set_style(div9, "--backfaceColor", /*card*/ ctx[11].backfaceColor);
    			set_style(div9, "--backfaceLogoBrightness", /*card*/ ctx[11].backfaceLogoBrightness);
    			add_location(div9, file$a, 32, 4, 1082);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div7);
    			append_dev(div7, div5);
    			if (if_block) if_block.m(div5, null);
    			append_dev(div5, t0);
    			append_dev(div5, div4);
    			append_dev(div4, div0);
    			append_dev(div0, t1);
    			append_dev(div4, t2);
    			append_dev(div4, div1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div1, null);
    			}

    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			/*div2_binding*/ ctx[8](div2);
    			append_dev(div3, t4);
    			mount_component(picture0, div3, null);
    			append_dev(div7, t5);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}

    			append_dev(div9, t6);
    			append_dev(div9, div8);
    			mount_component(picture1, div8, null);
    			append_dev(div9, t7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div9, "mousemove", /*mousemove_handler*/ ctx[9], false, false, false),
    					listen_dev(div9, "click", /*click_handler*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*card*/ ctx[11].imageId) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*contents*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div5, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*contents*/ 1) && t1_value !== (t1_value = /*card*/ ctx[11].name + "")) set_data_dev(t1, t1_value);

    			if (dirty & /*contents*/ 1) {
    				each_value_2 = /*card*/ ctx[11].post;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			const picture0_changes = {};
    			if (dirty & /*contents*/ 1) picture0_changes.contents = /*contents*/ ctx[0];
    			if (dirty & /*globalSettings*/ 2) picture0_changes.globalSettings = /*globalSettings*/ ctx[1];
    			if (dirty & /*globalSettings*/ 2) picture0_changes.imageDirectory = /*globalSettings*/ ctx[1].imageDirectory;
    			if (dirty & /*contents*/ 1) picture0_changes.imageId = /*contents*/ ctx[0].logoImageId;
    			if (dirty & /*contents*/ 1) picture0_changes.imageExtensionsShort = /*contents*/ ctx[0].logoImageExtensionsShort;
    			if (dirty & /*ch*/ 16) picture0_changes.sizes = "" + (3 * /*ch*/ ctx[4] + "px");
    			if (dirty & /*contents*/ 1) picture0_changes.width = /*contents*/ ctx[0].logoAspectRatio.width;
    			if (dirty & /*contents*/ 1) picture0_changes.height = /*contents*/ ctx[0].logoAspectRatio.height;
    			picture0.$set(picture0_changes);

    			if (!current || dirty & /*contents*/ 1 && div4_class_value !== (div4_class_value = "right " + (/*card*/ ctx[11].imageId ? '' : 'noImage') + " svelte-uyh0sc")) {
    				attr_dev(div4, "class", div4_class_value);
    			}

    			if (dirty & /*contents, socialConsts, globalSettings*/ 131) {
    				each_value_1 = /*card*/ ctx[11].accounts;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div6, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}

    			const picture1_changes = {};
    			if (dirty & /*contents*/ 1) picture1_changes.contents = /*contents*/ ctx[0];
    			if (dirty & /*globalSettings*/ 2) picture1_changes.globalSettings = /*globalSettings*/ ctx[1];
    			if (dirty & /*globalSettings*/ 2) picture1_changes.imageDirectory = /*globalSettings*/ ctx[1].imageDirectory;
    			if (dirty & /*contents*/ 1) picture1_changes.imageId = /*contents*/ ctx[0].backfaceLogoImageId;
    			if (dirty & /*contents*/ 1) picture1_changes.imageExtensionsShort = /*contents*/ ctx[0].backfaceLogoImageExtensionsShort;
    			if (dirty & /*contents*/ 1) picture1_changes.width = /*contents*/ ctx[0].backfaceLogoAspectRatio.width;
    			if (dirty & /*contents*/ 1) picture1_changes.height = /*contents*/ ctx[0].backfaceLogoAspectRatio.height;
    			picture1.$set(picture1_changes);

    			if (!current || dirty & /*contents*/ 1) {
    				set_style(div9, "--backfaceColor", /*card*/ ctx[11].backfaceColor);
    			}

    			if (!current || dirty & /*contents*/ 1) {
    				set_style(div9, "--backfaceLogoBrightness", /*card*/ ctx[11].backfaceLogoBrightness);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(picture0.$$.fragment, local);
    			transition_in(picture1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(picture0.$$.fragment, local);
    			transition_out(picture1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks_1, detaching);
    			/*div2_binding*/ ctx[8](null);
    			destroy_component(picture0);
    			destroy_each(each_blocks, detaching);
    			destroy_component(picture1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(32:2) {#each contents.cards as card}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let div;
    	let current;
    	let each_value = /*contents*/ ctx[0].cards;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "card_container svelte-uyh0sc");
    			set_style(div, "--rotateX", /*rotateX*/ ctx[5] + "deg");
    			set_style(div, "--rotateY", /*rotateY*/ ctx[6] + "deg");
    			add_location(div, file$a, 30, 0, 959);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*contents, rotateX, rotateY, setTimeout, globalSettings, socialConsts, ch, ch2px, standardWidth*/ 255) {
    				each_value = /*contents*/ ctx[0].cards;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*rotateX*/ 32) {
    				set_style(div, "--rotateX", /*rotateX*/ ctx[5] + "deg");
    			}

    			if (!current || dirty & /*rotateY*/ 64) {
    				set_style(div, "--rotateY", /*rotateY*/ ctx[6] + "deg");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Cards', slots, []);
    	let { contents, globalSettings, standardWidth } = $$props;

    	const socialConsts = {
    		urls: {
    			'twitter': 'twitter.com',
    			'facebook': 'facebook.com',
    			'note': 'note.com',
    			'github': 'github.com',
    			'qiita': 'qiita.com',
    			'youtube': 'www.youtube.com/c',
    			'lastfm': 'www.last.fm/ja/user'
    		},
    		aspectRatios: {
    			'twitter': { width: 2499, height: 2032 },
    			'facebook': { width: 971, height: 965 },
    			'note': { width: 167, height: 188 },
    			'github': { width: 362, height: 354 },
    			'qiita': { width: 1, height: 1 },
    			'youtube': { width: 44, height: 31 },
    			'lastfm': { width: 70877, height: 17833 }
    		}
    	};

    	let ch2px, ch, rotateX, rotateY;

    	onMount(() => {
    		$$invalidate(4, ch = ch2px.getBoundingClientRect().width);
    	});

    	const writable_props = ['contents', 'globalSettings', 'standardWidth'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cards> was created with unknown prop '${key}'`);
    	});

    	function div2_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			ch2px = $$value;
    			$$invalidate(3, ch2px);
    		});
    	}

    	const mousemove_handler = e => {
    		const cardClass = e.currentTarget.querySelector('.card').classList;

    		if (!cardClass.contains('isFliping')) {
    			$$invalidate(5, rotateX = ((e.clientY - e.currentTarget.getBoundingClientRect().top) / (e.currentTarget.getBoundingClientRect().height / 2) - 1) * 10);
    			$$invalidate(6, rotateY = ((e.clientX - e.currentTarget.getBoundingClientRect().left) / (e.currentTarget.getBoundingClientRect().width / 2) - 1) * -10 + (cardClass.contains('fliped') ? 180 : 0));
    		}
    	};

    	const click_handler = e => {
    		const cardClass = e.currentTarget.querySelector('.card').classList;
    		const backfaceClass = e.currentTarget.querySelector('.backface').classList;

    		if (!cardClass.contains('isFliping') && !e.currentTarget.querySelector('.card .lower').contains(e.target)) {
    			cardClass.add('isFliping');
    			backfaceClass.add('isFliping');

    			setTimeout(
    				() => {
    					cardClass.remove('isFliping');
    					backfaceClass.remove('isFliping');
    					cardClass[!cardClass.contains('fliped') ? 'add' : 'remove']('fliped');
    					backfaceClass[!backfaceClass.contains('fliped') ? 'add' : 'remove']('fliped');
    					$$invalidate(6, rotateY += 180);
    				},
    				600
    			);
    		}
    	};

    	$$self.$$set = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('standardWidth' in $$props) $$invalidate(2, standardWidth = $$props.standardWidth);
    	};

    	$$self.$capture_state = () => ({
    		contents,
    		globalSettings,
    		standardWidth,
    		Picture,
    		onMount,
    		socialConsts,
    		ch2px,
    		ch,
    		rotateX,
    		rotateY
    	});

    	$$self.$inject_state = $$props => {
    		if ('contents' in $$props) $$invalidate(0, contents = $$props.contents);
    		if ('globalSettings' in $$props) $$invalidate(1, globalSettings = $$props.globalSettings);
    		if ('standardWidth' in $$props) $$invalidate(2, standardWidth = $$props.standardWidth);
    		if ('ch2px' in $$props) $$invalidate(3, ch2px = $$props.ch2px);
    		if ('ch' in $$props) $$invalidate(4, ch = $$props.ch);
    		if ('rotateX' in $$props) $$invalidate(5, rotateX = $$props.rotateX);
    		if ('rotateY' in $$props) $$invalidate(6, rotateY = $$props.rotateY);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		contents,
    		globalSettings,
    		standardWidth,
    		ch2px,
    		ch,
    		rotateX,
    		rotateY,
    		socialConsts,
    		div2_binding,
    		mousemove_handler,
    		click_handler
    	];
    }

    class Cards extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {
    			contents: 0,
    			globalSettings: 1,
    			standardWidth: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cards",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*contents*/ ctx[0] === undefined && !('contents' in props)) {
    			console.warn("<Cards> was created without expected prop 'contents'");
    		}

    		if (/*globalSettings*/ ctx[1] === undefined && !('globalSettings' in props)) {
    			console.warn("<Cards> was created without expected prop 'globalSettings'");
    		}

    		if (/*standardWidth*/ ctx[2] === undefined && !('standardWidth' in props)) {
    			console.warn("<Cards> was created without expected prop 'standardWidth'");
    		}
    	}

    	get contents() {
    		throw new Error("<Cards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contents(value) {
    		throw new Error("<Cards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get globalSettings() {
    		throw new Error("<Cards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set globalSettings(value) {
    		throw new Error("<Cards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get standardWidth() {
    		throw new Error("<Cards>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set standardWidth(value) {
    		throw new Error("<Cards>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const settings = [
      {
        sectionType: 'navHeader',
        themeColor: '#fff',
        contents: {
          imageId: 'ssm-logo-landscape',
          aspectRatio: { width: 157213, height: 60041 },
          imageExtensionsShort: ['svg'],
          items: [
            {id: 'top', label: ''},
            {id: 'news', label: ''},
            {id: 'about', label: ''},
            {id: 'members', label: ''}
          ]
        }
      },
      {
        sectionType: 'slideHero',
        pairId: 'hero',
      },
      {
        sectionType: 'slideDesc',
        pairId: 'hero',
        isParent: true,
        contents: {
          articles: [
            {
              title: '',
              subtitle: '',
              themeColor: '#ed773e',
              imageId: 'necromance_ss',
              alt: '',
              aspectRatio: {width: 16, height: 9},
              description: [
                'STG',
                '',
                '',
                '20203972020',
                'Booth'
              ],
              buttons: [
                {
                  popup: '',
                  title: '',
                  target: '/necromance/',
                  spaMode: true
                }
              ],
              slides: [
                {
                  type: 'youtube',
                  id: 'foh7rj5YI_E'
                }
              ],
              specs: {
                times: [
                  {
                    year: '2019',
                    month: '8',
                    annotation: '',
                  }
                ],
                platforms: [
                  {
                    name: 'Windows',
                    version: '7',
                    orLater: true
                  },
                  {
                    name: 'macOS',
                    version: 'Sierra',
                    orLater: true
                  }
                ]
              }
            },
            {
              title: 'SPINNER',
              subtitle: '',
              themeColor: '#464646',
              imageId: 'spinner_ss',
              alt: 'SPINNER',
              aspectRatio: {width: 16, height: 9},
              description: [
                '1vs1',
                '',
                'GCGEXPO2019',
                '20202200'
              ],
              buttons: [
                {
                  title: '',
                  target: 'https://game.creators-guild.com/g4c/%e3%82%b2%e3%83%bc%e3%83%a0%e6%a5%ad%e7%95%8c%e4%ba%a4%e6%b5%81%e4%bc%9a%e3%81%ab%e6%bd%9c%e5%85%a5%ef%bc%81/'
                }
              ],
              specs: {
                times: [
                  {
                    year: '2019',
                    month: '11',
                    annotation: '(2)',
                  }
                ],
                platforms: [
                  {
                    name: 'Windows',
                    version: '7',
                    orLater: true
                  },
                  {
                    name: 'macOS',
                    version: 'Sierra',
                    orLater: true
                  }
                ]
              }
            },
            {
              title: 'CUPRUNMEN',
              subtitle: 'VRM',
              themeColor: '#b56c4e',
              imageId: 'cup-run_ss',
              alt: 'CUPRUNMEN',
              aspectRatio: {width: 16, height: 9},
              description: [
                '',
                '',
                'VRM',
                ''
              ],
              buttons: [
                {
                  popup: '',
                  title: [
                    'unityroom',
                    ''
                  ],
                  target: 'https://unityroom.com/games/cuprunmen'
                }
              ],
              slides: [
                {
                  type: 'youtube',
                  id: 'm44wTn8nk9Y'
                }
              ],
              specs: {
                times: [
                  {
                    year: '2020',
                    month: '4',
                    annotation: '(5)',
                  }
                ],
                platforms: [
                  {
                    name: 'WebGL'
                  }
                ]
              }
            },
            {
              title: '',
              subtitle: '',
              themeColor: '#4ae0ef',
              imageId: 'fall_in_parfait-ss1',
              alt: '',
              aspectRatio: {width: 16, height: 9},
              description: [
                '20208Unity1Week',
                '',
                'Twitter',
                '',
                'Unity1Week5004635',
                '2020',
                '2021Ohayoo Casual Game Contest'
              ],
              buttons: [
                {
                  popup: '',
                  title: [
                    'unityroom',
                    ''
                  ],
                  target: 'https://unityroom.com/games/fallinparfait'
                }
              ],
              slides: [
                {
                  type: 'youtube',
                  id: 'ZIFt6yuOMAQ'
                }
              ],
              specs: {
                times: [
                  {
                    year: '2020',
                    month: '8',
                    annotation: '(1)',
                  },
                  {
                    year: '2020',
                    month: '12',
                    annotation: '(1)',
                  }
                ],
                platforms: [
                  {
                    name: 'iOS',
                    version: '10',
                    orLater: true
                  },
                  {
                    name: 'Android',
                    version: '8',
                    orLater: true
                  },
                  {
                    name: 'WebGL'
                  }
                ]
              }
            },
            {
              title: '',
              subtitle: '',
              themeColor: '#da3c26',
              imageId: 'bakugai-img',
              aspectRatio: {width: 1, height: 1},
              alt: '',
              description: [
                'Unity1Week',
                '',
                'AIAI',
                'Unity1Week'
              ],
              buttons: [
                {
                  popup: '',
                  title: [
                    'unityroom',
                    ''
                  ],
                  target: 'https://unityroom.com/games/bakugaimarket'
                }
              ],
              slides: [
                {
                  type: 'youtube',
                  id: 'vTsy8NCYSNE'
                }
              ],
              specs: {
                times: [
                  {
                    year: '2020',
                    month: '2',
                    annotation: '(12)',
                  }
                ],
                platforms: [
                  {
                    name: 'WebGL'
                  }
                ]
              }
            }
          ]
        }
      },
      {
        sectionType: 'dateList',
        title: 'NEWS',
        subtitle: '',
        themeColor: '#f73f23',
        id: 'news',
        contents: {
          shownItemsCount: 3,
          articles: [
            {
              title: '2020f4samurai',
              date: {
                year: '2021',
                month: '1',
                day: '29'
              },
              url: 'https://twitter.com/MachiCollider/status/1355123713226625027'
            },
            {
              title: '',
              date: {
                year: '2021',
                month: '1',
                day: '28'
              },
              url: 'https://www.dendai.ac.jp/dendai-people/20210128-01.html'
            },
            {
              title: '20203',
              date: {
                year: '2020',
                month: '12',
                day: '19'
              },
              url: 'https://www.4gamer.net/games/999/G999905/20201228102/'
            },
            {
              title: '2020',
              date: {
                year: '2020',
                month: '11',
                day: '29'
              },
              url: 'http://digigame-expo.org/'
            },
            {
              title: 'Unity 1Week',
              date: {
                year: '2020',
                month: '8',
                day: '30'
              },
              url: 'https://unityroom.com/unity1weeks/17'
            },
            {
              title: 'SPINNER',
              date: {
                year: '2020',
                month: '2',
                day: '6'
              },
              url: 'https://game.creators-guild.com/g4c/%E3%82%B2%E3%83%BC%E3%83%A0%E6%A5%AD%E7%95%8C%E4%BA%A4%E6%B5%81%E4%BC%9A%E3%81%AB%E6%BD%9C%E5%85%A5%EF%BC%81/'
            },
            {
              title: '',
              date: {
                year: '2019',
                month: '12',
                day: '27'
              },
              url: 'https://game.creators-guild.com/g4c/interview-studentgamescreator-20190114/'
            },
            {
              title: 'SPINNERGCG EXPO 2019',
              date: {
                year: '2019',
                month: '11',
                day: '30'
              },
              url: 'https://game.creators-guild.com/g4c/event-realevent-20191205/'
            },
            {
              title: ' GAME^3',
              date: {
                year: '2019',
                month: '9',
                day: '8'
              },
              url: 'https://game3.trap.jp/10th/'
            }
          ]
        }
      },
      {
        sectionType: 'static',
        title: 'ABOUT',
        themeColor: '#f78323',
        id: 'about',
        contents: {
          imageId: 'ssm-logo-landscape',
          aspectRatio: { width: 157213, height: 60041 },
          imageExtensionsShort: ['svg'],
          article: [
            "",
            ""
          ],
          bottomButtonsLayout: 'left',
          bottomButtons: [
            {
              title: [
                ''
              ],
              target: 'https://docs.google.com/forms/d/e/1FAIpQLSd6Z3feC7onaq9SJa1Blfdd7frPFCsm4zQUCfQr9XqPxM3gzA/viewform'
            },
            {
              title: 'Twitter',
              target: 'https://twitter.com/necromance_chan'
            }
          ]
        }
      },
      {
        sectionType: 'cards',
        title: 'MEMBERS',
        themeColor: '#f7a723',
        id: 'members',
        contents: {
          logoImageId: 'ssm-logo',
          logoImageExtensionsShort: ['svg'],
          logoAspectRatio: {width: 47581, height: 90047},
          backfaceLogoImageId: 'ssm-logo-landscape',
          backfaceLogoImageExtensionsShort: ['svg'],
          backfaceLogoAspectRatio: {width: 157213, height: 60041},
          imageDirectory: './img/members/',
          cards: [
            {
              name: '',
              imageId: 'machiko',
              post: [
                '',
                ''
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'MachiCollider'
                },
                {
                  name: 'note',
                  id: 'machikou_mk2'
                },
                {
                  name: 'qiita',
                  id: 'Machikof'
                }
              ],
              backfaceColor: '#E03D16',
              backfaceLogoBrightness: 10
            },
            {
              name: '',
              imageId: 'i-da',
              post: [
                '',
                ''
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'GoodPaddyField5'
                },
                {
                  name: 'note',
                  id: '203_'
                }
              ],
              backfaceColor: '#57e827',
              backfaceLogoBrightness: 10
            },
            {
              name: 'Amu',
              imageId: 'amu',
              post: [
                'UI/',
                ''
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'Amu_dsgn'
                }
              ],
              backfaceColor: '#e84327',
              backfaceLogoBrightness: 10
            },
            {
              name: 'HIBIKI CUBE',
              imageId: 'hibiki',
              post: [
                'Web',
                'CG'
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'hibiki_cube'
                },
                {
                  name: 'github',
                  id: 'HIBIKI-CUBE'
                },
                {
                  name: 'qiita',
                  id: 'HIBIKI-CUBE'
                },
                {
                  name: 'lastfm',
                  id: 'HIBIKI_CUBE'
                }
              ],
              backfaceColor: '#27b1e8',
              backfaceLogoBrightness: 10
            },
            {
              name: 'Matsu',
              imageId: '',
              post: [
                '',
                ''
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'sake_unity_stu'
                },
                {
                  name: 'github',
                  id: 'AtaruMatsudaira'
                }
              ],
              backfaceColor: '#e82727',
              backfaceLogoBrightness: 10
            },
            {
              name: '',
              imageId: '',
              post: [
                ''
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'fi_matsu'
                }
              ],
              backfaceColor: '#6e27e8',
              backfaceLogoBrightness: 10
            },
            {
              name: '',
              imageId: 'echo',
              post: [
                ''
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'ysXKPSlvMZqVtIW'
                }
              ],
              backfaceColor: '#000000',
              backfaceLogoBrightness: 10
            },
            {
              name: '',
              imageId: '',
              post: [
                'CG'
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'Subamaru_7'
                }
              ],
              backfaceColor: '#e82781',
              backfaceLogoBrightness: 10
            },
            {
              name: '',
              imageId: 'kazuemon',
              post: [
                'Web'
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'kazuemon_0602',
                  customUrl: '//k6n.jp/tw'
                },
                {
                  name: 'youtube',
                  id: 'kazuemon',
                  customUrl: '//k6n.jp/yt'
                },
                {
                  name: 'github',
                  id: 'kazuemon',
                  customUrl: '//k6n.jp/gh'
                },
              ],
              backfaceColor: '#e8a127',
              backfaceLogoBrightness: 10
            },
            {
              name: 'NEO',
              imageId: 'neo',
              post: [
                '',
                ''
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'neo_97m'
                },
                {
                  name: 'github',
                  id: 'NEON1212121'
                },
              ],
              backfaceColor: '#7de8bd',
              backfaceLogoBrightness: 10
            },
            {
              name: '',
              post: [
                '3D',
              ],
              accounts: [
                {
                  name: 'twitter',
                  id: 'ucSzlqTS3y78lIN'
                }
              ],
              backfaceColor: '#145866',
              backfaceLogoBrightness: 10
            }
          ]
        }
      },
      {
        sectionType: 'footer',
        themeColor: '#fff',
        contents: {
          copyright: ['&copy; 2021', 'HIBIKI CUBE', ''],
          codeLicense: {
            license: 'mpl-2.0',
            linkLabel: 'GitHub',
            url: 'https://github.com/HIBIKI-CUBE/superstarmine-web',
          },
          assetsLicense: {
            ccType: 'by-nd'
          }
        }
      }
    ];

    /* src/pages/index.svelte generated by Svelte v3.43.0 */
    const file$9 = "src/pages/index.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i].title;
    	child_ctx[3] = list[i].subtitle;
    	child_ctx[4] = list[i].themeColor;
    	child_ctx[5] = list[i].sectionType;
    	child_ctx[6] = list[i].contents;
    	child_ctx[7] = list[i].id;
    	child_ctx[8] = list[i].pairId;
    	return child_ctx;
    }

    // (16:0) {#if settings.find(v => v.sectionType == 'navHeader')}
    function create_if_block_7(ctx) {
    	let nheader;
    	let current;

    	nheader = new Nav_header({
    			props: {
    				contents: settings.find(func_1).contents,
    				globalSettings
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(nheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nheader, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(16:0) {#if settings.find(v => v.sectionType == 'navHeader')}",
    		ctx
    	});

    	return block;
    }

    // (27:41) 
    function create_if_block_3(ctx) {
    	let cframe;
    	let current;

    	cframe = new Common_frame({
    			props: {
    				id: /*id*/ ctx[7],
    				title: /*title*/ ctx[2],
    				subtitle: /*subtitle*/ ctx[3],
    				themeColor: /*themeColor*/ ctx[4],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cframe.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cframe, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cframe_changes = {};

    			if (dirty & /*$$scope, $sync*/ 2049) {
    				cframe_changes.$$scope = { dirty, ctx };
    			}

    			cframe.$set(cframe_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cframe.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cframe.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cframe, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(27:41) ",
    		ctx
    	});

    	return block;
    }

    // (25:38) 
    function create_if_block_2(ctx) {
    	let footer;
    	let current;

    	footer = new Footer({
    			props: { contents: /*contents*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(25:38) ",
    		ctx
    	});

    	return block;
    }

    // (23:41) 
    function create_if_block_1(ctx) {
    	let desc;
    	let current;

    	desc = new Slide_description({
    			props: {
    				contents: /*contents*/ ctx[6],
    				globalSettings,
    				pairId: /*pairId*/ ctx[8],
    				standardWidth: /*$sync*/ ctx[0].standardWidth
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(desc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(desc, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const desc_changes = {};
    			if (dirty & /*$sync*/ 1) desc_changes.standardWidth = /*$sync*/ ctx[0].standardWidth;
    			desc.$set(desc_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(desc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(desc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(desc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(23:41) ",
    		ctx
    	});

    	return block;
    }

    // (21:4) {#if sectionType == "slideHero"}
    function create_if_block$3(ctx) {
    	let heros;
    	let current;

    	function func_2(...args) {
    		return /*func_2*/ ctx[1](/*pairId*/ ctx[8], ...args);
    	}

    	heros = new Slide_hero_swiper({
    			props: {
    				contents: /*contents*/ ctx[6] || settings.find(func_2).contents,
    				globalSettings,
    				pairId: /*pairId*/ ctx[8],
    				standardWidth: /*$sync*/ ctx[0].standardWidth
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(heros.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(heros, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const heros_changes = {};
    			if (dirty & /*$sync*/ 1) heros_changes.standardWidth = /*$sync*/ ctx[0].standardWidth;
    			heros.$set(heros_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(heros.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(heros.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(heros, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(21:4) {#if sectionType == \\\"slideHero\\\"}",
    		ctx
    	});

    	return block;
    }

    // (33:41) 
    function create_if_block_6(ctx) {
    	let cards;
    	let current;

    	cards = new Cards({
    			props: {
    				contents: /*contents*/ ctx[6],
    				globalSettings,
    				standardWidth: /*$sync*/ ctx[0].standardWidth
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cards.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cards, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cards_changes = {};
    			if (dirty & /*$sync*/ 1) cards_changes.standardWidth = /*$sync*/ ctx[0].standardWidth;
    			cards.$set(cards_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cards.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cards.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cards, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(33:41) ",
    		ctx
    	});

    	return block;
    }

    // (31:44) 
    function create_if_block_5(ctx) {
    	let dlist;
    	let current;

    	dlist = new Date_list({
    			props: { contents: /*contents*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dlist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dlist, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(31:44) ",
    		ctx
    	});

    	return block;
    }

    // (29:8) {#if sectionType == "static"}
    function create_if_block_4(ctx) {
    	let static_1;
    	let current;

    	static_1 = new Static_content({
    			props: {
    				contents: /*contents*/ ctx[6],
    				globalSettings,
    				standardWidth: /*$sync*/ ctx[0].standardWidth
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(static_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(static_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const static_1_changes = {};
    			if (dirty & /*$sync*/ 1) static_1_changes.standardWidth = /*$sync*/ ctx[0].standardWidth;
    			static_1.$set(static_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(static_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(static_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(static_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(29:8) {#if sectionType == \\\"static\\\"}",
    		ctx
    	});

    	return block;
    }

    // (28:6) <Cframe {id} {title} {subtitle} {themeColor}>
    function create_default_slot$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let current;
    	const if_block_creators = [create_if_block_4, create_if_block_5, create_if_block_6];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*sectionType*/ ctx[5] == "static") return 0;
    		if (/*sectionType*/ ctx[5] == "dateList") return 1;
    		if (/*sectionType*/ ctx[5] == "cards") return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (if_block) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(28:6) <Cframe {id} {title} {subtitle} {themeColor}>",
    		ctx
    	});

    	return block;
    }

    // (20:2) {#each settings as {title, subtitle, themeColor, sectionType, contents, id, pairId}}
    function create_each_block$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$3, create_if_block_1, create_if_block_2, create_if_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*sectionType*/ ctx[5] == "slideHero") return 0;
    		if (/*sectionType*/ ctx[5] == "slideDesc") return 1;
    		if (/*sectionType*/ ctx[5] == "footer") return 2;
    		if (/*sectionType*/ ctx[5] != "navHeader") return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (if_block) if_block.p(ctx, dirty);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(20:2) {#each settings as {title, subtitle, themeColor, sectionType, contents, id, pairId}}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let show_if = settings.find(func);
    	let t;
    	let main;
    	let current;
    	let if_block = show_if && create_if_block_7(ctx);
    	let each_value = settings;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			main = element("main");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(main, "--transitionDuration", globalSettings.transitionDuration + "ms");
    			set_style(main, "--standardWidth", /*$sync*/ ctx[0].standardWidth + "vw");
    			add_location(main, file$9, 18, 0, 787);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, main, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(main, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (show_if) if_block.p(ctx, dirty);

    			if (dirty & /*settings, globalSettings, $sync*/ 1) {
    				each_value = settings;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(main, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*$sync*/ 1) {
    				set_style(main, "--standardWidth", /*$sync*/ ctx[0].standardWidth + "vw");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = v => v.sectionType == 'navHeader';
    const func_1 = v => v.sectionType == 'navHeader';

    function instance$a($$self, $$props, $$invalidate) {
    	let $sync;
    	validate_store(sync, 'sync');
    	component_subscribe($$self, sync, $$value => $$invalidate(0, $sync = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Pages', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pages> was created with unknown prop '${key}'`);
    	});

    	const func_2 = (pairId, v) => v.pairId == pairId && v.isParent;

    	$$self.$capture_state = () => ({
    		Cframe: Common_frame,
    		Nheader: Nav_header,
    		Static: Static_content,
    		Dlist: Date_list,
    		HeroS: Slide_hero_swiper,
    		Desc: Slide_description,
    		Footer,
    		Cards,
    		settings,
    		globalSettings,
    		sync,
    		$sync
    	});

    	return [$sync, func_2];
    }

    class Pages extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pages",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* node_modules/.pnpm/svelte-intersection-observer@0.8.0/node_modules/svelte-intersection-observer/src/IntersectionObserver.svelte generated by Svelte v3.43.0 */

    const get_default_slot_changes = dirty => ({
    	intersecting: dirty & /*intersecting*/ 2,
    	entry: dirty & /*entry*/ 1,
    	observer: dirty & /*observer*/ 4
    });

    const get_default_slot_context = ctx => ({
    	intersecting: /*intersecting*/ ctx[1],
    	entry: /*entry*/ ctx[0],
    	observer: /*observer*/ ctx[2]
    });

    function create_fragment$9(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope, intersecting, entry, observer*/ 263)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[8],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[8])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, get_default_slot_changes),
    						get_default_slot_context
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IntersectionObserver', slots, ['default']);
    	let { element = null } = $$props;
    	let { once = false } = $$props;
    	let { root = null } = $$props;
    	let { rootMargin = "0px" } = $$props;
    	let { threshold = 0 } = $$props;
    	let { entry = null } = $$props;
    	let { intersecting = false } = $$props;
    	let { observer = null } = $$props;
    	const dispatch = createEventDispatcher();
    	let prevRootMargin = null;
    	let prevElement = null;

    	const initialize = () => {
    		$$invalidate(2, observer = new IntersectionObserver(entries => {
    				entries.forEach(_entry => {
    					$$invalidate(0, entry = _entry);
    					$$invalidate(1, intersecting = _entry.isIntersecting);
    				});
    			},
    		{ root, rootMargin, threshold }));
    	};

    	onMount(() => {
    		initialize();

    		return () => {
    			if (observer) observer.disconnect();
    		};
    	});

    	afterUpdate(async () => {
    		if (entry !== null) {
    			dispatch("observe", entry);

    			if (entry.isIntersecting) {
    				dispatch("intersect", entry);
    				if (once) observer.unobserve(element);
    			}
    		}

    		await tick();

    		if (element !== null && element !== prevElement) {
    			observer.observe(element);
    			if (prevElement !== null) observer.unobserve(prevElement);
    			prevElement = element;
    		}

    		if (prevRootMargin && rootMargin !== prevRootMargin) {
    			observer.disconnect();
    			prevElement = null;
    			initialize();
    		}

    		prevRootMargin = rootMargin;
    	});

    	const writable_props = [
    		'element',
    		'once',
    		'root',
    		'rootMargin',
    		'threshold',
    		'entry',
    		'intersecting',
    		'observer'
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IntersectionObserver> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('element' in $$props) $$invalidate(3, element = $$props.element);
    		if ('once' in $$props) $$invalidate(4, once = $$props.once);
    		if ('root' in $$props) $$invalidate(5, root = $$props.root);
    		if ('rootMargin' in $$props) $$invalidate(6, rootMargin = $$props.rootMargin);
    		if ('threshold' in $$props) $$invalidate(7, threshold = $$props.threshold);
    		if ('entry' in $$props) $$invalidate(0, entry = $$props.entry);
    		if ('intersecting' in $$props) $$invalidate(1, intersecting = $$props.intersecting);
    		if ('observer' in $$props) $$invalidate(2, observer = $$props.observer);
    		if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		element,
    		once,
    		root,
    		rootMargin,
    		threshold,
    		entry,
    		intersecting,
    		observer,
    		tick,
    		createEventDispatcher,
    		afterUpdate,
    		onMount,
    		dispatch,
    		prevRootMargin,
    		prevElement,
    		initialize
    	});

    	$$self.$inject_state = $$props => {
    		if ('element' in $$props) $$invalidate(3, element = $$props.element);
    		if ('once' in $$props) $$invalidate(4, once = $$props.once);
    		if ('root' in $$props) $$invalidate(5, root = $$props.root);
    		if ('rootMargin' in $$props) $$invalidate(6, rootMargin = $$props.rootMargin);
    		if ('threshold' in $$props) $$invalidate(7, threshold = $$props.threshold);
    		if ('entry' in $$props) $$invalidate(0, entry = $$props.entry);
    		if ('intersecting' in $$props) $$invalidate(1, intersecting = $$props.intersecting);
    		if ('observer' in $$props) $$invalidate(2, observer = $$props.observer);
    		if ('prevRootMargin' in $$props) prevRootMargin = $$props.prevRootMargin;
    		if ('prevElement' in $$props) prevElement = $$props.prevElement;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		entry,
    		intersecting,
    		observer,
    		element,
    		once,
    		root,
    		rootMargin,
    		threshold,
    		$$scope,
    		slots
    	];
    }

    class IntersectionObserver_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			element: 3,
    			once: 4,
    			root: 5,
    			rootMargin: 6,
    			threshold: 7,
    			entry: 0,
    			intersecting: 1,
    			observer: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IntersectionObserver_1",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get element() {
    		throw new Error("<IntersectionObserver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<IntersectionObserver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get once() {
    		throw new Error("<IntersectionObserver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set once(value) {
    		throw new Error("<IntersectionObserver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get root() {
    		throw new Error("<IntersectionObserver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set root(value) {
    		throw new Error("<IntersectionObserver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rootMargin() {
    		throw new Error("<IntersectionObserver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rootMargin(value) {
    		throw new Error("<IntersectionObserver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get threshold() {
    		throw new Error("<IntersectionObserver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set threshold(value) {
    		throw new Error("<IntersectionObserver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get entry() {
    		throw new Error("<IntersectionObserver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set entry(value) {
    		throw new Error("<IntersectionObserver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get intersecting() {
    		throw new Error("<IntersectionObserver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set intersecting(value) {
    		throw new Error("<IntersectionObserver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get observer() {
    		throw new Error("<IntersectionObserver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set observer(value) {
    		throw new Error("<IntersectionObserver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var IntersectionObserver$1 = IntersectionObserver_1;

    /* src/components/lines.svelte generated by Svelte v3.43.0 */
    const file$8 = "src/components/lines.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (20:4) {#each string.split(" ") as chunk}
    function create_each_block(ctx) {
    	let span;
    	let t_value = /*chunk*/ ctx[8] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text$1(t_value);
    			attr_dev(span, "class", "svelte-1cntuzd");
    			add_location(span, file$8, 20, 6, 494);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*string*/ 1 && t_value !== (t_value = /*chunk*/ ctx[8] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(20:4) {#each string.split(\\\" \\\") as chunk}",
    		ctx
    	});

    	return block;
    }

    // (12:0) <IntersectionObserver once {element} bind:intersecting>
    function create_default_slot$2(ctx) {
    	let p;
    	let each_value = /*string*/ ctx[0].split(" ");
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			p = element("p");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(p, "data-align", /*align*/ ctx[1]);
    			attr_dev(p, "data-slidein", /*slideIn*/ ctx[2]);
    			attr_dev(p, "class", /*className*/ ctx[3]);
    			toggle_class(p, "animation", /*intersecting*/ ctx[5]);
    			add_location(p, file$8, 12, 2, 311);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(p, null);
    			}

    			/*p_binding*/ ctx[6](p);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*string*/ 1) {
    				each_value = /*string*/ ctx[0].split(" ");
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(p, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*align*/ 2) {
    				attr_dev(p, "data-align", /*align*/ ctx[1]);
    			}

    			if (dirty & /*slideIn*/ 4) {
    				attr_dev(p, "data-slidein", /*slideIn*/ ctx[2]);
    			}

    			if (dirty & /*className*/ 8) {
    				attr_dev(p, "class", /*className*/ ctx[3]);
    			}

    			if (dirty & /*className, intersecting*/ 40) {
    				toggle_class(p, "animation", /*intersecting*/ ctx[5]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    			destroy_each(each_blocks, detaching);
    			/*p_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(12:0) <IntersectionObserver once {element} bind:intersecting>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let intersectionobserver;
    	let updating_intersecting;
    	let current;

    	function intersectionobserver_intersecting_binding(value) {
    		/*intersectionobserver_intersecting_binding*/ ctx[7](value);
    	}

    	let intersectionobserver_props = {
    		once: true,
    		element: /*element*/ ctx[4],
    		$$slots: { default: [create_default_slot$2] },
    		$$scope: { ctx }
    	};

    	if (/*intersecting*/ ctx[5] !== void 0) {
    		intersectionobserver_props.intersecting = /*intersecting*/ ctx[5];
    	}

    	intersectionobserver = new IntersectionObserver$1({
    			props: intersectionobserver_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind$1(intersectionobserver, 'intersecting', intersectionobserver_intersecting_binding));

    	const block = {
    		c: function create() {
    			create_component(intersectionobserver.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(intersectionobserver, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const intersectionobserver_changes = {};
    			if (dirty & /*element*/ 16) intersectionobserver_changes.element = /*element*/ ctx[4];

    			if (dirty & /*$$scope, align, slideIn, className, element, intersecting, string*/ 2111) {
    				intersectionobserver_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_intersecting && dirty & /*intersecting*/ 32) {
    				updating_intersecting = true;
    				intersectionobserver_changes.intersecting = /*intersecting*/ ctx[5];
    				add_flush_callback(() => updating_intersecting = false);
    			}

    			intersectionobserver.$set(intersectionobserver_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(intersectionobserver.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(intersectionobserver.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(intersectionobserver, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Lines', slots, []);
    	let { string = "" } = $$props;
    	let { align = "" } = $$props;
    	let { slideIn = "" } = $$props;
    	let { className = "" } = $$props;
    	let element;
    	let intersecting;
    	const writable_props = ['string', 'align', 'slideIn', 'className'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lines> was created with unknown prop '${key}'`);
    	});

    	function p_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			element = $$value;
    			$$invalidate(4, element);
    		});
    	}

    	function intersectionobserver_intersecting_binding(value) {
    		intersecting = value;
    		$$invalidate(5, intersecting);
    	}

    	$$self.$$set = $$props => {
    		if ('string' in $$props) $$invalidate(0, string = $$props.string);
    		if ('align' in $$props) $$invalidate(1, align = $$props.align);
    		if ('slideIn' in $$props) $$invalidate(2, slideIn = $$props.slideIn);
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    	};

    	$$self.$capture_state = () => ({
    		IntersectionObserver: IntersectionObserver$1,
    		string,
    		align,
    		slideIn,
    		className,
    		element,
    		intersecting
    	});

    	$$self.$inject_state = $$props => {
    		if ('string' in $$props) $$invalidate(0, string = $$props.string);
    		if ('align' in $$props) $$invalidate(1, align = $$props.align);
    		if ('slideIn' in $$props) $$invalidate(2, slideIn = $$props.slideIn);
    		if ('className' in $$props) $$invalidate(3, className = $$props.className);
    		if ('element' in $$props) $$invalidate(4, element = $$props.element);
    		if ('intersecting' in $$props) $$invalidate(5, intersecting = $$props.intersecting);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		string,
    		align,
    		slideIn,
    		className,
    		element,
    		intersecting,
    		p_binding,
    		intersectionobserver_intersecting_binding
    	];
    }

    class Lines extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			string: 0,
    			align: 1,
    			slideIn: 2,
    			className: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lines",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get string() {
    		throw new Error("<Lines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set string(value) {
    		throw new Error("<Lines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get align() {
    		throw new Error("<Lines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set align(value) {
    		throw new Error("<Lines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get slideIn() {
    		throw new Error("<Lines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slideIn(value) {
    		throw new Error("<Lines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<Lines>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<Lines>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/newcromance/index.svelte generated by Svelte v3.43.0 */
    const file$7 = "src/pages/newcromance/index.svelte";

    function create_fragment$7(ctx) {
    	let meta0;
    	let meta1;
    	let link0;
    	let link1;
    	let link2;
    	let link3;
    	let link4;
    	let link5;
    	let script;
    	let script_src_value;
    	let t0;
    	let nav;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t1;
    	let div2;
    	let div1;
    	let svg0;
    	let path0;
    	let t2;
    	let section0;
    	let div4;
    	let div3;
    	let img1;
    	let img1_src_value;
    	let t3;
    	let img2;
    	let img2_src_value;
    	let t4;
    	let img3;
    	let img3_src_value;
    	let t5;
    	let img4;
    	let img4_src_value;
    	let t6;
    	let img5;
    	let img5_src_value;
    	let t7;
    	let img6;
    	let img6_src_value;
    	let t8;
    	let img7;
    	let img7_src_value;
    	let t9;
    	let img8;
    	let img8_src_value;
    	let t10;
    	let img9;
    	let img9_src_value;
    	let t11;
    	let img10;
    	let img10_src_value;
    	let t12;
    	let img11;
    	let img11_src_value;
    	let t13;
    	let img12;
    	let img12_src_value;
    	let t14;
    	let img13;
    	let img13_src_value;
    	let t15;
    	let div5;
    	let svg1;
    	let path1;
    	let t16;
    	let main;
    	let section1;
    	let div7;
    	let div6;
    	let iframe;
    	let iframe_src_value;
    	let t17;
    	let section2;
    	let div9;
    	let div8;
    	let h20;
    	let t19;
    	let span0;
    	let t21;
    	let ul;
    	let li0;
    	let time0;
    	let t23;
    	let p0;
    	let t25;
    	let p1;
    	let t27;
    	let li1;
    	let a0;
    	let time1;
    	let t29;
    	let p2;
    	let t31;
    	let p3;
    	let t33;
    	let li2;
    	let a1;
    	let time2;
    	let t35;
    	let p4;
    	let t37;
    	let p5;
    	let t39;
    	let section3;
    	let div18;
    	let div10;
    	let h21;
    	let t41;
    	let span1;
    	let t43;
    	let div13;
    	let div11;
    	let lines0;
    	let t44;
    	let lines1;
    	let t45;
    	let lines2;
    	let t46;
    	let lines3;
    	let t47;
    	let div12;
    	let img14;
    	let img14_src_value;
    	let t48;
    	let div14;
    	let t49;
    	let div17;
    	let div15;
    	let img15;
    	let img15_src_value;
    	let t50;
    	let div16;
    	let lines4;
    	let t51;
    	let lines5;
    	let t52;
    	let lines6;
    	let t53;
    	let lines7;
    	let t54;
    	let lines8;
    	let t55;
    	let section4;
    	let div24;
    	let div19;
    	let h22;
    	let t57;
    	let span2;
    	let t59;
    	let div23;
    	let div22;
    	let div20;
    	let img16;
    	let img16_src_value;
    	let t60;
    	let div21;
    	let h3;
    	let t62;
    	let p6;
    	let t64;
    	let p7;
    	let t65;
    	let br0;
    	let t66;
    	let br1;
    	let t67;
    	let br2;
    	let t68;
    	let br3;
    	let t69;
    	let p8;
    	let t71;
    	let section5;
    	let div26;
    	let div25;
    	let h23;
    	let t73;
    	let span3;
    	let t75;
    	let br4;
    	let t76;
    	let img17;
    	let img17_src_value;
    	let t77;
    	let p9;
    	let t79;
    	let img18;
    	let img18_src_value;
    	let t80;
    	let p10;
    	let t82;
    	let img19;
    	let img19_src_value;
    	let t83;
    	let p11;
    	let t85;
    	let section6;
    	let div29;
    	let div27;
    	let h24;
    	let t87;
    	let span4;
    	let t89;
    	let div28;
    	let lines9;
    	let t90;
    	let lines10;
    	let t91;
    	let a2;
    	let t93;
    	let section7;
    	let div30;
    	let p12;
    	let t95;
    	let a3;
    	let br5;
    	let t97;
    	let a4;
    	let t99;
    	let div33;
    	let div31;
    	let img20;
    	let img20_src_value;
    	let t100;
    	let img21;
    	let img21_src_value;
    	let t101;
    	let div32;
    	let a5;
    	let svg2;
    	let path2;
    	let t102;
    	let a6;
    	let svg3;
    	let path3;
    	let t103;
    	let footer;
    	let div34;
    	let img22;
    	let img22_src_value;
    	let t104;
    	let p13;
    	let t106;
    	let hr;
    	let t107;
    	let p14;
    	let t108;
    	let a7;
    	let t110;
    	let br6;
    	let t111;
    	let a8;
    	let t113;
    	let t114;
    	let p15;
    	let t115;
    	let br7;
    	let t116;
    	let current;

    	lines0 = new Lines({
    			props: {
    				align: "left",
    				slideIn: "left",
    				string: " "
    			},
    			$$inline: true
    		});

    	lines1 = new Lines({
    			props: {
    				align: "left",
    				slideIn: "left",
    				string: "   "
    			},
    			$$inline: true
    		});

    	lines2 = new Lines({
    			props: {
    				align: "left",
    				slideIn: "left",
    				string: "    "
    			},
    			$$inline: true
    		});

    	lines3 = new Lines({
    			props: {
    				align: "left",
    				slideIn: "left",
    				string: "   "
    			},
    			$$inline: true
    		});

    	lines4 = new Lines({
    			props: {
    				align: "right",
    				slideIn: "right",
    				string: "  "
    			},
    			$$inline: true
    		});

    	lines5 = new Lines({
    			props: {
    				align: "right",
    				slideIn: "right",
    				string: "  "
    			},
    			$$inline: true
    		});

    	lines6 = new Lines({
    			props: {
    				className: "text--necro",
    				align: "right",
    				slideIn: "right",
    				string: "  "
    			},
    			$$inline: true
    		});

    	lines7 = new Lines({
    			props: {
    				className: "text--necro",
    				align: "right",
    				slideIn: "right",
    				string: " "
    			},
    			$$inline: true
    		});

    	lines8 = new Lines({
    			props: {
    				align: "right",
    				slideIn: "right",
    				string: "    "
    			},
    			$$inline: true
    		});

    	lines9 = new Lines({
    			props: {
    				align: "center",
    				slideIn: "left",
    				string: "Discord   "
    			},
    			$$inline: true
    		});

    	lines10 = new Lines({
    			props: {
    				align: "center",
    				slideIn: "left",
    				string: " "
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			meta0 = element("meta");
    			meta1 = element("meta");
    			link0 = element("link");
    			link1 = element("link");
    			link2 = element("link");
    			link3 = element("link");
    			link4 = element("link");
    			link5 = element("link");
    			script = element("script");
    			t0 = space();
    			nav = element("nav");
    			div0 = element("div");
    			img0 = element("img");
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			svg0 = svg_element("svg");
    			path0 = svg_element("path");
    			t2 = space();
    			section0 = element("section");
    			div4 = element("div");
    			div3 = element("div");
    			img1 = element("img");
    			t3 = space();
    			img2 = element("img");
    			t4 = space();
    			img3 = element("img");
    			t5 = space();
    			img4 = element("img");
    			t6 = space();
    			img5 = element("img");
    			t7 = space();
    			img6 = element("img");
    			t8 = space();
    			img7 = element("img");
    			t9 = space();
    			img8 = element("img");
    			t10 = space();
    			img9 = element("img");
    			t11 = space();
    			img10 = element("img");
    			t12 = space();
    			img11 = element("img");
    			t13 = space();
    			img12 = element("img");
    			t14 = space();
    			img13 = element("img");
    			t15 = space();
    			div5 = element("div");
    			svg1 = svg_element("svg");
    			path1 = svg_element("path");
    			t16 = space();
    			main = element("main");
    			section1 = element("section");
    			div7 = element("div");
    			div6 = element("div");
    			iframe = element("iframe");
    			t17 = space();
    			section2 = element("section");
    			div9 = element("div");
    			div8 = element("div");
    			h20 = element("h2");
    			h20.textContent = "News";
    			t19 = space();
    			span0 = element("span");
    			span0.textContent = "";
    			t21 = space();
    			ul = element("ul");
    			li0 = element("li");
    			time0 = element("time");
    			time0.textContent = "2021/09/27";
    			t23 = space();
    			p0 = element("p");
    			p0.textContent = "";
    			t25 = space();
    			p1 = element("p");
    			p1.textContent = "";
    			t27 = space();
    			li1 = element("li");
    			a0 = element("a");
    			time1 = element("time");
    			time1.textContent = "2021/06/05";
    			t29 = space();
    			p2 = element("p");
    			p2.textContent = "INDIE Live Expo 2021";
    			t31 = space();
    			p3 = element("p");
    			p3.textContent = "YouTube";
    			t33 = space();
    			li2 = element("li");
    			a1 = element("a");
    			time2 = element("time");
    			time2.textContent = "2020/12/19";
    			t35 = space();
    			p4 = element("p");
    			p4.textContent = "20203";
    			t37 = space();
    			p5 = element("p");
    			p5.textContent = "";
    			t39 = space();
    			section3 = element("section");
    			div18 = element("div");
    			div10 = element("div");
    			h21 = element("h2");
    			h21.textContent = "World";
    			t41 = space();
    			span1 = element("span");
    			span1.textContent = "";
    			t43 = space();
    			div13 = element("div");
    			div11 = element("div");
    			create_component(lines0.$$.fragment);
    			t44 = space();
    			create_component(lines1.$$.fragment);
    			t45 = space();
    			create_component(lines2.$$.fragment);
    			t46 = space();
    			create_component(lines3.$$.fragment);
    			t47 = space();
    			div12 = element("div");
    			img14 = element("img");
    			t48 = space();
    			div14 = element("div");
    			t49 = space();
    			div17 = element("div");
    			div15 = element("div");
    			img15 = element("img");
    			t50 = space();
    			div16 = element("div");
    			create_component(lines4.$$.fragment);
    			t51 = space();
    			create_component(lines5.$$.fragment);
    			t52 = space();
    			create_component(lines6.$$.fragment);
    			t53 = space();
    			create_component(lines7.$$.fragment);
    			t54 = space();
    			create_component(lines8.$$.fragment);
    			t55 = space();
    			section4 = element("section");
    			div24 = element("div");
    			div19 = element("div");
    			h22 = element("h2");
    			h22.textContent = "CHARACTERS";
    			t57 = space();
    			span2 = element("span");
    			span2.textContent = "";
    			t59 = space();
    			div23 = element("div");
    			div22 = element("div");
    			div20 = element("div");
    			img16 = element("img");
    			t60 = space();
    			div21 = element("div");
    			h3 = element("h3");
    			h3.textContent = "NECROMANCE";
    			t62 = space();
    			p6 = element("p");
    			p6.textContent = "";
    			t64 = space();
    			p7 = element("p");
    			t65 = text$1("");
    			br0 = element("br");
    			t66 = text$1("\n              14");
    			br1 = element("br");
    			t67 = text$1("\n              ");
    			br2 = element("br");
    			t68 = text$1("\n              ");
    			br3 = element("br");
    			t69 = space();
    			p8 = element("p");
    			p8.textContent = "";
    			t71 = space();
    			section5 = element("section");
    			div26 = element("div");
    			div25 = element("div");
    			h23 = element("h2");
    			h23.textContent = "SYSTEM";
    			t73 = space();
    			span3 = element("span");
    			span3.textContent = "";
    			t75 = space();
    			br4 = element("br");
    			t76 = space();
    			img17 = element("img");
    			t77 = space();
    			p9 = element("p");
    			p9.textContent = "";
    			t79 = space();
    			img18 = element("img");
    			t80 = space();
    			p10 = element("p");
    			p10.textContent = "";
    			t82 = space();
    			img19 = element("img");
    			t83 = space();
    			p11 = element("p");
    			p11.textContent = "";
    			t85 = space();
    			section6 = element("section");
    			div29 = element("div");
    			div27 = element("div");
    			h24 = element("h2");
    			h24.textContent = "DISCORD";
    			t87 = space();
    			span4 = element("span");
    			span4.textContent = "";
    			t89 = space();
    			div28 = element("div");
    			create_component(lines9.$$.fragment);
    			t90 = space();
    			create_component(lines10.$$.fragment);
    			t91 = space();
    			a2 = element("a");
    			a2.textContent = "";
    			t93 = space();
    			section7 = element("section");
    			div30 = element("div");
    			p12 = element("p");
    			p12.textContent = "Twitter";
    			t95 = space();
    			a3 = element("a");
    			a3.textContent = "Tweets by necromance_chan";
    			br5 = element("br");
    			t97 = space();
    			a4 = element("a");
    			a4.textContent = "Twitter ";
    			t99 = space();
    			div33 = element("div");
    			div31 = element("div");
    			img20 = element("img");
    			t100 = space();
    			img21 = element("img");
    			t101 = space();
    			div32 = element("div");
    			a5 = element("a");
    			svg2 = svg_element("svg");
    			path2 = svg_element("path");
    			t102 = space();
    			a6 = element("a");
    			svg3 = svg_element("svg");
    			path3 = svg_element("path");
    			t103 = space();
    			footer = element("footer");
    			div34 = element("div");
    			img22 = element("img");
    			t104 = space();
    			p13 = element("p");
    			p13.textContent = " 2021 HIBIKI CUBE, , ";
    			t106 = space();
    			hr = element("hr");
    			t107 = space();
    			p14 = element("p");
    			t108 = text$1("Web Mozilla Public License 2.0\n       ");
    			a7 = element("a");
    			a7.textContent = "GitHub";
    			t110 = text$1("\n      ");
    			br6 = element("br");
    			t111 = text$1("\n      The source code of this web site is licensed under a Mozilla Public License\n      2.0 and available at\n      ");
    			a8 = element("a");
    			a8.textContent = "GitHub";
    			t113 = text$1(".");
    			t114 = space();
    			p15 = element("p");
    			t115 = text$1("\n        -  4.0  \n      ");
    			br7 = element("br");
    			t116 = text$1("\n      All non-source code resources such as images and videos are licensed under\n      a Creative Commons Attribution-NoDerivatives 4.0 International License.");
    			attr_dev(meta0, "charset", "UTF-8");
    			add_location(meta0, file$7, 8, 2, 183);
    			attr_dev(meta1, "name", "viewport");
    			attr_dev(meta1, "content", "width=device-width, initial-scale=1");
    			add_location(meta1, file$7, 9, 2, 210);
    			document.title = "";
    			attr_dev(link0, "rel", "preconnect");
    			attr_dev(link0, "href", "https://fonts.googleapis.com");
    			add_location(link0, file$7, 11, 2, 315);
    			attr_dev(link1, "rel", "preconnect");
    			attr_dev(link1, "href", "https://fonts.gstatic.com");
    			attr_dev(link1, "crossorigin", "");
    			add_location(link1, file$7, 12, 2, 379);
    			attr_dev(link2, "rel", "stylesheet");
    			attr_dev(link2, "href", "/src/pages/newcromance/style/reset.css");
    			add_location(link2, file$7, 13, 2, 452);
    			attr_dev(link3, "href", "https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap");
    			attr_dev(link3, "rel", "stylesheet");
    			add_location(link3, file$7, 14, 2, 526);
    			attr_dev(link4, "rel", "stylesheet");
    			attr_dev(link4, "href", "https://use.typekit.net/lkm8uks.css");
    			add_location(link4, file$7, 18, 2, 651);
    			attr_dev(link5, "rel", "stylesheet");
    			attr_dev(link5, "href", "/src/pages/newcromance/style/style.css");
    			add_location(link5, file$7, 19, 2, 722);
    			script.async = true;
    			if (!src_url_equal(script.src, script_src_value = "https://platform.twitter.com/widgets.js")) attr_dev(script, "src", script_src_value);
    			attr_dev(script, "charset", "utf-8");
    			add_location(script, file$7, 20, 2, 796);
    			attr_dev(img0, "class", "nav__logo");
    			if (!src_url_equal(img0.src, img0_src_value = "/src/pages/newcromance/img/SSM_LOGO.png")) attr_dev(img0, "src", img0_src_value);
    			add_location(img0, file$7, 27, 4, 957);
    			attr_dev(div0, "class", "nav__left");
    			add_location(div0, file$7, 26, 2, 929);
    			attr_dev(path0, "fill", "#56449A");
    			attr_dev(path0, "d", "M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z");
    			add_location(path0, file$7, 32, 8, 1193);
    			set_style(svg0, "width", "40px");
    			set_style(svg0, "height", "40px");
    			attr_dev(svg0, "viewBox", "0 0 24 24");
    			add_location(svg0, file$7, 31, 6, 1128);
    			attr_dev(div1, "class", "nav__menu-button");
    			set_style(div1, "display", "none");
    			add_location(div1, file$7, 30, 4, 1069);
    			attr_dev(div2, "class", "nav__right");
    			add_location(div2, file$7, 29, 2, 1040);
    			attr_dev(nav, "class", "nav");
    			add_location(nav, file$7, 25, 0, 909);
    			attr_dev(img1, "class", "hero-section__layer01");
    			if (!src_url_equal(img1.src, img1_src_value = "/src/pages/newcromance/img/keyvisual/01.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "01");
    			add_location(img1, file$7, 43, 6, 1469);
    			attr_dev(img2, "class", "hero-section__layer03");
    			if (!src_url_equal(img2.src, img2_src_value = "/src/pages/newcromance/img/keyvisual/03.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "03");
    			add_location(img2, file$7, 48, 6, 1609);
    			attr_dev(img3, "class", "hero-section__layer04");
    			if (!src_url_equal(img3.src, img3_src_value = "/src/pages/newcromance/img/keyvisual/04.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "04");
    			add_location(img3, file$7, 53, 6, 1749);
    			attr_dev(img4, "class", "hero-section__layer05");
    			if (!src_url_equal(img4.src, img4_src_value = "/src/pages/newcromance/img/keyvisual/05.png")) attr_dev(img4, "src", img4_src_value);
    			attr_dev(img4, "alt", "05");
    			add_location(img4, file$7, 58, 6, 1889);
    			attr_dev(img5, "class", "hero-section__layer06");
    			if (!src_url_equal(img5.src, img5_src_value = "/src/pages/newcromance/img/keyvisual/06.png")) attr_dev(img5, "src", img5_src_value);
    			attr_dev(img5, "alt", "06");
    			add_location(img5, file$7, 63, 6, 2029);
    			attr_dev(img6, "class", "hero-section__layer07");
    			if (!src_url_equal(img6.src, img6_src_value = "/src/pages/newcromance/img/keyvisual/07.png")) attr_dev(img6, "src", img6_src_value);
    			attr_dev(img6, "alt", "07");
    			add_location(img6, file$7, 68, 6, 2169);
    			attr_dev(img7, "class", "hero-section__layer08");
    			if (!src_url_equal(img7.src, img7_src_value = "/src/pages/newcromance/img/keyvisual/08.png")) attr_dev(img7, "src", img7_src_value);
    			attr_dev(img7, "alt", "08");
    			add_location(img7, file$7, 73, 6, 2309);
    			attr_dev(img8, "class", "hero-section__layer09");
    			if (!src_url_equal(img8.src, img8_src_value = "/src/pages/newcromance/img/keyvisual/09.png")) attr_dev(img8, "src", img8_src_value);
    			attr_dev(img8, "alt", "09");
    			add_location(img8, file$7, 78, 6, 2449);
    			attr_dev(img9, "class", "hero-section__layer10");
    			if (!src_url_equal(img9.src, img9_src_value = "/src/pages/newcromance/img/keyvisual/10.png")) attr_dev(img9, "src", img9_src_value);
    			attr_dev(img9, "alt", "10");
    			add_location(img9, file$7, 83, 6, 2589);
    			attr_dev(img10, "class", "hero-section__layer11");
    			if (!src_url_equal(img10.src, img10_src_value = "/src/pages/newcromance/img/keyvisual/11.png")) attr_dev(img10, "src", img10_src_value);
    			attr_dev(img10, "alt", "11");
    			add_location(img10, file$7, 88, 6, 2729);
    			attr_dev(img11, "class", "hero-section__layer12");
    			if (!src_url_equal(img11.src, img11_src_value = "/src/pages/newcromance/img/keyvisual/12.png")) attr_dev(img11, "src", img11_src_value);
    			attr_dev(img11, "alt", "12");
    			add_location(img11, file$7, 93, 6, 2869);
    			attr_dev(img12, "class", "hero-section__layer02");
    			if (!src_url_equal(img12.src, img12_src_value = "/src/pages/newcromance/img/keyvisual/02.png")) attr_dev(img12, "src", img12_src_value);
    			attr_dev(img12, "alt", "02");
    			add_location(img12, file$7, 98, 6, 3009);
    			attr_dev(img13, "class", "hero-section__logo");
    			if (!src_url_equal(img13.src, img13_src_value = "/src/pages/newcromance/img/_Ver3.png")) attr_dev(img13, "src", img13_src_value);
    			attr_dev(img13, "alt", "");
    			add_location(img13, file$7, 103, 6, 3149);
    			attr_dev(div3, "class", "hero-section__elements");
    			add_location(div3, file$7, 42, 4, 1426);
    			attr_dev(div4, "class", "hero-section__elements-wrapper");
    			add_location(div4, file$7, 41, 2, 1377);
    			attr_dev(path1, "d", "M342.816 63.56C404.683 74.35 464.587 93.69 526.283 105.42C614.165 122.14 705.685 123.15 793.429 105.81C878.699 89 967.115 48 1051.37 27.17C1126.09 8.69 1207.67 1.08 1280 24.17V120H0V92.65C109.297 53.7958 227.854 43.7355 342.816 63.56Z");
    			attr_dev(path1, "fill", "#56449A");
    			add_location(path1, file$7, 117, 6, 3501);
    			attr_dev(svg1, "viewBox", "0 0 1280 120");
    			attr_dev(svg1, "preserveAspectRatio", "none");
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			set_style(svg1, "position", "absolute");
    			set_style(svg1, "bottom", "0");
    			add_location(svg1, file$7, 111, 4, 3340);
    			attr_dev(div5, "class", "hero-section__shape-divider");
    			add_location(div5, file$7, 110, 2, 3294);
    			attr_dev(section0, "class", "section hero-section");
    			add_location(section0, file$7, 40, 0, 1336);
    			attr_dev(iframe, "class", "movie-section__iframe");
    			attr_dev(iframe, "width", "560");
    			attr_dev(iframe, "height", "315");
    			if (!src_url_equal(iframe.src, iframe_src_value = "https://www.youtube.com/embed/jLoTKRXC-X0")) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "title", "YouTube video player");
    			attr_dev(iframe, "frameborder", "0");
    			attr_dev(iframe, "allow", "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture");
    			iframe.allowFullscreen = true;
    			add_location(iframe, file$7, 128, 8, 3962);
    			attr_dev(div6, "class", "movie-section__video-wrapper");
    			add_location(div6, file$7, 127, 6, 3911);
    			attr_dev(div7, "class", "content");
    			add_location(div7, file$7, 126, 4, 3883);
    			attr_dev(section1, "class", "section movie-section");
    			add_location(section1, file$7, 125, 2, 3839);
    			add_location(h20, file$7, 144, 8, 4462);
    			add_location(span0, file$7, 145, 8, 4484);
    			attr_dev(div8, "class", "heading");
    			add_location(div8, file$7, 143, 6, 4432);
    			attr_dev(time0, "class", "news-item__date");
    			attr_dev(time0, "datetime", "2020-09-27");
    			add_location(time0, file$7, 149, 10, 4594);
    			attr_dev(p0, "class", "news-item__heading");
    			add_location(p0, file$7, 150, 10, 4674);
    			attr_dev(p1, "class", "news-item__text");
    			add_location(p1, file$7, 151, 10, 4736);
    			attr_dev(li0, "class", "news-item");
    			add_location(li0, file$7, 148, 8, 4561);
    			attr_dev(time1, "class", "news-item__date");
    			attr_dev(time1, "datetime", "2020-09-27");
    			add_location(time1, file$7, 155, 12, 4898);
    			attr_dev(p2, "class", "news-item__heading");
    			add_location(p2, file$7, 157, 12, 4993);
    			attr_dev(p3, "class", "news-item__text");
    			add_location(p3, file$7, 160, 12, 5101);
    			attr_dev(a0, "href", "https://youtu.be/c9WYyPyVM18?t=165");
    			add_location(a0, file$7, 154, 10, 4840);
    			attr_dev(li1, "class", "news-item");
    			add_location(li1, file$7, 153, 8, 4807);
    			attr_dev(time2, "class", "news-item__date");
    			attr_dev(time2, "datetime", "2020-12-19");
    			add_location(time2, file$7, 167, 12, 5333);
    			attr_dev(p4, "class", "news-item__heading");
    			add_location(p4, file$7, 169, 12, 5428);
    			attr_dev(p5, "class", "news-item__text");
    			add_location(p5, file$7, 172, 12, 5546);
    			attr_dev(a1, "href", "https://www.4gamer.net/games/999/G999905/20201228102/");
    			add_location(a1, file$7, 166, 10, 5256);
    			attr_dev(li2, "class", "news-item");
    			add_location(li2, file$7, 165, 8, 5223);
    			attr_dev(ul, "class", "news-section__list");
    			add_location(ul, file$7, 147, 6, 4521);
    			attr_dev(div9, "class", "content");
    			add_location(div9, file$7, 142, 4, 4404);
    			attr_dev(section2, "class", "section news-section");
    			add_location(section2, file$7, 141, 2, 4361);
    			add_location(h21, file$7, 181, 8, 5765);
    			add_location(span1, file$7, 182, 8, 5788);
    			attr_dev(div10, "class", "heading");
    			add_location(div10, file$7, 180, 6, 5735);
    			attr_dev(div11, "class", "filled-sentence");
    			add_location(div11, file$7, 185, 8, 5870);
    			if (!src_url_equal(img14.src, img14_src_value = "/src/pages/newcromance/img/enemies.png")) attr_dev(img14, "src", img14_src_value);
    			add_location(img14, file$7, 204, 10, 6472);
    			attr_dev(div12, "class", "world-section__block01__img");
    			add_location(div12, file$7, 203, 8, 6420);
    			attr_dev(div13, "class", "world-section__block01");
    			add_location(div13, file$7, 184, 6, 5825);
    			set_style(div14, "height", "80px");
    			add_location(div14, file$7, 207, 6, 6559);
    			if (!src_url_equal(img15.src, img15_src_value = "/src/pages/newcromance/img/necromance_doya.png")) attr_dev(img15, "src", img15_src_value);
    			add_location(img15, file$7, 210, 10, 6692);
    			attr_dev(div15, "class", "world-section__block02__img");
    			add_location(div15, file$7, 209, 8, 6640);
    			attr_dev(div16, "class", "filled-sentence");
    			add_location(div16, file$7, 212, 8, 6776);
    			attr_dev(div17, "class", "world-section__block02");
    			add_location(div17, file$7, 208, 6, 6595);
    			attr_dev(div18, "class", "content");
    			add_location(div18, file$7, 179, 4, 5707);
    			attr_dev(section3, "class", "section world-section");
    			add_location(section3, file$7, 178, 2, 5663);
    			add_location(h22, file$7, 247, 8, 7722);
    			add_location(span2, file$7, 248, 8, 7750);
    			attr_dev(div19, "class", "heading heading--center");
    			add_location(div19, file$7, 246, 6, 7676);
    			if (!src_url_equal(img16.src, img16_src_value = "/src/pages/newcromance/img/Necromance_smile_alpha_shadow.png")) attr_dev(img16, "src", img16_src_value);
    			add_location(img16, file$7, 253, 12, 7909);
    			attr_dev(div20, "class", "character__figure");
    			add_location(div20, file$7, 252, 10, 7865);
    			attr_dev(h3, "class", "character__spell");
    			add_location(h3, file$7, 258, 12, 8086);
    			attr_dev(p6, "class", "character__name");
    			add_location(p6, file$7, 259, 12, 8143);
    			add_location(br0, file$7, 261, 35, 8257);
    			add_location(br1, file$7, 262, 25, 8289);
    			add_location(br2, file$7, 263, 42, 8338);
    			add_location(br3, file$7, 264, 38, 8383);
    			attr_dev(p7, "class", "character__intro");
    			add_location(p7, file$7, 260, 12, 8193);
    			attr_dev(div21, "class", "character__description");
    			add_location(div21, file$7, 257, 10, 8037);
    			attr_dev(div22, "class", "character__contents");
    			add_location(div22, file$7, 251, 8, 7821);
    			attr_dev(div23, "class", "character");
    			add_location(div23, file$7, 250, 6, 7789);
    			attr_dev(p8, "class", "characters-section__more");
    			add_location(p8, file$7, 269, 6, 8458);
    			attr_dev(div24, "class", "content");
    			add_location(div24, file$7, 245, 4, 7648);
    			attr_dev(section4, "class", "section characters-section");
    			add_location(section4, file$7, 244, 2, 7599);
    			add_location(h23, file$7, 277, 8, 8664);
    			add_location(span3, file$7, 278, 8, 8688);
    			attr_dev(div25, "class", "heading");
    			add_location(div25, file$7, 276, 6, 8634);
    			add_location(br4, file$7, 280, 6, 8728);
    			if (!src_url_equal(img17.src, img17_src_value = "/src/pages/newcromance/img/system_01.png")) attr_dev(img17, "src", img17_src_value);
    			attr_dev(img17, "width", "500px");
    			add_location(img17, file$7, 281, 6, 8741);
    			attr_dev(p9, "class", "system-section__text");
    			add_location(p9, file$7, 282, 6, 8816);
    			if (!src_url_equal(img18.src, img18_src_value = "/src/pages/newcromance/img/system_02.png")) attr_dev(img18, "src", img18_src_value);
    			attr_dev(img18, "width", "500px");
    			add_location(img18, file$7, 283, 6, 8877);
    			attr_dev(p10, "class", "system-section__text");
    			add_location(p10, file$7, 284, 6, 8952);
    			if (!src_url_equal(img19.src, img19_src_value = "/src/pages/newcromance/img/system_03.png")) attr_dev(img19, "src", img19_src_value);
    			attr_dev(img19, "width", "500px");
    			add_location(img19, file$7, 285, 6, 9014);
    			attr_dev(p11, "class", "system-section__text");
    			add_location(p11, file$7, 286, 6, 9089);
    			attr_dev(div26, "class", "content");
    			add_location(div26, file$7, 275, 4, 8606);
    			attr_dev(section5, "class", "section system-section");
    			add_location(section5, file$7, 274, 2, 8561);
    			add_location(h24, file$7, 292, 8, 9272);
    			add_location(span4, file$7, 293, 8, 9297);
    			attr_dev(div27, "class", "heading");
    			add_location(div27, file$7, 291, 6, 9242);
    			attr_dev(div28, "class", "filled-sentence");
    			add_location(div28, file$7, 295, 6, 9336);
    			attr_dev(a2, "class", "button button--discord");
    			set_style(a2, "margin-top", "60px");
    			attr_dev(a2, "href", "https://discord.gg/FvZvX8gEDx");
    			add_location(a2, file$7, 307, 6, 9630);
    			attr_dev(div29, "class", "content");
    			add_location(div29, file$7, 290, 4, 9214);
    			attr_dev(section6, "class", "section discord-section");
    			add_location(section6, file$7, 289, 2, 9168);
    			attr_dev(p12, "class", "twitter-section__followText");
    			add_location(p12, file$7, 318, 6, 9888);
    			attr_dev(a3, "class", "twitter-timeline");
    			attr_dev(a3, "data-width", "400");
    			attr_dev(a3, "data-height", "400");
    			attr_dev(a3, "data-chrome", "noheader nofooter noborders");
    			attr_dev(a3, "href", "https://twitter.com/necromance_chan?ref_src=twsrc%5Etfw");
    			add_location(a3, file$7, 319, 6, 9954);
    			add_location(br5, file$7, 326, 7, 10207);
    			attr_dev(a4, "class", "button button--twitter");
    			set_style(a4, "margin-top", "60px");
    			attr_dev(a4, "href", "https://twitter.com/necromance_chan");
    			add_location(a4, file$7, 327, 6, 10220);
    			attr_dev(div30, "class", "content");
    			add_location(div30, file$7, 317, 4, 9860);
    			attr_dev(section7, "class", "section twitter-section");
    			add_location(section7, file$7, 316, 2, 9814);
    			attr_dev(main, "class", "main");
    			add_location(main, file$7, 124, 0, 3817);
    			attr_dev(img20, "class", "share-section__mini-necromance");
    			if (!src_url_equal(img20.src, img20_src_value = "/src/pages/newcromance/img/mini_necromance.png")) attr_dev(img20, "src", img20_src_value);
    			add_location(img20, file$7, 339, 4, 10494);
    			attr_dev(img21, "class", "share-section__text");
    			if (!src_url_equal(img21.src, img21_src_value = "/src/pages/newcromance/img/.png")) attr_dev(img21, "src", img21_src_value);
    			attr_dev(img21, "alt", "");
    			add_location(img21, file$7, 343, 4, 10614);
    			attr_dev(div31, "class", "share-section__dialogue");
    			add_location(div31, file$7, 338, 2, 10452);
    			attr_dev(path2, "fill", "currentColor");
    			attr_dev(path2, "d", "M22.46,6C21.69,6.35 20.86,6.58 20,6.69C20.88,6.16 21.56,5.32 21.88,4.31C21.05,4.81 20.13,5.16 19.16,5.36C18.37,4.5 17.26,4 16,4C13.65,4 11.73,5.92 11.73,8.29C11.73,8.63 11.77,8.96 11.84,9.27C8.28,9.09 5.11,7.38 3,4.79C2.63,5.42 2.42,6.16 2.42,6.94C2.42,8.43 3.17,9.75 4.33,10.5C3.62,10.5 2.96,10.3 2.38,10C2.38,10 2.38,10 2.38,10.03C2.38,12.11 3.86,13.85 5.82,14.24C5.46,14.34 5.08,14.39 4.69,14.39C4.42,14.39 4.15,14.36 3.89,14.31C4.43,16 6,17.26 7.89,17.29C6.43,18.45 4.58,19.13 2.56,19.13C2.22,19.13 1.88,19.11 1.54,19.07C3.44,20.29 5.7,21 8.12,21C16,21 20.33,14.46 20.33,8.79C20.33,8.6 20.33,8.42 20.32,8.23C21.16,7.63 21.88,6.87 22.46,6Z");
    			add_location(path2, file$7, 355, 8, 11484);
    			set_style(svg2, "width", "24px");
    			set_style(svg2, "height", "24px");
    			attr_dev(svg2, "viewBox", "0 0 24 24");
    			add_location(svg2, file$7, 354, 6, 11419);
    			attr_dev(a5, "class", "share-section__button--twitter");
    			attr_dev(a5, "href", "https://twitter.com/intent/tweet?text=%E3%82%8C%E3%83%BC%E3%81%9E%E3%81%8F%E5%85%A8%E6%96%B9%E4%BD%8DSTG%E3%80%8E%E3%82%8C%E3%83%BC%E3%81%9E%E3%81%8F%EF%BC%81%E3%83%8D%E3%82%AF%E3%83%AD%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%A1%E3%82%83%E3%82%93%E3%80%8F%E5%85%AC%E5%BC%8F%E3%82%B5%E3%82%A4%E3%83%88%20https%3A%2F%2Fsuperstarmine.com%2Fnecromance%2F%20%23%E3%81%9E%E3%81%8F%E3%83%AD%E3%83%9E%20%23%E3%82%8C%E3%83%BC%E3%81%9E%E3%81%8F%E3%83%8D%E3%82%AF%E3%83%AD%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%A1%E3%82%83%E3%82%93%20%40necromance_chan%E3%82%88%E3%82%8A%20");
    			add_location(a5, file$7, 350, 4, 10795);
    			attr_dev(path3, "fill", "currentColor");
    			attr_dev(path3, "d", "M12 2.04C6.5 2.04 2 6.53 2 12.06C2 17.06 5.66 21.21 10.44 21.96V14.96H7.9V12.06H10.44V9.85C10.44 7.34 11.93 5.96 14.22 5.96C15.31 5.96 16.45 6.15 16.45 6.15V8.62H15.19C13.95 8.62 13.56 9.39 13.56 10.18V12.06H16.34L15.89 14.96H13.56V21.96A10 10 0 0 0 22 12.06C22 6.53 17.5 2.04 12 2.04Z");
    			add_location(path3, file$7, 366, 8, 12517);
    			set_style(svg3, "width", "24px");
    			set_style(svg3, "height", "24px");
    			attr_dev(svg3, "viewBox", "0 0 24 24");
    			add_location(svg3, file$7, 365, 6, 12452);
    			attr_dev(a6, "class", "share-section__button--facebook");
    			attr_dev(a6, "href", "https://www.facebook.com/sharer/sharer.php?kid_directed_site=0&sdk=joey&u=https%3A%2F%2Fsuperstarmine.com%2Fnecromance%2F&display=popup&ref=plugin&src=share_button");
    			add_location(a6, file$7, 361, 4, 12214);
    			attr_dev(div32, "class", "share-section__share-buttons");
    			add_location(div32, file$7, 349, 2, 10748);
    			attr_dev(div33, "class", "share-section");
    			add_location(div33, file$7, 337, 0, 10422);
    			attr_dev(img22, "class", "footer__circle-logo");
    			if (!src_url_equal(img22.src, img22_src_value = "/src/pages/newcromance/img/_W__v2_a.png")) attr_dev(img22, "src", img22_src_value);
    			attr_dev(img22, "alt", "");
    			add_location(img22, file$7, 376, 4, 12954);
    			attr_dev(p13, "class", "footer__copyright");
    			add_location(p13, file$7, 381, 4, 13079);
    			attr_dev(hr, "class", "footer__divider");
    			add_location(hr, file$7, 384, 4, 13171);
    			attr_dev(a7, "href", "https://github.com/SuperStarMine/web-v3");
    			add_location(a7, file$7, 387, 17, 13306);
    			add_location(br6, file$7, 390, 19, 13402);
    			attr_dev(a8, "href", "https://github.com/SuperStarMine/web-v3");
    			add_location(a8, file$7, 393, 6, 13524);
    			attr_dev(p14, "class", "footer__license");
    			add_location(p14, file$7, 385, 4, 13206);
    			add_location(br7, file$7, 398, 18, 13719);
    			attr_dev(p15, "class", "footer__license");
    			add_location(p15, file$7, 395, 4, 13599);
    			attr_dev(div34, "class", "content");
    			add_location(div34, file$7, 375, 2, 12928);
    			attr_dev(footer, "class", "footer");
    			add_location(footer, file$7, 374, 0, 12902);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document.head, meta0);
    			append_dev(document.head, meta1);
    			append_dev(document.head, link0);
    			append_dev(document.head, link1);
    			append_dev(document.head, link2);
    			append_dev(document.head, link3);
    			append_dev(document.head, link4);
    			append_dev(document.head, link5);
    			append_dev(document.head, script);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div0);
    			append_dev(div0, img0);
    			append_dev(nav, t1);
    			append_dev(nav, div2);
    			append_dev(div2, div1);
    			append_dev(div1, svg0);
    			append_dev(svg0, path0);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, section0, anchor);
    			append_dev(section0, div4);
    			append_dev(div4, div3);
    			append_dev(div3, img1);
    			append_dev(div3, t3);
    			append_dev(div3, img2);
    			append_dev(div3, t4);
    			append_dev(div3, img3);
    			append_dev(div3, t5);
    			append_dev(div3, img4);
    			append_dev(div3, t6);
    			append_dev(div3, img5);
    			append_dev(div3, t7);
    			append_dev(div3, img6);
    			append_dev(div3, t8);
    			append_dev(div3, img7);
    			append_dev(div3, t9);
    			append_dev(div3, img8);
    			append_dev(div3, t10);
    			append_dev(div3, img9);
    			append_dev(div3, t11);
    			append_dev(div3, img10);
    			append_dev(div3, t12);
    			append_dev(div3, img11);
    			append_dev(div3, t13);
    			append_dev(div3, img12);
    			append_dev(div3, t14);
    			append_dev(div3, img13);
    			append_dev(section0, t15);
    			append_dev(section0, div5);
    			append_dev(div5, svg1);
    			append_dev(svg1, path1);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, section1);
    			append_dev(section1, div7);
    			append_dev(div7, div6);
    			append_dev(div6, iframe);
    			append_dev(main, t17);
    			append_dev(main, section2);
    			append_dev(section2, div9);
    			append_dev(div9, div8);
    			append_dev(div8, h20);
    			append_dev(div8, t19);
    			append_dev(div8, span0);
    			append_dev(div9, t21);
    			append_dev(div9, ul);
    			append_dev(ul, li0);
    			append_dev(li0, time0);
    			append_dev(li0, t23);
    			append_dev(li0, p0);
    			append_dev(li0, t25);
    			append_dev(li0, p1);
    			append_dev(ul, t27);
    			append_dev(ul, li1);
    			append_dev(li1, a0);
    			append_dev(a0, time1);
    			append_dev(a0, t29);
    			append_dev(a0, p2);
    			append_dev(a0, t31);
    			append_dev(a0, p3);
    			append_dev(ul, t33);
    			append_dev(ul, li2);
    			append_dev(li2, a1);
    			append_dev(a1, time2);
    			append_dev(a1, t35);
    			append_dev(a1, p4);
    			append_dev(a1, t37);
    			append_dev(a1, p5);
    			append_dev(main, t39);
    			append_dev(main, section3);
    			append_dev(section3, div18);
    			append_dev(div18, div10);
    			append_dev(div10, h21);
    			append_dev(div10, t41);
    			append_dev(div10, span1);
    			append_dev(div18, t43);
    			append_dev(div18, div13);
    			append_dev(div13, div11);
    			mount_component(lines0, div11, null);
    			append_dev(div11, t44);
    			mount_component(lines1, div11, null);
    			append_dev(div11, t45);
    			mount_component(lines2, div11, null);
    			append_dev(div11, t46);
    			mount_component(lines3, div11, null);
    			append_dev(div13, t47);
    			append_dev(div13, div12);
    			append_dev(div12, img14);
    			append_dev(div18, t48);
    			append_dev(div18, div14);
    			append_dev(div18, t49);
    			append_dev(div18, div17);
    			append_dev(div17, div15);
    			append_dev(div15, img15);
    			append_dev(div17, t50);
    			append_dev(div17, div16);
    			mount_component(lines4, div16, null);
    			append_dev(div16, t51);
    			mount_component(lines5, div16, null);
    			append_dev(div16, t52);
    			mount_component(lines6, div16, null);
    			append_dev(div16, t53);
    			mount_component(lines7, div16, null);
    			append_dev(div16, t54);
    			mount_component(lines8, div16, null);
    			append_dev(main, t55);
    			append_dev(main, section4);
    			append_dev(section4, div24);
    			append_dev(div24, div19);
    			append_dev(div19, h22);
    			append_dev(div19, t57);
    			append_dev(div19, span2);
    			append_dev(div24, t59);
    			append_dev(div24, div23);
    			append_dev(div23, div22);
    			append_dev(div22, div20);
    			append_dev(div20, img16);
    			append_dev(div22, t60);
    			append_dev(div22, div21);
    			append_dev(div21, h3);
    			append_dev(div21, t62);
    			append_dev(div21, p6);
    			append_dev(div21, t64);
    			append_dev(div21, p7);
    			append_dev(p7, t65);
    			append_dev(p7, br0);
    			append_dev(p7, t66);
    			append_dev(p7, br1);
    			append_dev(p7, t67);
    			append_dev(p7, br2);
    			append_dev(p7, t68);
    			append_dev(p7, br3);
    			append_dev(div24, t69);
    			append_dev(div24, p8);
    			append_dev(main, t71);
    			append_dev(main, section5);
    			append_dev(section5, div26);
    			append_dev(div26, div25);
    			append_dev(div25, h23);
    			append_dev(div25, t73);
    			append_dev(div25, span3);
    			append_dev(div26, t75);
    			append_dev(div26, br4);
    			append_dev(div26, t76);
    			append_dev(div26, img17);
    			append_dev(div26, t77);
    			append_dev(div26, p9);
    			append_dev(div26, t79);
    			append_dev(div26, img18);
    			append_dev(div26, t80);
    			append_dev(div26, p10);
    			append_dev(div26, t82);
    			append_dev(div26, img19);
    			append_dev(div26, t83);
    			append_dev(div26, p11);
    			append_dev(main, t85);
    			append_dev(main, section6);
    			append_dev(section6, div29);
    			append_dev(div29, div27);
    			append_dev(div27, h24);
    			append_dev(div27, t87);
    			append_dev(div27, span4);
    			append_dev(div29, t89);
    			append_dev(div29, div28);
    			mount_component(lines9, div28, null);
    			append_dev(div28, t90);
    			mount_component(lines10, div28, null);
    			append_dev(div29, t91);
    			append_dev(div29, a2);
    			append_dev(main, t93);
    			append_dev(main, section7);
    			append_dev(section7, div30);
    			append_dev(div30, p12);
    			append_dev(div30, t95);
    			append_dev(div30, a3);
    			append_dev(div30, br5);
    			append_dev(div30, t97);
    			append_dev(div30, a4);
    			insert_dev(target, t99, anchor);
    			insert_dev(target, div33, anchor);
    			append_dev(div33, div31);
    			append_dev(div31, img20);
    			append_dev(div31, t100);
    			append_dev(div31, img21);
    			append_dev(div33, t101);
    			append_dev(div33, div32);
    			append_dev(div32, a5);
    			append_dev(a5, svg2);
    			append_dev(svg2, path2);
    			append_dev(div32, t102);
    			append_dev(div32, a6);
    			append_dev(a6, svg3);
    			append_dev(svg3, path3);
    			insert_dev(target, t103, anchor);
    			insert_dev(target, footer, anchor);
    			append_dev(footer, div34);
    			append_dev(div34, img22);
    			append_dev(div34, t104);
    			append_dev(div34, p13);
    			append_dev(div34, t106);
    			append_dev(div34, hr);
    			append_dev(div34, t107);
    			append_dev(div34, p14);
    			append_dev(p14, t108);
    			append_dev(p14, a7);
    			append_dev(p14, t110);
    			append_dev(p14, br6);
    			append_dev(p14, t111);
    			append_dev(p14, a8);
    			append_dev(p14, t113);
    			append_dev(div34, t114);
    			append_dev(div34, p15);
    			append_dev(p15, t115);
    			append_dev(p15, br7);
    			append_dev(p15, t116);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(lines0.$$.fragment, local);
    			transition_in(lines1.$$.fragment, local);
    			transition_in(lines2.$$.fragment, local);
    			transition_in(lines3.$$.fragment, local);
    			transition_in(lines4.$$.fragment, local);
    			transition_in(lines5.$$.fragment, local);
    			transition_in(lines6.$$.fragment, local);
    			transition_in(lines7.$$.fragment, local);
    			transition_in(lines8.$$.fragment, local);
    			transition_in(lines9.$$.fragment, local);
    			transition_in(lines10.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(lines0.$$.fragment, local);
    			transition_out(lines1.$$.fragment, local);
    			transition_out(lines2.$$.fragment, local);
    			transition_out(lines3.$$.fragment, local);
    			transition_out(lines4.$$.fragment, local);
    			transition_out(lines5.$$.fragment, local);
    			transition_out(lines6.$$.fragment, local);
    			transition_out(lines7.$$.fragment, local);
    			transition_out(lines8.$$.fragment, local);
    			transition_out(lines9.$$.fragment, local);
    			transition_out(lines10.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(meta0);
    			detach_dev(meta1);
    			detach_dev(link0);
    			detach_dev(link1);
    			detach_dev(link2);
    			detach_dev(link3);
    			detach_dev(link4);
    			detach_dev(link5);
    			detach_dev(script);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(nav);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(section0);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(main);
    			destroy_component(lines0);
    			destroy_component(lines1);
    			destroy_component(lines2);
    			destroy_component(lines3);
    			destroy_component(lines4);
    			destroy_component(lines5);
    			destroy_component(lines6);
    			destroy_component(lines7);
    			destroy_component(lines8);
    			destroy_component(lines9);
    			destroy_component(lines10);
    			if (detaching) detach_dev(t99);
    			if (detaching) detach_dev(div33);
    			if (detaching) detach_dev(t103);
    			if (detaching) detach_dev(footer);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Newcromance', slots, []);
    	let mounted = false;
    	onMount(() => mounted = true);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Newcromance> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Lines, onMount, mounted });

    	$$self.$inject_state = $$props => {
    		if ('mounted' in $$props) mounted = $$props.mounted;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [];
    }

    class Newcromance extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Newcromance",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* src/components/magic-button.svelte generated by Svelte v3.43.0 */

    const file$6 = "src/components/magic-button.svelte";

    function create_fragment$6(ctx) {
    	let a;
    	let div1;
    	let svg0;
    	let use0;
    	let t0;
    	let svg1;
    	let use1;
    	let t1;
    	let svg2;
    	let use2;
    	let t2;
    	let div0;
    	let a_href_value;
    	let a_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			div1 = element("div");
    			svg0 = svg_element("svg");
    			use0 = svg_element("use");
    			t0 = space();
    			svg1 = svg_element("svg");
    			use1 = svg_element("use");
    			t1 = space();
    			svg2 = svg_element("svg");
    			use2 = svg_element("use");
    			t2 = space();
    			div0 = element("div");
    			if (default_slot) default_slot.c();
    			xlink_attr(use0, "xlink:href", "/img/magic-button.svg#shape");
    			attr_dev(use0, "class", "svelte-a40m9e");
    			add_location(use0, file$6, 5, 6, 182);
    			attr_dev(svg0, "class", "shadow svelte-a40m9e");
    			attr_dev(svg0, "width", "258");
    			attr_dev(svg0, "height", "52");
    			attr_dev(svg0, "viewBox", "0 0 258 52");
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg0, file$6, 4, 4, 75);
    			xlink_attr(use1, "xlink:href", "/img/magic-button.svg#shape");
    			attr_dev(use1, "class", "svelte-a40m9e");
    			add_location(use1, file$6, 8, 6, 351);
    			attr_dev(svg1, "class", "pink svelte-a40m9e");
    			attr_dev(svg1, "width", "258");
    			attr_dev(svg1, "height", "52");
    			attr_dev(svg1, "viewBox", "0 0 258 52");
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg1, file$6, 7, 4, 246);
    			xlink_attr(use2, "xlink:href", "/img/magic-button.svg#shape");
    			attr_dev(use2, "class", "svelte-a40m9e");
    			add_location(use2, file$6, 11, 6, 518);
    			attr_dev(svg2, "class", "bg svelte-a40m9e");
    			attr_dev(svg2, "width", "262");
    			attr_dev(svg2, "height", "56");
    			attr_dev(svg2, "viewBox", "0 0 258 52");
    			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg2, file$6, 10, 4, 415);
    			attr_dev(div0, "class", "content svelte-a40m9e");
    			add_location(div0, file$6, 13, 4, 582);
    			attr_dev(div1, "class", "button svelte-a40m9e");
    			add_location(div1, file$6, 3, 2, 50);
    			attr_dev(a, "href", a_href_value = /*$$props*/ ctx[0].href);
    			attr_dev(a, "class", a_class_value = "" + (null_to_empty(/*$$props*/ ctx[0].class) + " svelte-a40m9e"));
    			add_location(a, file$6, 2, 0, 2);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div1);
    			append_dev(div1, svg0);
    			append_dev(svg0, use0);
    			append_dev(div1, t0);
    			append_dev(div1, svg1);
    			append_dev(svg1, use1);
    			append_dev(div1, t1);
    			append_dev(div1, svg2);
    			append_dev(svg2, use2);
    			append_dev(div1, t2);
    			append_dev(div1, div0);

    			if (default_slot) {
    				default_slot.m(div0, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[1],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
    						null
    					);
    				}
    			}

    			if (!current || dirty & /*$$props*/ 1 && a_href_value !== (a_href_value = /*$$props*/ ctx[0].href)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (!current || dirty & /*$$props*/ 1 && a_class_value !== (a_class_value = "" + (null_to_empty(/*$$props*/ ctx[0].class) + " svelte-a40m9e"))) {
    				attr_dev(a, "class", a_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Magic_button', slots, ['default']);

    	$$self.$$set = $$new_props => {
    		$$invalidate(0, $$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props)));
    		if ('$$scope' in $$new_props) $$invalidate(1, $$scope = $$new_props.$$scope);
    	};

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(0, $$props = assign$1(assign$1({}, $$props), $$new_props));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$props = exclude_internal_props($$props);
    	return [$$props, $$scope, slots];
    }

    class Magic_button extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Magic_button",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /**
     * Combines valid class names.
     *
     * @param classes - An array with classes.
     *
     * @return A concatenated string with provided class names.
     */
    function classNames(...classes) {
        return classes.filter(Boolean).join(' ');
    }

    /**
     * Iterates over the provided object by own enumerable keys with calling the iteratee function.
     *
     * @param object   - An object to iterate over.
     * @param iteratee - An iteratee function that takes the value and key as arguments.
     *
     * @return A provided object itself.
     */
    function forOwn$1(object, iteratee) {
        if (object) {
            const keys = Object.keys(object);
            for (let i = 0; i < keys.length; i++) {
                const key = keys[i];
                if (key !== '__proto__') {
                    if (iteratee(object[key], key) === false) {
                        break;
                    }
                }
            }
        }
        return object;
    }

    function getSlides(splide) {
        const children = splide.Components.Elements?.list.children;
        return children && Array.prototype.slice.call(children) || [];
    }

    /**
     * Checks if the given subject is an object or not.
     *
     * @param subject - A subject to check.
     *
     * @return `true` if the subject is an object, or otherwise `false`.
     */
    function isObject$1(subject) {
        return subject !== null && typeof subject === 'object';
    }

    /**
     * Checks if provided two arrays are shallowly equal or not.
     *
     * @param subject1 - An array to test.
     * @param subject2 - Anther array to test.
     *
     * @return `true` if they are considered as equal, or otherwise `false`.
     */
    function isEqualDeep(subject1, subject2) {
        if (Array.isArray(subject1) && Array.isArray(subject2)) {
            return subject1.length === subject2.length
                && !subject1.some((elm, index) => !isEqualDeep(elm, subject2[index]));
        }
        if (isObject$1(subject1) && isObject$1(subject2)) {
            const keys1 = Object.keys(subject1);
            const keys2 = Object.keys(subject2);
            return keys1.length === keys2.length && !keys1.some(key => {
                return !Object.prototype.hasOwnProperty.call(subject2, key)
                    || !isEqualDeep(subject1[key], subject2[key]);
            });
        }
        return subject1 === subject2;
    }

    /**
     * Checks if provided two arrays are shallowly equal or not.
     *
     * @param array1 - An array to test.
     * @param array2 - Anther array to test.
     *
     * @return `true` if they are considered as equal, or otherwise `false`.
     */
    function isEqualShallow(array1, array2) {
        return array1.length === array2.length
            && !array1.some((elm, index) => elm !== array2[index]);
    }

    /**
     * Recursively merges source properties to the object.
     * Be aware that this method does not merge arrays. They are just duplicated by `slice()`.
     *
     * @param object - An object to merge properties to.
     * @param source - A source object to merge properties from.
     *
     * @return A new object with merged properties.
     */
    function merge$1(object, source) {
        const merged = object;
        forOwn$1(source, (value, key) => {
            if (Array.isArray(value)) {
                merged[key] = value.slice();
            }
            else if (isObject$1(value)) {
                merged[key] = merge$1(isObject$1(merged[key]) ? merged[key] : {}, value);
            }
            else {
                merged[key] = value;
            }
        });
        return merged;
    }

    function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

    function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

    /*!
     * Splide.js
     * Version  : 4.1.4
     * License  : MIT
     * Copyright: 2022 Naotoshi Fujita
     */
    var MEDIA_PREFERS_REDUCED_MOTION = "(prefers-reduced-motion: reduce)";
    var CREATED = 1;
    var MOUNTED = 2;
    var IDLE = 3;
    var MOVING = 4;
    var SCROLLING = 5;
    var DRAGGING = 6;
    var DESTROYED = 7;
    var STATES = {
      CREATED: CREATED,
      MOUNTED: MOUNTED,
      IDLE: IDLE,
      MOVING: MOVING,
      SCROLLING: SCROLLING,
      DRAGGING: DRAGGING,
      DESTROYED: DESTROYED
    };

    function empty(array) {
      array.length = 0;
    }

    function slice(arrayLike, start, end) {
      return Array.prototype.slice.call(arrayLike, start, end);
    }

    function apply(func) {
      return func.bind.apply(func, [null].concat(slice(arguments, 1)));
    }

    var nextTick = setTimeout;

    var noop = function noop() {};

    function raf(func) {
      return requestAnimationFrame(func);
    }

    function typeOf(type, subject) {
      return typeof subject === type;
    }

    function isObject(subject) {
      return !isNull(subject) && typeOf("object", subject);
    }

    var isArray = Array.isArray;
    var isFunction = apply(typeOf, "function");
    var isString = apply(typeOf, "string");
    var isUndefined = apply(typeOf, "undefined");

    function isNull(subject) {
      return subject === null;
    }

    function isHTMLElement(subject) {
      try {
        return subject instanceof (subject.ownerDocument.defaultView || window).HTMLElement;
      } catch (e) {
        return false;
      }
    }

    function toArray(value) {
      return isArray(value) ? value : [value];
    }

    function forEach(values, iteratee) {
      toArray(values).forEach(iteratee);
    }

    function includes(array, value) {
      return array.indexOf(value) > -1;
    }

    function push(array, items) {
      array.push.apply(array, toArray(items));
      return array;
    }

    function toggleClass(elm, classes, add) {
      if (elm) {
        forEach(classes, function (name) {
          if (name) {
            elm.classList[add ? "add" : "remove"](name);
          }
        });
      }
    }

    function addClass(elm, classes) {
      toggleClass(elm, isString(classes) ? classes.split(" ") : classes, true);
    }

    function append(parent, children) {
      forEach(children, parent.appendChild.bind(parent));
    }

    function before(nodes, ref) {
      forEach(nodes, function (node) {
        var parent = (ref || node).parentNode;

        if (parent) {
          parent.insertBefore(node, ref);
        }
      });
    }

    function matches(elm, selector) {
      return isHTMLElement(elm) && (elm["msMatchesSelector"] || elm.matches).call(elm, selector);
    }

    function children(parent, selector) {
      var children2 = parent ? slice(parent.children) : [];
      return selector ? children2.filter(function (child) {
        return matches(child, selector);
      }) : children2;
    }

    function child(parent, selector) {
      return selector ? children(parent, selector)[0] : parent.firstElementChild;
    }

    var ownKeys = Object.keys;

    function forOwn(object, iteratee, right) {
      if (object) {
        (right ? ownKeys(object).reverse() : ownKeys(object)).forEach(function (key) {
          key !== "__proto__" && iteratee(object[key], key);
        });
      }

      return object;
    }

    function assign(object) {
      slice(arguments, 1).forEach(function (source) {
        forOwn(source, function (value, key) {
          object[key] = source[key];
        });
      });
      return object;
    }

    function merge(object) {
      slice(arguments, 1).forEach(function (source) {
        forOwn(source, function (value, key) {
          if (isArray(value)) {
            object[key] = value.slice();
          } else if (isObject(value)) {
            object[key] = merge({}, isObject(object[key]) ? object[key] : {}, value);
          } else {
            object[key] = value;
          }
        });
      });
      return object;
    }

    function omit(object, keys) {
      forEach(keys || ownKeys(object), function (key) {
        delete object[key];
      });
    }

    function removeAttribute(elms, attrs) {
      forEach(elms, function (elm) {
        forEach(attrs, function (attr) {
          elm && elm.removeAttribute(attr);
        });
      });
    }

    function setAttribute(elms, attrs, value) {
      if (isObject(attrs)) {
        forOwn(attrs, function (value2, name) {
          setAttribute(elms, name, value2);
        });
      } else {
        forEach(elms, function (elm) {
          isNull(value) || value === "" ? removeAttribute(elm, attrs) : elm.setAttribute(attrs, String(value));
        });
      }
    }

    function create(tag, attrs, parent) {
      var elm = document.createElement(tag);

      if (attrs) {
        isString(attrs) ? addClass(elm, attrs) : setAttribute(elm, attrs);
      }

      parent && append(parent, elm);
      return elm;
    }

    function style(elm, prop, value) {
      if (isUndefined(value)) {
        return getComputedStyle(elm)[prop];
      }

      if (!isNull(value)) {
        elm.style[prop] = "" + value;
      }
    }

    function display(elm, display2) {
      style(elm, "display", display2);
    }

    function focus(elm) {
      elm["setActive"] && elm["setActive"]() || elm.focus({
        preventScroll: true
      });
    }

    function getAttribute(elm, attr) {
      return elm.getAttribute(attr);
    }

    function hasClass(elm, className) {
      return elm && elm.classList.contains(className);
    }

    function rect(target) {
      return target.getBoundingClientRect();
    }

    function remove(nodes) {
      forEach(nodes, function (node) {
        if (node && node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });
    }

    function parseHtml(html) {
      return child(new DOMParser().parseFromString(html, "text/html").body);
    }

    function prevent(e, stopPropagation) {
      e.preventDefault();

      if (stopPropagation) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }

    function query(parent, selector) {
      return parent && parent.querySelector(selector);
    }

    function queryAll(parent, selector) {
      return selector ? slice(parent.querySelectorAll(selector)) : [];
    }

    function removeClass(elm, classes) {
      toggleClass(elm, classes, false);
    }

    function timeOf(e) {
      return e.timeStamp;
    }

    function unit(value) {
      return isString(value) ? value : value ? value + "px" : "";
    }

    var PROJECT_CODE = "splide";
    var DATA_ATTRIBUTE = "data-" + PROJECT_CODE;

    function assert(condition, message) {
      if (!condition) {
        throw new Error("[" + PROJECT_CODE + "] " + (message || ""));
      }
    }

    var min = Math.min,
        max = Math.max,
        floor = Math.floor,
        ceil = Math.ceil,
        abs = Math.abs;

    function approximatelyEqual(x, y, epsilon) {
      return abs(x - y) < epsilon;
    }

    function between(number, x, y, exclusive) {
      var minimum = min(x, y);
      var maximum = max(x, y);
      return exclusive ? minimum < number && number < maximum : minimum <= number && number <= maximum;
    }

    function clamp(number, x, y) {
      var minimum = min(x, y);
      var maximum = max(x, y);
      return min(max(minimum, number), maximum);
    }

    function sign(x) {
      return +(x > 0) - +(x < 0);
    }

    function format(string, replacements) {
      forEach(replacements, function (replacement) {
        string = string.replace("%s", "" + replacement);
      });
      return string;
    }

    function pad(number) {
      return number < 10 ? "0" + number : "" + number;
    }

    var ids = {};

    function uniqueId(prefix) {
      return "" + prefix + pad(ids[prefix] = (ids[prefix] || 0) + 1);
    }

    function EventBinder() {
      var listeners = [];

      function bind(targets, events, callback, options) {
        forEachEvent(targets, events, function (target, event, namespace) {
          var isEventTarget = ("addEventListener" in target);
          var remover = isEventTarget ? target.removeEventListener.bind(target, event, callback, options) : target["removeListener"].bind(target, callback);
          isEventTarget ? target.addEventListener(event, callback, options) : target["addListener"](callback);
          listeners.push([target, event, namespace, callback, remover]);
        });
      }

      function unbind(targets, events, callback) {
        forEachEvent(targets, events, function (target, event, namespace) {
          listeners = listeners.filter(function (listener) {
            if (listener[0] === target && listener[1] === event && listener[2] === namespace && (!callback || listener[3] === callback)) {
              listener[4]();
              return false;
            }

            return true;
          });
        });
      }

      function dispatch(target, type, detail) {
        var e;
        var bubbles = true;

        if (typeof CustomEvent === "function") {
          e = new CustomEvent(type, {
            bubbles: bubbles,
            detail: detail
          });
        } else {
          e = document.createEvent("CustomEvent");
          e.initCustomEvent(type, bubbles, false, detail);
        }

        target.dispatchEvent(e);
        return e;
      }

      function forEachEvent(targets, events, iteratee) {
        forEach(targets, function (target) {
          target && forEach(events, function (events2) {
            events2.split(" ").forEach(function (eventNS) {
              var fragment = eventNS.split(".");
              iteratee(target, fragment[0], fragment[1]);
            });
          });
        });
      }

      function destroy() {
        listeners.forEach(function (data) {
          data[4]();
        });
        empty(listeners);
      }

      return {
        bind: bind,
        unbind: unbind,
        dispatch: dispatch,
        destroy: destroy
      };
    }

    var EVENT_MOUNTED = "mounted";
    var EVENT_READY = "ready";
    var EVENT_MOVE = "move";
    var EVENT_MOVED = "moved";
    var EVENT_CLICK = "click";
    var EVENT_ACTIVE = "active";
    var EVENT_INACTIVE = "inactive";
    var EVENT_VISIBLE = "visible";
    var EVENT_HIDDEN = "hidden";
    var EVENT_REFRESH = "refresh";
    var EVENT_UPDATED = "updated";
    var EVENT_RESIZE = "resize";
    var EVENT_RESIZED = "resized";
    var EVENT_DRAG = "drag";
    var EVENT_DRAGGING = "dragging";
    var EVENT_DRAGGED = "dragged";
    var EVENT_SCROLL = "scroll";
    var EVENT_SCROLLED = "scrolled";
    var EVENT_OVERFLOW = "overflow";
    var EVENT_DESTROY = "destroy";
    var EVENT_ARROWS_MOUNTED = "arrows:mounted";
    var EVENT_ARROWS_UPDATED = "arrows:updated";
    var EVENT_PAGINATION_MOUNTED = "pagination:mounted";
    var EVENT_PAGINATION_UPDATED = "pagination:updated";
    var EVENT_NAVIGATION_MOUNTED = "navigation:mounted";
    var EVENT_AUTOPLAY_PLAY = "autoplay:play";
    var EVENT_AUTOPLAY_PLAYING = "autoplay:playing";
    var EVENT_AUTOPLAY_PAUSE = "autoplay:pause";
    var EVENT_LAZYLOAD_LOADED = "lazyload:loaded";
    var EVENT_SLIDE_KEYDOWN = "sk";
    var EVENT_SHIFTED = "sh";
    var EVENT_END_INDEX_CHANGED = "ei";

    function EventInterface(Splide2) {
      var bus = Splide2 ? Splide2.event.bus : document.createDocumentFragment();
      var binder = EventBinder();

      function on(events, callback) {
        binder.bind(bus, toArray(events).join(" "), function (e) {
          callback.apply(callback, isArray(e.detail) ? e.detail : []);
        });
      }

      function emit(event) {
        binder.dispatch(bus, event, slice(arguments, 1));
      }

      if (Splide2) {
        Splide2.event.on(EVENT_DESTROY, binder.destroy);
      }

      return assign(binder, {
        bus: bus,
        on: on,
        off: apply(binder.unbind, bus),
        emit: emit
      });
    }

    function RequestInterval(interval, onInterval, onUpdate, limit) {
      var now = Date.now;
      var startTime;
      var rate = 0;
      var id;
      var paused = true;
      var count = 0;

      function update() {
        if (!paused) {
          rate = interval ? min((now() - startTime) / interval, 1) : 1;
          onUpdate && onUpdate(rate);

          if (rate >= 1) {
            onInterval();
            startTime = now();

            if (limit && ++count >= limit) {
              return pause();
            }
          }

          id = raf(update);
        }
      }

      function start(resume) {
        resume || cancel();
        startTime = now() - (resume ? rate * interval : 0);
        paused = false;
        id = raf(update);
      }

      function pause() {
        paused = true;
      }

      function rewind() {
        startTime = now();
        rate = 0;

        if (onUpdate) {
          onUpdate(rate);
        }
      }

      function cancel() {
        id && cancelAnimationFrame(id);
        rate = 0;
        id = 0;
        paused = true;
      }

      function set(time) {
        interval = time;
      }

      function isPaused() {
        return paused;
      }

      return {
        start: start,
        rewind: rewind,
        pause: pause,
        cancel: cancel,
        set: set,
        isPaused: isPaused
      };
    }

    function State(initialState) {
      var state = initialState;

      function set(value) {
        state = value;
      }

      function is(states) {
        return includes(toArray(states), state);
      }

      return {
        set: set,
        is: is
      };
    }

    function Throttle(func, duration) {
      var interval = RequestInterval(duration || 0, func, null, 1);
      return function () {
        interval.isPaused() && interval.start();
      };
    }

    function Media(Splide2, Components2, options) {
      var state = Splide2.state;
      var breakpoints = options.breakpoints || {};
      var reducedMotion = options.reducedMotion || {};
      var binder = EventBinder();
      var queries = [];

      function setup() {
        var isMin = options.mediaQuery === "min";
        ownKeys(breakpoints).sort(function (n, m) {
          return isMin ? +n - +m : +m - +n;
        }).forEach(function (key) {
          register(breakpoints[key], "(" + (isMin ? "min" : "max") + "-width:" + key + "px)");
        });
        register(reducedMotion, MEDIA_PREFERS_REDUCED_MOTION);
        update();
      }

      function destroy(completely) {
        if (completely) {
          binder.destroy();
        }
      }

      function register(options2, query) {
        var queryList = matchMedia(query);
        binder.bind(queryList, "change", update);
        queries.push([options2, queryList]);
      }

      function update() {
        var destroyed = state.is(DESTROYED);
        var direction = options.direction;
        var merged = queries.reduce(function (merged2, entry) {
          return merge(merged2, entry[1].matches ? entry[0] : {});
        }, {});
        omit(options);
        set(merged);

        if (options.destroy) {
          Splide2.destroy(options.destroy === "completely");
        } else if (destroyed) {
          destroy(true);
          Splide2.mount();
        } else {
          direction !== options.direction && Splide2.refresh();
        }
      }

      function reduce(enable) {
        if (matchMedia(MEDIA_PREFERS_REDUCED_MOTION).matches) {
          enable ? merge(options, reducedMotion) : omit(options, ownKeys(reducedMotion));
        }
      }

      function set(opts, base, notify) {
        merge(options, opts);
        base && merge(Object.getPrototypeOf(options), opts);

        if (notify || !state.is(CREATED)) {
          Splide2.emit(EVENT_UPDATED, options);
        }
      }

      return {
        setup: setup,
        destroy: destroy,
        reduce: reduce,
        set: set
      };
    }

    var ARROW = "Arrow";
    var ARROW_LEFT = ARROW + "Left";
    var ARROW_RIGHT = ARROW + "Right";
    var ARROW_UP = ARROW + "Up";
    var ARROW_DOWN = ARROW + "Down";
    var RTL = "rtl";
    var TTB = "ttb";
    var ORIENTATION_MAP = {
      width: ["height"],
      left: ["top", "right"],
      right: ["bottom", "left"],
      x: ["y"],
      X: ["Y"],
      Y: ["X"],
      ArrowLeft: [ARROW_UP, ARROW_RIGHT],
      ArrowRight: [ARROW_DOWN, ARROW_LEFT]
    };

    function Direction(Splide2, Components2, options) {
      function resolve(prop, axisOnly, direction) {
        direction = direction || options.direction;
        var index = direction === RTL && !axisOnly ? 1 : direction === TTB ? 0 : -1;
        return ORIENTATION_MAP[prop] && ORIENTATION_MAP[prop][index] || prop.replace(/width|left|right/i, function (match, offset) {
          var replacement = ORIENTATION_MAP[match.toLowerCase()][index] || match;
          return offset > 0 ? replacement.charAt(0).toUpperCase() + replacement.slice(1) : replacement;
        });
      }

      function orient(value) {
        return value * (options.direction === RTL ? 1 : -1);
      }

      return {
        resolve: resolve,
        orient: orient
      };
    }

    var ROLE = "role";
    var TAB_INDEX = "tabindex";
    var DISABLED = "disabled";
    var ARIA_PREFIX = "aria-";
    var ARIA_CONTROLS = ARIA_PREFIX + "controls";
    var ARIA_CURRENT = ARIA_PREFIX + "current";
    var ARIA_SELECTED = ARIA_PREFIX + "selected";
    var ARIA_LABEL = ARIA_PREFIX + "label";
    var ARIA_LABELLEDBY = ARIA_PREFIX + "labelledby";
    var ARIA_HIDDEN = ARIA_PREFIX + "hidden";
    var ARIA_ORIENTATION = ARIA_PREFIX + "orientation";
    var ARIA_ROLEDESCRIPTION = ARIA_PREFIX + "roledescription";
    var ARIA_LIVE = ARIA_PREFIX + "live";
    var ARIA_BUSY = ARIA_PREFIX + "busy";
    var ARIA_ATOMIC = ARIA_PREFIX + "atomic";
    var ALL_ATTRIBUTES = [ROLE, TAB_INDEX, DISABLED, ARIA_CONTROLS, ARIA_CURRENT, ARIA_LABEL, ARIA_LABELLEDBY, ARIA_HIDDEN, ARIA_ORIENTATION, ARIA_ROLEDESCRIPTION];
    var CLASS_PREFIX = PROJECT_CODE + "__";
    var STATUS_CLASS_PREFIX = "is-";
    var CLASS_ROOT = PROJECT_CODE;
    var CLASS_TRACK = CLASS_PREFIX + "track";
    var CLASS_LIST = CLASS_PREFIX + "list";
    var CLASS_SLIDE = CLASS_PREFIX + "slide";
    var CLASS_CLONE = CLASS_SLIDE + "--clone";
    var CLASS_CONTAINER = CLASS_SLIDE + "__container";
    var CLASS_ARROWS = CLASS_PREFIX + "arrows";
    var CLASS_ARROW = CLASS_PREFIX + "arrow";
    var CLASS_ARROW_PREV = CLASS_ARROW + "--prev";
    var CLASS_ARROW_NEXT = CLASS_ARROW + "--next";
    var CLASS_PAGINATION = CLASS_PREFIX + "pagination";
    var CLASS_PAGINATION_PAGE = CLASS_PAGINATION + "__page";
    var CLASS_PROGRESS = CLASS_PREFIX + "progress";
    var CLASS_PROGRESS_BAR = CLASS_PROGRESS + "__bar";
    var CLASS_TOGGLE = CLASS_PREFIX + "toggle";
    var CLASS_SPINNER = CLASS_PREFIX + "spinner";
    var CLASS_SR = CLASS_PREFIX + "sr";
    var CLASS_INITIALIZED = STATUS_CLASS_PREFIX + "initialized";
    var CLASS_ACTIVE = STATUS_CLASS_PREFIX + "active";
    var CLASS_PREV = STATUS_CLASS_PREFIX + "prev";
    var CLASS_NEXT = STATUS_CLASS_PREFIX + "next";
    var CLASS_VISIBLE = STATUS_CLASS_PREFIX + "visible";
    var CLASS_LOADING = STATUS_CLASS_PREFIX + "loading";
    var CLASS_FOCUS_IN = STATUS_CLASS_PREFIX + "focus-in";
    var CLASS_OVERFLOW = STATUS_CLASS_PREFIX + "overflow";
    var STATUS_CLASSES = [CLASS_ACTIVE, CLASS_VISIBLE, CLASS_PREV, CLASS_NEXT, CLASS_LOADING, CLASS_FOCUS_IN, CLASS_OVERFLOW];
    var CLASSES = {
      slide: CLASS_SLIDE,
      clone: CLASS_CLONE,
      arrows: CLASS_ARROWS,
      arrow: CLASS_ARROW,
      prev: CLASS_ARROW_PREV,
      next: CLASS_ARROW_NEXT,
      pagination: CLASS_PAGINATION,
      page: CLASS_PAGINATION_PAGE,
      spinner: CLASS_SPINNER
    };

    function closest(from, selector) {
      if (isFunction(from.closest)) {
        return from.closest(selector);
      }

      var elm = from;

      while (elm && elm.nodeType === 1) {
        if (matches(elm, selector)) {
          break;
        }

        elm = elm.parentElement;
      }

      return elm;
    }

    var FRICTION = 5;
    var LOG_INTERVAL = 200;
    var POINTER_DOWN_EVENTS = "touchstart mousedown";
    var POINTER_MOVE_EVENTS = "touchmove mousemove";
    var POINTER_UP_EVENTS = "touchend touchcancel mouseup click";

    function Elements(Splide2, Components2, options) {
      var _EventInterface = EventInterface(Splide2),
          on = _EventInterface.on,
          bind = _EventInterface.bind;

      var root = Splide2.root;
      var i18n = options.i18n;
      var elements = {};
      var slides = [];
      var rootClasses = [];
      var trackClasses = [];
      var track;
      var list;
      var isUsingKey;

      function setup() {
        collect();
        init();
        update();
      }

      function mount() {
        on(EVENT_REFRESH, destroy);
        on(EVENT_REFRESH, setup);
        on(EVENT_UPDATED, update);
        bind(document, POINTER_DOWN_EVENTS + " keydown", function (e) {
          isUsingKey = e.type === "keydown";
        }, {
          capture: true
        });
        bind(root, "focusin", function () {
          toggleClass(root, CLASS_FOCUS_IN, !!isUsingKey);
        });
      }

      function destroy(completely) {
        var attrs = ALL_ATTRIBUTES.concat("style");
        empty(slides);
        removeClass(root, rootClasses);
        removeClass(track, trackClasses);
        removeAttribute([track, list], attrs);
        removeAttribute(root, completely ? attrs : ["style", ARIA_ROLEDESCRIPTION]);
      }

      function update() {
        removeClass(root, rootClasses);
        removeClass(track, trackClasses);
        rootClasses = getClasses(CLASS_ROOT);
        trackClasses = getClasses(CLASS_TRACK);
        addClass(root, rootClasses);
        addClass(track, trackClasses);
        setAttribute(root, ARIA_LABEL, options.label);
        setAttribute(root, ARIA_LABELLEDBY, options.labelledby);
      }

      function collect() {
        track = find("." + CLASS_TRACK);
        list = child(track, "." + CLASS_LIST);
        assert(track && list, "A track/list element is missing.");
        push(slides, children(list, "." + CLASS_SLIDE + ":not(." + CLASS_CLONE + ")"));
        forOwn({
          arrows: CLASS_ARROWS,
          pagination: CLASS_PAGINATION,
          prev: CLASS_ARROW_PREV,
          next: CLASS_ARROW_NEXT,
          bar: CLASS_PROGRESS_BAR,
          toggle: CLASS_TOGGLE
        }, function (className, key) {
          elements[key] = find("." + className);
        });
        assign(elements, {
          root: root,
          track: track,
          list: list,
          slides: slides
        });
      }

      function init() {
        var id = root.id || uniqueId(PROJECT_CODE);
        var role = options.role;
        root.id = id;
        track.id = track.id || id + "-track";
        list.id = list.id || id + "-list";

        if (!getAttribute(root, ROLE) && root.tagName !== "SECTION" && role) {
          setAttribute(root, ROLE, role);
        }

        setAttribute(root, ARIA_ROLEDESCRIPTION, i18n.carousel);
        setAttribute(list, ROLE, "presentation");
      }

      function find(selector) {
        var elm = query(root, selector);
        return elm && closest(elm, "." + CLASS_ROOT) === root ? elm : void 0;
      }

      function getClasses(base) {
        return [base + "--" + options.type, base + "--" + options.direction, options.drag && base + "--draggable", options.isNavigation && base + "--nav", base === CLASS_ROOT && CLASS_ACTIVE];
      }

      return assign(elements, {
        setup: setup,
        mount: mount,
        destroy: destroy
      });
    }

    var SLIDE = "slide";
    var LOOP = "loop";
    var FADE = "fade";

    function Slide$1(Splide2, index, slideIndex, slide) {
      var event = EventInterface(Splide2);
      var on = event.on,
          emit = event.emit,
          bind = event.bind;
      var Components = Splide2.Components,
          root = Splide2.root,
          options = Splide2.options;
      var isNavigation = options.isNavigation,
          updateOnMove = options.updateOnMove,
          i18n = options.i18n,
          pagination = options.pagination,
          slideFocus = options.slideFocus;
      var resolve = Components.Direction.resolve;
      var styles = getAttribute(slide, "style");
      var label = getAttribute(slide, ARIA_LABEL);
      var isClone = slideIndex > -1;
      var container = child(slide, "." + CLASS_CONTAINER);
      var destroyed;

      function mount() {
        if (!isClone) {
          slide.id = root.id + "-slide" + pad(index + 1);
          setAttribute(slide, ROLE, pagination ? "tabpanel" : "group");
          setAttribute(slide, ARIA_ROLEDESCRIPTION, i18n.slide);
          setAttribute(slide, ARIA_LABEL, label || format(i18n.slideLabel, [index + 1, Splide2.length]));
        }

        listen();
      }

      function listen() {
        bind(slide, "click", apply(emit, EVENT_CLICK, self));
        bind(slide, "keydown", apply(emit, EVENT_SLIDE_KEYDOWN, self));
        on([EVENT_MOVED, EVENT_SHIFTED, EVENT_SCROLLED], update);
        on(EVENT_NAVIGATION_MOUNTED, initNavigation);

        if (updateOnMove) {
          on(EVENT_MOVE, onMove);
        }
      }

      function destroy() {
        destroyed = true;
        event.destroy();
        removeClass(slide, STATUS_CLASSES);
        removeAttribute(slide, ALL_ATTRIBUTES);
        setAttribute(slide, "style", styles);
        setAttribute(slide, ARIA_LABEL, label || "");
      }

      function initNavigation() {
        var controls = Splide2.splides.map(function (target) {
          var Slide2 = target.splide.Components.Slides.getAt(index);
          return Slide2 ? Slide2.slide.id : "";
        }).join(" ");
        setAttribute(slide, ARIA_LABEL, format(i18n.slideX, (isClone ? slideIndex : index) + 1));
        setAttribute(slide, ARIA_CONTROLS, controls);
        setAttribute(slide, ROLE, slideFocus ? "button" : "");
        slideFocus && removeAttribute(slide, ARIA_ROLEDESCRIPTION);
      }

      function onMove() {
        if (!destroyed) {
          update();
        }
      }

      function update() {
        if (!destroyed) {
          var curr = Splide2.index;
          updateActivity();
          updateVisibility();
          toggleClass(slide, CLASS_PREV, index === curr - 1);
          toggleClass(slide, CLASS_NEXT, index === curr + 1);
        }
      }

      function updateActivity() {
        var active = isActive();

        if (active !== hasClass(slide, CLASS_ACTIVE)) {
          toggleClass(slide, CLASS_ACTIVE, active);
          setAttribute(slide, ARIA_CURRENT, isNavigation && active || "");
          emit(active ? EVENT_ACTIVE : EVENT_INACTIVE, self);
        }
      }

      function updateVisibility() {
        var visible = isVisible();
        var hidden = !visible && (!isActive() || isClone);

        if (!Splide2.state.is([MOVING, SCROLLING])) {
          setAttribute(slide, ARIA_HIDDEN, hidden || "");
        }

        setAttribute(queryAll(slide, options.focusableNodes || ""), TAB_INDEX, hidden ? -1 : "");

        if (slideFocus) {
          setAttribute(slide, TAB_INDEX, hidden ? -1 : 0);
        }

        if (visible !== hasClass(slide, CLASS_VISIBLE)) {
          toggleClass(slide, CLASS_VISIBLE, visible);
          emit(visible ? EVENT_VISIBLE : EVENT_HIDDEN, self);
        }

        if (!visible && document.activeElement === slide) {
          var Slide2 = Components.Slides.getAt(Splide2.index);
          Slide2 && focus(Slide2.slide);
        }
      }

      function style$1(prop, value, useContainer) {
        style(useContainer && container || slide, prop, value);
      }

      function isActive() {
        var curr = Splide2.index;
        return curr === index || options.cloneStatus && curr === slideIndex;
      }

      function isVisible() {
        if (Splide2.is(FADE)) {
          return isActive();
        }

        var trackRect = rect(Components.Elements.track);
        var slideRect = rect(slide);
        var left = resolve("left", true);
        var right = resolve("right", true);
        return floor(trackRect[left]) <= ceil(slideRect[left]) && floor(slideRect[right]) <= ceil(trackRect[right]);
      }

      function isWithin(from, distance) {
        var diff = abs(from - index);

        if (!isClone && (options.rewind || Splide2.is(LOOP))) {
          diff = min(diff, Splide2.length - diff);
        }

        return diff <= distance;
      }

      var self = {
        index: index,
        slideIndex: slideIndex,
        slide: slide,
        container: container,
        isClone: isClone,
        mount: mount,
        destroy: destroy,
        update: update,
        style: style$1,
        isWithin: isWithin
      };
      return self;
    }

    function Slides(Splide2, Components2, options) {
      var _EventInterface2 = EventInterface(Splide2),
          on = _EventInterface2.on,
          emit = _EventInterface2.emit,
          bind = _EventInterface2.bind;

      var _Components2$Elements = Components2.Elements,
          slides = _Components2$Elements.slides,
          list = _Components2$Elements.list;
      var Slides2 = [];

      function mount() {
        init();
        on(EVENT_REFRESH, destroy);
        on(EVENT_REFRESH, init);
      }

      function init() {
        slides.forEach(function (slide, index) {
          register(slide, index, -1);
        });
      }

      function destroy() {
        forEach$1(function (Slide2) {
          Slide2.destroy();
        });
        empty(Slides2);
      }

      function update() {
        forEach$1(function (Slide2) {
          Slide2.update();
        });
      }

      function register(slide, index, slideIndex) {
        var object = Slide$1(Splide2, index, slideIndex, slide);
        object.mount();
        Slides2.push(object);
        Slides2.sort(function (Slide1, Slide2) {
          return Slide1.index - Slide2.index;
        });
      }

      function get(excludeClones) {
        return excludeClones ? filter(function (Slide2) {
          return !Slide2.isClone;
        }) : Slides2;
      }

      function getIn(page) {
        var Controller = Components2.Controller;
        var index = Controller.toIndex(page);
        var max = Controller.hasFocus() ? 1 : options.perPage;
        return filter(function (Slide2) {
          return between(Slide2.index, index, index + max - 1);
        });
      }

      function getAt(index) {
        return filter(index)[0];
      }

      function add(items, index) {
        forEach(items, function (slide) {
          if (isString(slide)) {
            slide = parseHtml(slide);
          }

          if (isHTMLElement(slide)) {
            var ref = slides[index];
            ref ? before(slide, ref) : append(list, slide);
            addClass(slide, options.classes.slide);
            observeImages(slide, apply(emit, EVENT_RESIZE));
          }
        });
        emit(EVENT_REFRESH);
      }

      function remove$1(matcher) {
        remove(filter(matcher).map(function (Slide2) {
          return Slide2.slide;
        }));
        emit(EVENT_REFRESH);
      }

      function forEach$1(iteratee, excludeClones) {
        get(excludeClones).forEach(iteratee);
      }

      function filter(matcher) {
        return Slides2.filter(isFunction(matcher) ? matcher : function (Slide2) {
          return isString(matcher) ? matches(Slide2.slide, matcher) : includes(toArray(matcher), Slide2.index);
        });
      }

      function style(prop, value, useContainer) {
        forEach$1(function (Slide2) {
          Slide2.style(prop, value, useContainer);
        });
      }

      function observeImages(elm, callback) {
        var images = queryAll(elm, "img");
        var length = images.length;

        if (length) {
          images.forEach(function (img) {
            bind(img, "load error", function () {
              if (! --length) {
                callback();
              }
            });
          });
        } else {
          callback();
        }
      }

      function getLength(excludeClones) {
        return excludeClones ? slides.length : Slides2.length;
      }

      function isEnough() {
        return Slides2.length > options.perPage;
      }

      return {
        mount: mount,
        destroy: destroy,
        update: update,
        register: register,
        get: get,
        getIn: getIn,
        getAt: getAt,
        add: add,
        remove: remove$1,
        forEach: forEach$1,
        filter: filter,
        style: style,
        getLength: getLength,
        isEnough: isEnough
      };
    }

    function Layout(Splide2, Components2, options) {
      var _EventInterface3 = EventInterface(Splide2),
          on = _EventInterface3.on,
          bind = _EventInterface3.bind,
          emit = _EventInterface3.emit;

      var Slides = Components2.Slides;
      var resolve = Components2.Direction.resolve;
      var _Components2$Elements2 = Components2.Elements,
          root = _Components2$Elements2.root,
          track = _Components2$Elements2.track,
          list = _Components2$Elements2.list;
      var getAt = Slides.getAt,
          styleSlides = Slides.style;
      var vertical;
      var rootRect;
      var overflow;

      function mount() {
        init();
        bind(window, "resize load", Throttle(apply(emit, EVENT_RESIZE)));
        on([EVENT_UPDATED, EVENT_REFRESH], init);
        on(EVENT_RESIZE, resize);
      }

      function init() {
        vertical = options.direction === TTB;
        style(root, "maxWidth", unit(options.width));
        style(track, resolve("paddingLeft"), cssPadding(false));
        style(track, resolve("paddingRight"), cssPadding(true));
        resize(true);
      }

      function resize(force) {
        var newRect = rect(root);

        if (force || rootRect.width !== newRect.width || rootRect.height !== newRect.height) {
          style(track, "height", cssTrackHeight());
          styleSlides(resolve("marginRight"), unit(options.gap));
          styleSlides("width", cssSlideWidth());
          styleSlides("height", cssSlideHeight(), true);
          rootRect = newRect;
          emit(EVENT_RESIZED);

          if (overflow !== (overflow = isOverflow())) {
            toggleClass(root, CLASS_OVERFLOW, overflow);
            emit(EVENT_OVERFLOW, overflow);
          }
        }
      }

      function cssPadding(right) {
        var padding = options.padding;
        var prop = resolve(right ? "right" : "left");
        return padding && unit(padding[prop] || (isObject(padding) ? 0 : padding)) || "0px";
      }

      function cssTrackHeight() {
        var height = "";

        if (vertical) {
          height = cssHeight();
          assert(height, "height or heightRatio is missing.");
          height = "calc(" + height + " - " + cssPadding(false) + " - " + cssPadding(true) + ")";
        }

        return height;
      }

      function cssHeight() {
        return unit(options.height || rect(list).width * options.heightRatio);
      }

      function cssSlideWidth() {
        return options.autoWidth ? null : unit(options.fixedWidth) || (vertical ? "" : cssSlideSize());
      }

      function cssSlideHeight() {
        return unit(options.fixedHeight) || (vertical ? options.autoHeight ? null : cssSlideSize() : cssHeight());
      }

      function cssSlideSize() {
        var gap = unit(options.gap);
        return "calc((100%" + (gap && " + " + gap) + ")/" + (options.perPage || 1) + (gap && " - " + gap) + ")";
      }

      function listSize() {
        return rect(list)[resolve("width")];
      }

      function slideSize(index, withoutGap) {
        var Slide = getAt(index || 0);
        return Slide ? rect(Slide.slide)[resolve("width")] + (withoutGap ? 0 : getGap()) : 0;
      }

      function totalSize(index, withoutGap) {
        var Slide = getAt(index);

        if (Slide) {
          var right = rect(Slide.slide)[resolve("right")];
          var left = rect(list)[resolve("left")];
          return abs(right - left) + (withoutGap ? 0 : getGap());
        }

        return 0;
      }

      function sliderSize(withoutGap) {
        return totalSize(Splide2.length - 1) - totalSize(0) + slideSize(0, withoutGap);
      }

      function getGap() {
        var Slide = getAt(0);
        return Slide && parseFloat(style(Slide.slide, resolve("marginRight"))) || 0;
      }

      function getPadding(right) {
        return parseFloat(style(track, resolve("padding" + (right ? "Right" : "Left")))) || 0;
      }

      function isOverflow() {
        return Splide2.is(FADE) || sliderSize(true) > listSize();
      }

      return {
        mount: mount,
        resize: resize,
        listSize: listSize,
        slideSize: slideSize,
        sliderSize: sliderSize,
        totalSize: totalSize,
        getPadding: getPadding,
        isOverflow: isOverflow
      };
    }

    var MULTIPLIER = 2;

    function Clones(Splide2, Components2, options) {
      var event = EventInterface(Splide2);
      var on = event.on;
      var Elements = Components2.Elements,
          Slides = Components2.Slides;
      var resolve = Components2.Direction.resolve;
      var clones = [];
      var cloneCount;

      function mount() {
        on(EVENT_REFRESH, remount);
        on([EVENT_UPDATED, EVENT_RESIZE], observe);

        if (cloneCount = computeCloneCount()) {
          generate(cloneCount);
          Components2.Layout.resize(true);
        }
      }

      function remount() {
        destroy();
        mount();
      }

      function destroy() {
        remove(clones);
        empty(clones);
        event.destroy();
      }

      function observe() {
        var count = computeCloneCount();

        if (cloneCount !== count) {
          if (cloneCount < count || !count) {
            event.emit(EVENT_REFRESH);
          }
        }
      }

      function generate(count) {
        var slides = Slides.get().slice();
        var length = slides.length;

        if (length) {
          while (slides.length < count) {
            push(slides, slides);
          }

          push(slides.slice(-count), slides.slice(0, count)).forEach(function (Slide, index) {
            var isHead = index < count;
            var clone = cloneDeep(Slide.slide, index);
            isHead ? before(clone, slides[0].slide) : append(Elements.list, clone);
            push(clones, clone);
            Slides.register(clone, index - count + (isHead ? 0 : length), Slide.index);
          });
        }
      }

      function cloneDeep(elm, index) {
        var clone = elm.cloneNode(true);
        addClass(clone, options.classes.clone);
        clone.id = Splide2.root.id + "-clone" + pad(index + 1);
        return clone;
      }

      function computeCloneCount() {
        var clones2 = options.clones;

        if (!Splide2.is(LOOP)) {
          clones2 = 0;
        } else if (isUndefined(clones2)) {
          var fixedSize = options[resolve("fixedWidth")] && Components2.Layout.slideSize(0);
          var fixedCount = fixedSize && ceil(rect(Elements.track)[resolve("width")] / fixedSize);
          clones2 = fixedCount || options[resolve("autoWidth")] && Splide2.length || options.perPage * MULTIPLIER;
        }

        return clones2;
      }

      return {
        mount: mount,
        destroy: destroy
      };
    }

    function Move(Splide2, Components2, options) {
      var _EventInterface4 = EventInterface(Splide2),
          on = _EventInterface4.on,
          emit = _EventInterface4.emit;

      var set = Splide2.state.set;
      var _Components2$Layout = Components2.Layout,
          slideSize = _Components2$Layout.slideSize,
          getPadding = _Components2$Layout.getPadding,
          totalSize = _Components2$Layout.totalSize,
          listSize = _Components2$Layout.listSize,
          sliderSize = _Components2$Layout.sliderSize;
      var _Components2$Directio = Components2.Direction,
          resolve = _Components2$Directio.resolve,
          orient = _Components2$Directio.orient;
      var _Components2$Elements3 = Components2.Elements,
          list = _Components2$Elements3.list,
          track = _Components2$Elements3.track;
      var Transition;

      function mount() {
        Transition = Components2.Transition;
        on([EVENT_MOUNTED, EVENT_RESIZED, EVENT_UPDATED, EVENT_REFRESH], reposition);
      }

      function reposition() {
        if (!Components2.Controller.isBusy()) {
          Components2.Scroll.cancel();
          jump(Splide2.index);
          Components2.Slides.update();
        }
      }

      function move(dest, index, prev, callback) {
        if (dest !== index && canShift(dest > prev)) {
          cancel();
          translate(shift(getPosition(), dest > prev), true);
        }

        set(MOVING);
        emit(EVENT_MOVE, index, prev, dest);
        Transition.start(index, function () {
          set(IDLE);
          emit(EVENT_MOVED, index, prev, dest);
          callback && callback();
        });
      }

      function jump(index) {
        translate(toPosition(index, true));
      }

      function translate(position, preventLoop) {
        if (!Splide2.is(FADE)) {
          var destination = preventLoop ? position : loop(position);
          style(list, "transform", "translate" + resolve("X") + "(" + destination + "px)");
          position !== destination && emit(EVENT_SHIFTED);
        }
      }

      function loop(position) {
        if (Splide2.is(LOOP)) {
          var index = toIndex(position);
          var exceededMax = index > Components2.Controller.getEnd();
          var exceededMin = index < 0;

          if (exceededMin || exceededMax) {
            position = shift(position, exceededMax);
          }
        }

        return position;
      }

      function shift(position, backwards) {
        var excess = position - getLimit(backwards);
        var size = sliderSize();
        position -= orient(size * (ceil(abs(excess) / size) || 1)) * (backwards ? 1 : -1);
        return position;
      }

      function cancel() {
        translate(getPosition(), true);
        Transition.cancel();
      }

      function toIndex(position) {
        var Slides = Components2.Slides.get();
        var index = 0;
        var minDistance = Infinity;

        for (var i = 0; i < Slides.length; i++) {
          var slideIndex = Slides[i].index;
          var distance = abs(toPosition(slideIndex, true) - position);

          if (distance <= minDistance) {
            minDistance = distance;
            index = slideIndex;
          } else {
            break;
          }
        }

        return index;
      }

      function toPosition(index, trimming) {
        var position = orient(totalSize(index - 1) - offset(index));
        return trimming ? trim(position) : position;
      }

      function getPosition() {
        var left = resolve("left");
        return rect(list)[left] - rect(track)[left] + orient(getPadding(false));
      }

      function trim(position) {
        if (options.trimSpace && Splide2.is(SLIDE)) {
          position = clamp(position, 0, orient(sliderSize(true) - listSize()));
        }

        return position;
      }

      function offset(index) {
        var focus = options.focus;
        return focus === "center" ? (listSize() - slideSize(index, true)) / 2 : +focus * slideSize(index) || 0;
      }

      function getLimit(max) {
        return toPosition(max ? Components2.Controller.getEnd() : 0, !!options.trimSpace);
      }

      function canShift(backwards) {
        var shifted = orient(shift(getPosition(), backwards));
        return backwards ? shifted >= 0 : shifted <= list[resolve("scrollWidth")] - rect(track)[resolve("width")];
      }

      function exceededLimit(max, position) {
        position = isUndefined(position) ? getPosition() : position;
        var exceededMin = max !== true && orient(position) < orient(getLimit(false));
        var exceededMax = max !== false && orient(position) > orient(getLimit(true));
        return exceededMin || exceededMax;
      }

      return {
        mount: mount,
        move: move,
        jump: jump,
        translate: translate,
        shift: shift,
        cancel: cancel,
        toIndex: toIndex,
        toPosition: toPosition,
        getPosition: getPosition,
        getLimit: getLimit,
        exceededLimit: exceededLimit,
        reposition: reposition
      };
    }

    function Controller(Splide2, Components2, options) {
      var _EventInterface5 = EventInterface(Splide2),
          on = _EventInterface5.on,
          emit = _EventInterface5.emit;

      var Move = Components2.Move;
      var getPosition = Move.getPosition,
          getLimit = Move.getLimit,
          toPosition = Move.toPosition;
      var _Components2$Slides = Components2.Slides,
          isEnough = _Components2$Slides.isEnough,
          getLength = _Components2$Slides.getLength;
      var omitEnd = options.omitEnd;
      var isLoop = Splide2.is(LOOP);
      var isSlide = Splide2.is(SLIDE);
      var getNext = apply(getAdjacent, false);
      var getPrev = apply(getAdjacent, true);
      var currIndex = options.start || 0;
      var endIndex;
      var prevIndex = currIndex;
      var slideCount;
      var perMove;
      var perPage;

      function mount() {
        init();
        on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], init);
        on(EVENT_RESIZED, onResized);
      }

      function init() {
        slideCount = getLength(true);
        perMove = options.perMove;
        perPage = options.perPage;
        endIndex = getEnd();
        var index = clamp(currIndex, 0, omitEnd ? endIndex : slideCount - 1);

        if (index !== currIndex) {
          currIndex = index;
          Move.reposition();
        }
      }

      function onResized() {
        if (endIndex !== getEnd()) {
          emit(EVENT_END_INDEX_CHANGED);
        }
      }

      function go(control, allowSameIndex, callback) {
        if (!isBusy()) {
          var dest = parse(control);
          var index = loop(dest);

          if (index > -1 && (allowSameIndex || index !== currIndex)) {
            setIndex(index);
            Move.move(dest, index, prevIndex, callback);
          }
        }
      }

      function scroll(destination, duration, snap, callback) {
        Components2.Scroll.scroll(destination, duration, snap, function () {
          var index = loop(Move.toIndex(getPosition()));
          setIndex(omitEnd ? min(index, endIndex) : index);
          callback && callback();
        });
      }

      function parse(control) {
        var index = currIndex;

        if (isString(control)) {
          var _ref = control.match(/([+\-<>])(\d+)?/) || [],
              indicator = _ref[1],
              number = _ref[2];

          if (indicator === "+" || indicator === "-") {
            index = computeDestIndex(currIndex + +("" + indicator + (+number || 1)), currIndex);
          } else if (indicator === ">") {
            index = number ? toIndex(+number) : getNext(true);
          } else if (indicator === "<") {
            index = getPrev(true);
          }
        } else {
          index = isLoop ? control : clamp(control, 0, endIndex);
        }

        return index;
      }

      function getAdjacent(prev, destination) {
        var number = perMove || (hasFocus() ? 1 : perPage);
        var dest = computeDestIndex(currIndex + number * (prev ? -1 : 1), currIndex, !(perMove || hasFocus()));

        if (dest === -1 && isSlide) {
          if (!approximatelyEqual(getPosition(), getLimit(!prev), 1)) {
            return prev ? 0 : endIndex;
          }
        }

        return destination ? dest : loop(dest);
      }

      function computeDestIndex(dest, from, snapPage) {
        if (isEnough() || hasFocus()) {
          var index = computeMovableDestIndex(dest);

          if (index !== dest) {
            from = dest;
            dest = index;
            snapPage = false;
          }

          if (dest < 0 || dest > endIndex) {
            if (!perMove && (between(0, dest, from, true) || between(endIndex, from, dest, true))) {
              dest = toIndex(toPage(dest));
            } else {
              if (isLoop) {
                dest = snapPage ? dest < 0 ? -(slideCount % perPage || perPage) : slideCount : dest;
              } else if (options.rewind) {
                dest = dest < 0 ? endIndex : 0;
              } else {
                dest = -1;
              }
            }
          } else {
            if (snapPage && dest !== from) {
              dest = toIndex(toPage(from) + (dest < from ? -1 : 1));
            }
          }
        } else {
          dest = -1;
        }

        return dest;
      }

      function computeMovableDestIndex(dest) {
        if (isSlide && options.trimSpace === "move" && dest !== currIndex) {
          var position = getPosition();

          while (position === toPosition(dest, true) && between(dest, 0, Splide2.length - 1, !options.rewind)) {
            dest < currIndex ? --dest : ++dest;
          }
        }

        return dest;
      }

      function loop(index) {
        return isLoop ? (index + slideCount) % slideCount || 0 : index;
      }

      function getEnd() {
        var end = slideCount - (hasFocus() || isLoop && perMove ? 1 : perPage);

        while (omitEnd && end-- > 0) {
          if (toPosition(slideCount - 1, true) !== toPosition(end, true)) {
            end++;
            break;
          }
        }

        return clamp(end, 0, slideCount - 1);
      }

      function toIndex(page) {
        return clamp(hasFocus() ? page : perPage * page, 0, endIndex);
      }

      function toPage(index) {
        return hasFocus() ? min(index, endIndex) : floor((index >= endIndex ? slideCount - 1 : index) / perPage);
      }

      function toDest(destination) {
        var closest = Move.toIndex(destination);
        return isSlide ? clamp(closest, 0, endIndex) : closest;
      }

      function setIndex(index) {
        if (index !== currIndex) {
          prevIndex = currIndex;
          currIndex = index;
        }
      }

      function getIndex(prev) {
        return prev ? prevIndex : currIndex;
      }

      function hasFocus() {
        return !isUndefined(options.focus) || options.isNavigation;
      }

      function isBusy() {
        return Splide2.state.is([MOVING, SCROLLING]) && !!options.waitForTransition;
      }

      return {
        mount: mount,
        go: go,
        scroll: scroll,
        getNext: getNext,
        getPrev: getPrev,
        getAdjacent: getAdjacent,
        getEnd: getEnd,
        setIndex: setIndex,
        getIndex: getIndex,
        toIndex: toIndex,
        toPage: toPage,
        toDest: toDest,
        hasFocus: hasFocus,
        isBusy: isBusy
      };
    }

    var XML_NAME_SPACE = "http://www.w3.org/2000/svg";
    var PATH = "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z";
    var SIZE = 40;

    function Arrows(Splide2, Components2, options) {
      var event = EventInterface(Splide2);
      var on = event.on,
          bind = event.bind,
          emit = event.emit;
      var classes = options.classes,
          i18n = options.i18n;
      var Elements = Components2.Elements,
          Controller = Components2.Controller;
      var placeholder = Elements.arrows,
          track = Elements.track;
      var wrapper = placeholder;
      var prev = Elements.prev;
      var next = Elements.next;
      var created;
      var wrapperClasses;
      var arrows = {};

      function mount() {
        init();
        on(EVENT_UPDATED, remount);
      }

      function remount() {
        destroy();
        mount();
      }

      function init() {
        var enabled = options.arrows;

        if (enabled && !(prev && next)) {
          createArrows();
        }

        if (prev && next) {
          assign(arrows, {
            prev: prev,
            next: next
          });
          display(wrapper, enabled ? "" : "none");
          addClass(wrapper, wrapperClasses = CLASS_ARROWS + "--" + options.direction);

          if (enabled) {
            listen();
            update();
            setAttribute([prev, next], ARIA_CONTROLS, track.id);
            emit(EVENT_ARROWS_MOUNTED, prev, next);
          }
        }
      }

      function destroy() {
        event.destroy();
        removeClass(wrapper, wrapperClasses);

        if (created) {
          remove(placeholder ? [prev, next] : wrapper);
          prev = next = null;
        } else {
          removeAttribute([prev, next], ALL_ATTRIBUTES);
        }
      }

      function listen() {
        on([EVENT_MOUNTED, EVENT_MOVED, EVENT_REFRESH, EVENT_SCROLLED, EVENT_END_INDEX_CHANGED], update);
        bind(next, "click", apply(go, ">"));
        bind(prev, "click", apply(go, "<"));
      }

      function go(control) {
        Controller.go(control, true);
      }

      function createArrows() {
        wrapper = placeholder || create("div", classes.arrows);
        prev = createArrow(true);
        next = createArrow(false);
        created = true;
        append(wrapper, [prev, next]);
        !placeholder && before(wrapper, track);
      }

      function createArrow(prev2) {
        var arrow = "<button class=\"" + classes.arrow + " " + (prev2 ? classes.prev : classes.next) + "\" type=\"button\"><svg xmlns=\"" + XML_NAME_SPACE + "\" viewBox=\"0 0 " + SIZE + " " + SIZE + "\" width=\"" + SIZE + "\" height=\"" + SIZE + "\" focusable=\"false\"><path d=\"" + (options.arrowPath || PATH) + "\" />";
        return parseHtml(arrow);
      }

      function update() {
        if (prev && next) {
          var index = Splide2.index;
          var prevIndex = Controller.getPrev();
          var nextIndex = Controller.getNext();
          var prevLabel = prevIndex > -1 && index < prevIndex ? i18n.last : i18n.prev;
          var nextLabel = nextIndex > -1 && index > nextIndex ? i18n.first : i18n.next;
          prev.disabled = prevIndex < 0;
          next.disabled = nextIndex < 0;
          setAttribute(prev, ARIA_LABEL, prevLabel);
          setAttribute(next, ARIA_LABEL, nextLabel);
          emit(EVENT_ARROWS_UPDATED, prev, next, prevIndex, nextIndex);
        }
      }

      return {
        arrows: arrows,
        mount: mount,
        destroy: destroy,
        update: update
      };
    }

    var INTERVAL_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-interval";

    function Autoplay(Splide2, Components2, options) {
      var _EventInterface6 = EventInterface(Splide2),
          on = _EventInterface6.on,
          bind = _EventInterface6.bind,
          emit = _EventInterface6.emit;

      var interval = RequestInterval(options.interval, Splide2.go.bind(Splide2, ">"), onAnimationFrame);
      var isPaused = interval.isPaused;
      var Elements = Components2.Elements,
          _Components2$Elements4 = Components2.Elements,
          root = _Components2$Elements4.root,
          toggle = _Components2$Elements4.toggle;
      var autoplay = options.autoplay;
      var hovered;
      var focused;
      var stopped = autoplay === "pause";

      function mount() {
        if (autoplay) {
          listen();
          toggle && setAttribute(toggle, ARIA_CONTROLS, Elements.track.id);
          stopped || play();
          update();
        }
      }

      function listen() {
        if (options.pauseOnHover) {
          bind(root, "mouseenter mouseleave", function (e) {
            hovered = e.type === "mouseenter";
            autoToggle();
          });
        }

        if (options.pauseOnFocus) {
          bind(root, "focusin focusout", function (e) {
            focused = e.type === "focusin";
            autoToggle();
          });
        }

        if (toggle) {
          bind(toggle, "click", function () {
            stopped ? play() : pause(true);
          });
        }

        on([EVENT_MOVE, EVENT_SCROLL, EVENT_REFRESH], interval.rewind);
        on(EVENT_MOVE, onMove);
      }

      function play() {
        if (isPaused() && Components2.Slides.isEnough()) {
          interval.start(!options.resetProgress);
          focused = hovered = stopped = false;
          update();
          emit(EVENT_AUTOPLAY_PLAY);
        }
      }

      function pause(stop) {
        if (stop === void 0) {
          stop = true;
        }

        stopped = !!stop;
        update();

        if (!isPaused()) {
          interval.pause();
          emit(EVENT_AUTOPLAY_PAUSE);
        }
      }

      function autoToggle() {
        if (!stopped) {
          hovered || focused ? pause(false) : play();
        }
      }

      function update() {
        if (toggle) {
          toggleClass(toggle, CLASS_ACTIVE, !stopped);
          setAttribute(toggle, ARIA_LABEL, options.i18n[stopped ? "play" : "pause"]);
        }
      }

      function onAnimationFrame(rate) {
        var bar = Elements.bar;
        bar && style(bar, "width", rate * 100 + "%");
        emit(EVENT_AUTOPLAY_PLAYING, rate);
      }

      function onMove(index) {
        var Slide = Components2.Slides.getAt(index);
        interval.set(Slide && +getAttribute(Slide.slide, INTERVAL_DATA_ATTRIBUTE) || options.interval);
      }

      return {
        mount: mount,
        destroy: interval.cancel,
        play: play,
        pause: pause,
        isPaused: isPaused
      };
    }

    function Cover(Splide2, Components2, options) {
      var _EventInterface7 = EventInterface(Splide2),
          on = _EventInterface7.on;

      function mount() {
        if (options.cover) {
          on(EVENT_LAZYLOAD_LOADED, apply(toggle, true));
          on([EVENT_MOUNTED, EVENT_UPDATED, EVENT_REFRESH], apply(cover, true));
        }
      }

      function cover(cover2) {
        Components2.Slides.forEach(function (Slide) {
          var img = child(Slide.container || Slide.slide, "img");

          if (img && img.src) {
            toggle(cover2, img, Slide);
          }
        });
      }

      function toggle(cover2, img, Slide) {
        Slide.style("background", cover2 ? "center/cover no-repeat url(\"" + img.src + "\")" : "", true);
        display(img, cover2 ? "none" : "");
      }

      return {
        mount: mount,
        destroy: apply(cover, false)
      };
    }

    var BOUNCE_DIFF_THRESHOLD = 10;
    var BOUNCE_DURATION = 600;
    var FRICTION_FACTOR = 0.6;
    var BASE_VELOCITY = 1.5;
    var MIN_DURATION = 800;

    function Scroll(Splide2, Components2, options) {
      var _EventInterface8 = EventInterface(Splide2),
          on = _EventInterface8.on,
          emit = _EventInterface8.emit;

      var set = Splide2.state.set;
      var Move = Components2.Move;
      var getPosition = Move.getPosition,
          getLimit = Move.getLimit,
          exceededLimit = Move.exceededLimit,
          translate = Move.translate;
      var isSlide = Splide2.is(SLIDE);
      var interval;
      var callback;
      var friction = 1;

      function mount() {
        on(EVENT_MOVE, clear);
        on([EVENT_UPDATED, EVENT_REFRESH], cancel);
      }

      function scroll(destination, duration, snap, onScrolled, noConstrain) {
        var from = getPosition();
        clear();

        if (snap && (!isSlide || !exceededLimit())) {
          var size = Components2.Layout.sliderSize();
          var offset = sign(destination) * size * floor(abs(destination) / size) || 0;
          destination = Move.toPosition(Components2.Controller.toDest(destination % size)) + offset;
        }

        var noDistance = approximatelyEqual(from, destination, 1);
        friction = 1;
        duration = noDistance ? 0 : duration || max(abs(destination - from) / BASE_VELOCITY, MIN_DURATION);
        callback = onScrolled;
        interval = RequestInterval(duration, onEnd, apply(update, from, destination, noConstrain), 1);
        set(SCROLLING);
        emit(EVENT_SCROLL);
        interval.start();
      }

      function onEnd() {
        set(IDLE);
        callback && callback();
        emit(EVENT_SCROLLED);
      }

      function update(from, to, noConstrain, rate) {
        var position = getPosition();
        var target = from + (to - from) * easing(rate);
        var diff = (target - position) * friction;
        translate(position + diff);

        if (isSlide && !noConstrain && exceededLimit()) {
          friction *= FRICTION_FACTOR;

          if (abs(diff) < BOUNCE_DIFF_THRESHOLD) {
            scroll(getLimit(exceededLimit(true)), BOUNCE_DURATION, false, callback, true);
          }
        }
      }

      function clear() {
        if (interval) {
          interval.cancel();
        }
      }

      function cancel() {
        if (interval && !interval.isPaused()) {
          clear();
          onEnd();
        }
      }

      function easing(t) {
        var easingFunc = options.easingFunc;
        return easingFunc ? easingFunc(t) : 1 - Math.pow(1 - t, 4);
      }

      return {
        mount: mount,
        destroy: clear,
        scroll: scroll,
        cancel: cancel
      };
    }

    var SCROLL_LISTENER_OPTIONS = {
      passive: false,
      capture: true
    };

    function Drag(Splide2, Components2, options) {
      var _EventInterface9 = EventInterface(Splide2),
          on = _EventInterface9.on,
          emit = _EventInterface9.emit,
          bind = _EventInterface9.bind,
          unbind = _EventInterface9.unbind;

      var state = Splide2.state;
      var Move = Components2.Move,
          Scroll = Components2.Scroll,
          Controller = Components2.Controller,
          track = Components2.Elements.track,
          reduce = Components2.Media.reduce;
      var _Components2$Directio2 = Components2.Direction,
          resolve = _Components2$Directio2.resolve,
          orient = _Components2$Directio2.orient;
      var getPosition = Move.getPosition,
          exceededLimit = Move.exceededLimit;
      var basePosition;
      var baseEvent;
      var prevBaseEvent;
      var isFree;
      var dragging;
      var exceeded = false;
      var clickPrevented;
      var disabled;
      var target;

      function mount() {
        bind(track, POINTER_MOVE_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
        bind(track, POINTER_UP_EVENTS, noop, SCROLL_LISTENER_OPTIONS);
        bind(track, POINTER_DOWN_EVENTS, onPointerDown, SCROLL_LISTENER_OPTIONS);
        bind(track, "click", onClick, {
          capture: true
        });
        bind(track, "dragstart", prevent);
        on([EVENT_MOUNTED, EVENT_UPDATED], init);
      }

      function init() {
        var drag = options.drag;
        disable(!drag);
        isFree = drag === "free";
      }

      function onPointerDown(e) {
        clickPrevented = false;

        if (!disabled) {
          var isTouch = isTouchEvent(e);

          if (isDraggable(e.target) && (isTouch || !e.button)) {
            if (!Controller.isBusy()) {
              target = isTouch ? track : window;
              dragging = state.is([MOVING, SCROLLING]);
              prevBaseEvent = null;
              bind(target, POINTER_MOVE_EVENTS, onPointerMove, SCROLL_LISTENER_OPTIONS);
              bind(target, POINTER_UP_EVENTS, onPointerUp, SCROLL_LISTENER_OPTIONS);
              Move.cancel();
              Scroll.cancel();
              save(e);
            } else {
              prevent(e, true);
            }
          }
        }
      }

      function onPointerMove(e) {
        if (!state.is(DRAGGING)) {
          state.set(DRAGGING);
          emit(EVENT_DRAG);
        }

        if (e.cancelable) {
          if (dragging) {
            Move.translate(basePosition + constrain(diffCoord(e)));
            var expired = diffTime(e) > LOG_INTERVAL;
            var hasExceeded = exceeded !== (exceeded = exceededLimit());

            if (expired || hasExceeded) {
              save(e);
            }

            clickPrevented = true;
            emit(EVENT_DRAGGING);
            prevent(e);
          } else if (isSliderDirection(e)) {
            dragging = shouldStart(e);
            prevent(e);
          }
        }
      }

      function onPointerUp(e) {
        if (state.is(DRAGGING)) {
          state.set(IDLE);
          emit(EVENT_DRAGGED);
        }

        if (dragging) {
          move(e);
          prevent(e);
        }

        unbind(target, POINTER_MOVE_EVENTS, onPointerMove);
        unbind(target, POINTER_UP_EVENTS, onPointerUp);
        dragging = false;
      }

      function onClick(e) {
        if (!disabled && clickPrevented) {
          prevent(e, true);
        }
      }

      function save(e) {
        prevBaseEvent = baseEvent;
        baseEvent = e;
        basePosition = getPosition();
      }

      function move(e) {
        var velocity = computeVelocity(e);
        var destination = computeDestination(velocity);
        var rewind = options.rewind && options.rewindByDrag;
        reduce(false);

        if (isFree) {
          Controller.scroll(destination, 0, options.snap);
        } else if (Splide2.is(FADE)) {
          Controller.go(orient(sign(velocity)) < 0 ? rewind ? "<" : "-" : rewind ? ">" : "+");
        } else if (Splide2.is(SLIDE) && exceeded && rewind) {
          Controller.go(exceededLimit(true) ? ">" : "<");
        } else {
          Controller.go(Controller.toDest(destination), true);
        }

        reduce(true);
      }

      function shouldStart(e) {
        var thresholds = options.dragMinThreshold;
        var isObj = isObject(thresholds);
        var mouse = isObj && thresholds.mouse || 0;
        var touch = (isObj ? thresholds.touch : +thresholds) || 10;
        return abs(diffCoord(e)) > (isTouchEvent(e) ? touch : mouse);
      }

      function isSliderDirection(e) {
        return abs(diffCoord(e)) > abs(diffCoord(e, true));
      }

      function computeVelocity(e) {
        if (Splide2.is(LOOP) || !exceeded) {
          var time = diffTime(e);

          if (time && time < LOG_INTERVAL) {
            return diffCoord(e) / time;
          }
        }

        return 0;
      }

      function computeDestination(velocity) {
        return getPosition() + sign(velocity) * min(abs(velocity) * (options.flickPower || 600), isFree ? Infinity : Components2.Layout.listSize() * (options.flickMaxPages || 1));
      }

      function diffCoord(e, orthogonal) {
        return coordOf(e, orthogonal) - coordOf(getBaseEvent(e), orthogonal);
      }

      function diffTime(e) {
        return timeOf(e) - timeOf(getBaseEvent(e));
      }

      function getBaseEvent(e) {
        return baseEvent === e && prevBaseEvent || baseEvent;
      }

      function coordOf(e, orthogonal) {
        return (isTouchEvent(e) ? e.changedTouches[0] : e)["page" + resolve(orthogonal ? "Y" : "X")];
      }

      function constrain(diff) {
        return diff / (exceeded && Splide2.is(SLIDE) ? FRICTION : 1);
      }

      function isDraggable(target2) {
        var noDrag = options.noDrag;
        return !matches(target2, "." + CLASS_PAGINATION_PAGE + ", ." + CLASS_ARROW) && (!noDrag || !matches(target2, noDrag));
      }

      function isTouchEvent(e) {
        return typeof TouchEvent !== "undefined" && e instanceof TouchEvent;
      }

      function isDragging() {
        return dragging;
      }

      function disable(value) {
        disabled = value;
      }

      return {
        mount: mount,
        disable: disable,
        isDragging: isDragging
      };
    }

    var NORMALIZATION_MAP = {
      Spacebar: " ",
      Right: ARROW_RIGHT,
      Left: ARROW_LEFT,
      Up: ARROW_UP,
      Down: ARROW_DOWN
    };

    function normalizeKey(key) {
      key = isString(key) ? key : key.key;
      return NORMALIZATION_MAP[key] || key;
    }

    var KEYBOARD_EVENT = "keydown";

    function Keyboard(Splide2, Components2, options) {
      var _EventInterface10 = EventInterface(Splide2),
          on = _EventInterface10.on,
          bind = _EventInterface10.bind,
          unbind = _EventInterface10.unbind;

      var root = Splide2.root;
      var resolve = Components2.Direction.resolve;
      var target;
      var disabled;

      function mount() {
        init();
        on(EVENT_UPDATED, destroy);
        on(EVENT_UPDATED, init);
        on(EVENT_MOVE, onMove);
      }

      function init() {
        var keyboard = options.keyboard;

        if (keyboard) {
          target = keyboard === "global" ? window : root;
          bind(target, KEYBOARD_EVENT, onKeydown);
        }
      }

      function destroy() {
        unbind(target, KEYBOARD_EVENT);
      }

      function disable(value) {
        disabled = value;
      }

      function onMove() {
        var _disabled = disabled;
        disabled = true;
        nextTick(function () {
          disabled = _disabled;
        });
      }

      function onKeydown(e) {
        if (!disabled) {
          var key = normalizeKey(e);

          if (key === resolve(ARROW_LEFT)) {
            Splide2.go("<");
          } else if (key === resolve(ARROW_RIGHT)) {
            Splide2.go(">");
          }
        }
      }

      return {
        mount: mount,
        destroy: destroy,
        disable: disable
      };
    }

    var SRC_DATA_ATTRIBUTE = DATA_ATTRIBUTE + "-lazy";
    var SRCSET_DATA_ATTRIBUTE = SRC_DATA_ATTRIBUTE + "-srcset";
    var IMAGE_SELECTOR = "[" + SRC_DATA_ATTRIBUTE + "], [" + SRCSET_DATA_ATTRIBUTE + "]";

    function LazyLoad(Splide2, Components2, options) {
      var _EventInterface11 = EventInterface(Splide2),
          on = _EventInterface11.on,
          off = _EventInterface11.off,
          bind = _EventInterface11.bind,
          emit = _EventInterface11.emit;

      var isSequential = options.lazyLoad === "sequential";
      var events = [EVENT_MOVED, EVENT_SCROLLED];
      var entries = [];

      function mount() {
        if (options.lazyLoad) {
          init();
          on(EVENT_REFRESH, init);
        }
      }

      function init() {
        empty(entries);
        register();

        if (isSequential) {
          loadNext();
        } else {
          off(events);
          on(events, check);
          check();
        }
      }

      function register() {
        Components2.Slides.forEach(function (Slide) {
          queryAll(Slide.slide, IMAGE_SELECTOR).forEach(function (img) {
            var src = getAttribute(img, SRC_DATA_ATTRIBUTE);
            var srcset = getAttribute(img, SRCSET_DATA_ATTRIBUTE);

            if (src !== img.src || srcset !== img.srcset) {
              var className = options.classes.spinner;
              var parent = img.parentElement;
              var spinner = child(parent, "." + className) || create("span", className, parent);
              entries.push([img, Slide, spinner]);
              img.src || display(img, "none");
            }
          });
        });
      }

      function check() {
        entries = entries.filter(function (data) {
          var distance = options.perPage * ((options.preloadPages || 1) + 1) - 1;
          return data[1].isWithin(Splide2.index, distance) ? load(data) : true;
        });
        entries.length || off(events);
      }

      function load(data) {
        var img = data[0];
        addClass(data[1].slide, CLASS_LOADING);
        bind(img, "load error", apply(onLoad, data));
        setAttribute(img, "src", getAttribute(img, SRC_DATA_ATTRIBUTE));
        setAttribute(img, "srcset", getAttribute(img, SRCSET_DATA_ATTRIBUTE));
        removeAttribute(img, SRC_DATA_ATTRIBUTE);
        removeAttribute(img, SRCSET_DATA_ATTRIBUTE);
      }

      function onLoad(data, e) {
        var img = data[0],
            Slide = data[1];
        removeClass(Slide.slide, CLASS_LOADING);

        if (e.type !== "error") {
          remove(data[2]);
          display(img, "");
          emit(EVENT_LAZYLOAD_LOADED, img, Slide);
          emit(EVENT_RESIZE);
        }

        isSequential && loadNext();
      }

      function loadNext() {
        entries.length && load(entries.shift());
      }

      return {
        mount: mount,
        destroy: apply(empty, entries),
        check: check
      };
    }

    function Pagination(Splide2, Components2, options) {
      var event = EventInterface(Splide2);
      var on = event.on,
          emit = event.emit,
          bind = event.bind;
      var Slides = Components2.Slides,
          Elements = Components2.Elements,
          Controller = Components2.Controller;
      var hasFocus = Controller.hasFocus,
          getIndex = Controller.getIndex,
          go = Controller.go;
      var resolve = Components2.Direction.resolve;
      var placeholder = Elements.pagination;
      var items = [];
      var list;
      var paginationClasses;

      function mount() {
        destroy();
        on([EVENT_UPDATED, EVENT_REFRESH, EVENT_END_INDEX_CHANGED], mount);
        var enabled = options.pagination;
        placeholder && display(placeholder, enabled ? "" : "none");

        if (enabled) {
          on([EVENT_MOVE, EVENT_SCROLL, EVENT_SCROLLED], update);
          createPagination();
          update();
          emit(EVENT_PAGINATION_MOUNTED, {
            list: list,
            items: items
          }, getAt(Splide2.index));
        }
      }

      function destroy() {
        if (list) {
          remove(placeholder ? slice(list.children) : list);
          removeClass(list, paginationClasses);
          empty(items);
          list = null;
        }

        event.destroy();
      }

      function createPagination() {
        var length = Splide2.length;
        var classes = options.classes,
            i18n = options.i18n,
            perPage = options.perPage;
        var max = hasFocus() ? Controller.getEnd() + 1 : ceil(length / perPage);
        list = placeholder || create("ul", classes.pagination, Elements.track.parentElement);
        addClass(list, paginationClasses = CLASS_PAGINATION + "--" + getDirection());
        setAttribute(list, ROLE, "tablist");
        setAttribute(list, ARIA_LABEL, i18n.select);
        setAttribute(list, ARIA_ORIENTATION, getDirection() === TTB ? "vertical" : "");

        for (var i = 0; i < max; i++) {
          var li = create("li", null, list);
          var button = create("button", {
            class: classes.page,
            type: "button"
          }, li);
          var controls = Slides.getIn(i).map(function (Slide) {
            return Slide.slide.id;
          });
          var text = !hasFocus() && perPage > 1 ? i18n.pageX : i18n.slideX;
          bind(button, "click", apply(onClick, i));

          if (options.paginationKeyboard) {
            bind(button, "keydown", apply(onKeydown, i));
          }

          setAttribute(li, ROLE, "presentation");
          setAttribute(button, ROLE, "tab");
          setAttribute(button, ARIA_CONTROLS, controls.join(" "));
          setAttribute(button, ARIA_LABEL, format(text, i + 1));
          setAttribute(button, TAB_INDEX, -1);
          items.push({
            li: li,
            button: button,
            page: i
          });
        }
      }

      function onClick(page) {
        go(">" + page, true);
      }

      function onKeydown(page, e) {
        var length = items.length;
        var key = normalizeKey(e);
        var dir = getDirection();
        var nextPage = -1;

        if (key === resolve(ARROW_RIGHT, false, dir)) {
          nextPage = ++page % length;
        } else if (key === resolve(ARROW_LEFT, false, dir)) {
          nextPage = (--page + length) % length;
        } else if (key === "Home") {
          nextPage = 0;
        } else if (key === "End") {
          nextPage = length - 1;
        }

        var item = items[nextPage];

        if (item) {
          focus(item.button);
          go(">" + nextPage);
          prevent(e, true);
        }
      }

      function getDirection() {
        return options.paginationDirection || options.direction;
      }

      function getAt(index) {
        return items[Controller.toPage(index)];
      }

      function update() {
        var prev = getAt(getIndex(true));
        var curr = getAt(getIndex());

        if (prev) {
          var button = prev.button;
          removeClass(button, CLASS_ACTIVE);
          removeAttribute(button, ARIA_SELECTED);
          setAttribute(button, TAB_INDEX, -1);
        }

        if (curr) {
          var _button = curr.button;
          addClass(_button, CLASS_ACTIVE);
          setAttribute(_button, ARIA_SELECTED, true);
          setAttribute(_button, TAB_INDEX, "");
        }

        emit(EVENT_PAGINATION_UPDATED, {
          list: list,
          items: items
        }, prev, curr);
      }

      return {
        items: items,
        mount: mount,
        destroy: destroy,
        getAt: getAt,
        update: update
      };
    }

    var TRIGGER_KEYS = [" ", "Enter"];

    function Sync(Splide2, Components2, options) {
      var isNavigation = options.isNavigation,
          slideFocus = options.slideFocus;
      var events = [];

      function mount() {
        Splide2.splides.forEach(function (target) {
          if (!target.isParent) {
            sync(Splide2, target.splide);
            sync(target.splide, Splide2);
          }
        });

        if (isNavigation) {
          navigate();
        }
      }

      function destroy() {
        events.forEach(function (event) {
          event.destroy();
        });
        empty(events);
      }

      function remount() {
        destroy();
        mount();
      }

      function sync(splide, target) {
        var event = EventInterface(splide);
        event.on(EVENT_MOVE, function (index, prev, dest) {
          target.go(target.is(LOOP) ? dest : index);
        });
        events.push(event);
      }

      function navigate() {
        var event = EventInterface(Splide2);
        var on = event.on;
        on(EVENT_CLICK, onClick);
        on(EVENT_SLIDE_KEYDOWN, onKeydown);
        on([EVENT_MOUNTED, EVENT_UPDATED], update);
        events.push(event);
        event.emit(EVENT_NAVIGATION_MOUNTED, Splide2.splides);
      }

      function update() {
        setAttribute(Components2.Elements.list, ARIA_ORIENTATION, options.direction === TTB ? "vertical" : "");
      }

      function onClick(Slide) {
        Splide2.go(Slide.index);
      }

      function onKeydown(Slide, e) {
        if (includes(TRIGGER_KEYS, normalizeKey(e))) {
          onClick(Slide);
          prevent(e);
        }
      }

      return {
        setup: apply(Components2.Media.set, {
          slideFocus: isUndefined(slideFocus) ? isNavigation : slideFocus
        }, true),
        mount: mount,
        destroy: destroy,
        remount: remount
      };
    }

    function Wheel(Splide2, Components2, options) {
      var _EventInterface12 = EventInterface(Splide2),
          bind = _EventInterface12.bind;

      var lastTime = 0;

      function mount() {
        if (options.wheel) {
          bind(Components2.Elements.track, "wheel", onWheel, SCROLL_LISTENER_OPTIONS);
        }
      }

      function onWheel(e) {
        if (e.cancelable) {
          var deltaY = e.deltaY;
          var backwards = deltaY < 0;
          var timeStamp = timeOf(e);

          var _min = options.wheelMinThreshold || 0;

          var sleep = options.wheelSleep || 0;

          if (abs(deltaY) > _min && timeStamp - lastTime > sleep) {
            Splide2.go(backwards ? "<" : ">");
            lastTime = timeStamp;
          }

          shouldPrevent(backwards) && prevent(e);
        }
      }

      function shouldPrevent(backwards) {
        return !options.releaseWheel || Splide2.state.is(MOVING) || Components2.Controller.getAdjacent(backwards) !== -1;
      }

      return {
        mount: mount
      };
    }

    var SR_REMOVAL_DELAY = 90;

    function Live(Splide2, Components2, options) {
      var _EventInterface13 = EventInterface(Splide2),
          on = _EventInterface13.on;

      var track = Components2.Elements.track;
      var enabled = options.live && !options.isNavigation;
      var sr = create("span", CLASS_SR);
      var interval = RequestInterval(SR_REMOVAL_DELAY, apply(toggle, false));

      function mount() {
        if (enabled) {
          disable(!Components2.Autoplay.isPaused());
          setAttribute(track, ARIA_ATOMIC, true);
          sr.textContent = "\u2026";
          on(EVENT_AUTOPLAY_PLAY, apply(disable, true));
          on(EVENT_AUTOPLAY_PAUSE, apply(disable, false));
          on([EVENT_MOVED, EVENT_SCROLLED], apply(toggle, true));
        }
      }

      function toggle(active) {
        setAttribute(track, ARIA_BUSY, active);

        if (active) {
          append(track, sr);
          interval.start();
        } else {
          remove(sr);
          interval.cancel();
        }
      }

      function destroy() {
        removeAttribute(track, [ARIA_LIVE, ARIA_ATOMIC, ARIA_BUSY]);
        remove(sr);
      }

      function disable(disabled) {
        if (enabled) {
          setAttribute(track, ARIA_LIVE, disabled ? "off" : "polite");
        }
      }

      return {
        mount: mount,
        disable: disable,
        destroy: destroy
      };
    }

    var ComponentConstructors = /*#__PURE__*/Object.freeze({
      __proto__: null,
      Media: Media,
      Direction: Direction,
      Elements: Elements,
      Slides: Slides,
      Layout: Layout,
      Clones: Clones,
      Move: Move,
      Controller: Controller,
      Arrows: Arrows,
      Autoplay: Autoplay,
      Cover: Cover,
      Scroll: Scroll,
      Drag: Drag,
      Keyboard: Keyboard,
      LazyLoad: LazyLoad,
      Pagination: Pagination,
      Sync: Sync,
      Wheel: Wheel,
      Live: Live
    });
    var I18N = {
      prev: "Previous slide",
      next: "Next slide",
      first: "Go to first slide",
      last: "Go to last slide",
      slideX: "Go to slide %s",
      pageX: "Go to page %s",
      play: "Start autoplay",
      pause: "Pause autoplay",
      carousel: "carousel",
      slide: "slide",
      select: "Select a slide to show",
      slideLabel: "%s of %s"
    };
    var DEFAULTS = {
      type: "slide",
      role: "region",
      speed: 400,
      perPage: 1,
      cloneStatus: true,
      arrows: true,
      pagination: true,
      paginationKeyboard: true,
      interval: 5e3,
      pauseOnHover: true,
      pauseOnFocus: true,
      resetProgress: true,
      easing: "cubic-bezier(0.25, 1, 0.5, 1)",
      drag: true,
      direction: "ltr",
      trimSpace: true,
      focusableNodes: "a, button, textarea, input, select, iframe",
      live: true,
      classes: CLASSES,
      i18n: I18N,
      reducedMotion: {
        speed: 0,
        rewindSpeed: 0,
        autoplay: "pause"
      }
    };

    function Fade(Splide2, Components2, options) {
      var Slides = Components2.Slides;

      function mount() {
        EventInterface(Splide2).on([EVENT_MOUNTED, EVENT_REFRESH], init);
      }

      function init() {
        Slides.forEach(function (Slide) {
          Slide.style("transform", "translateX(-" + 100 * Slide.index + "%)");
        });
      }

      function start(index, done) {
        Slides.style("transition", "opacity " + options.speed + "ms " + options.easing);
        nextTick(done);
      }

      return {
        mount: mount,
        start: start,
        cancel: noop
      };
    }

    function Slide(Splide2, Components2, options) {
      var Move = Components2.Move,
          Controller = Components2.Controller,
          Scroll = Components2.Scroll;
      var list = Components2.Elements.list;
      var transition = apply(style, list, "transition");
      var endCallback;

      function mount() {
        EventInterface(Splide2).bind(list, "transitionend", function (e) {
          if (e.target === list && endCallback) {
            cancel();
            endCallback();
          }
        });
      }

      function start(index, done) {
        var destination = Move.toPosition(index, true);
        var position = Move.getPosition();
        var speed = getSpeed(index);

        if (abs(destination - position) >= 1 && speed >= 1) {
          if (options.useScroll) {
            Scroll.scroll(destination, speed, false, done);
          } else {
            transition("transform " + speed + "ms " + options.easing);
            Move.translate(destination, true);
            endCallback = done;
          }
        } else {
          Move.jump(index);
          done();
        }
      }

      function cancel() {
        transition("");
        Scroll.cancel();
      }

      function getSpeed(index) {
        var rewindSpeed = options.rewindSpeed;

        if (Splide2.is(SLIDE) && rewindSpeed) {
          var prev = Controller.getIndex(true);
          var end = Controller.getEnd();

          if (prev === 0 && index >= end || prev >= end && index === 0) {
            return rewindSpeed;
          }
        }

        return options.speed;
      }

      return {
        mount: mount,
        start: start,
        cancel: cancel
      };
    }

    var _Splide = /*#__PURE__*/function () {
      function _Splide(target, options) {
        this.event = EventInterface();
        this.Components = {};
        this.state = State(CREATED);
        this.splides = [];
        this._o = {};
        this._E = {};
        var root = isString(target) ? query(document, target) : target;
        assert(root, root + " is invalid.");
        this.root = root;
        options = merge({
          label: getAttribute(root, ARIA_LABEL) || "",
          labelledby: getAttribute(root, ARIA_LABELLEDBY) || ""
        }, DEFAULTS, _Splide.defaults, options || {});

        try {
          merge(options, JSON.parse(getAttribute(root, DATA_ATTRIBUTE)));
        } catch (e) {
          assert(false, "Invalid JSON");
        }

        this._o = Object.create(merge({}, options));
      }

      var _proto = _Splide.prototype;

      _proto.mount = function mount(Extensions, Transition) {
        var _this = this;

        var state = this.state,
            Components2 = this.Components;
        assert(state.is([CREATED, DESTROYED]), "Already mounted!");
        state.set(CREATED);
        this._C = Components2;
        this._T = Transition || this._T || (this.is(FADE) ? Fade : Slide);
        this._E = Extensions || this._E;
        var Constructors = assign({}, ComponentConstructors, this._E, {
          Transition: this._T
        });
        forOwn(Constructors, function (Component, key) {
          var component = Component(_this, Components2, _this._o);
          Components2[key] = component;
          component.setup && component.setup();
        });
        forOwn(Components2, function (component) {
          component.mount && component.mount();
        });
        this.emit(EVENT_MOUNTED);
        addClass(this.root, CLASS_INITIALIZED);
        state.set(IDLE);
        this.emit(EVENT_READY);
        return this;
      };

      _proto.sync = function sync(splide) {
        this.splides.push({
          splide: splide
        });
        splide.splides.push({
          splide: this,
          isParent: true
        });

        if (this.state.is(IDLE)) {
          this._C.Sync.remount();

          splide.Components.Sync.remount();
        }

        return this;
      };

      _proto.go = function go(control) {
        this._C.Controller.go(control);

        return this;
      };

      _proto.on = function on(events, callback) {
        this.event.on(events, callback);
        return this;
      };

      _proto.off = function off(events) {
        this.event.off(events);
        return this;
      };

      _proto.emit = function emit(event) {
        var _this$event;

        (_this$event = this.event).emit.apply(_this$event, [event].concat(slice(arguments, 1)));

        return this;
      };

      _proto.add = function add(slides, index) {
        this._C.Slides.add(slides, index);

        return this;
      };

      _proto.remove = function remove(matcher) {
        this._C.Slides.remove(matcher);

        return this;
      };

      _proto.is = function is(type) {
        return this._o.type === type;
      };

      _proto.refresh = function refresh() {
        this.emit(EVENT_REFRESH);
        return this;
      };

      _proto.destroy = function destroy(completely) {
        if (completely === void 0) {
          completely = true;
        }

        var event = this.event,
            state = this.state;

        if (state.is(CREATED)) {
          EventInterface(this).on(EVENT_READY, this.destroy.bind(this, completely));
        } else {
          forOwn(this._C, function (component) {
            component.destroy && component.destroy(completely);
          }, true);
          event.emit(EVENT_DESTROY);
          event.destroy();
          completely && empty(this.splides);
          state.set(DESTROYED);
        }

        return this;
      };

      _createClass(_Splide, [{
        key: "options",
        get: function get() {
          return this._o;
        },
        set: function set(options) {
          this._C.Media.set(options, true, true);
        }
      }, {
        key: "length",
        get: function get() {
          return this._C.Slides.getLength(true);
        }
      }, {
        key: "index",
        get: function get() {
          return this._C.Controller.getIndex();
        }
      }]);

      return _Splide;
    }();

    var Splide = _Splide;
    Splide.defaults = {};
    Splide.STATES = STATES;

    const EVENTS_WITHOUT_ARGS = [
        EVENT_MOUNTED,
        EVENT_REFRESH,
        EVENT_RESIZE,
        EVENT_RESIZED,
        EVENT_DRAG,
        EVENT_DRAGGING,
        EVENT_DRAGGED,
        EVENT_SCROLL,
        EVENT_SCROLLED,
        EVENT_DESTROY,
        EVENT_AUTOPLAY_PLAY,
        EVENT_AUTOPLAY_PAUSE,
    ];
    /**
     * Binds Splide events to the svelte dispatcher.
     *
     * @since 0.1.0
     *
     * @param splide     - A splide instance.
     * @param dispatchFn - A dispatch function created by `createEventDispatcher()`.
     */
    function bind(splide, dispatchFn) {
        const dispatch = (event, detail = {}) => {
            dispatchFn(transform(event), { splide, ...detail });
        };
        splide.on(EVENT_CLICK, (Slide, e) => {
            dispatch(EVENT_CLICK, { Slide, e });
        });
        splide.on(EVENT_MOVE, (index, prev, dest) => {
            dispatch(EVENT_MOVE, { index, prev, dest });
        });
        splide.on(EVENT_MOVED, (index, prev, dest) => {
            dispatch(EVENT_MOVED, { index, prev, dest });
        });
        splide.on(EVENT_ACTIVE, (Slide) => {
            dispatch(EVENT_ACTIVE, { Slide });
        });
        splide.on(EVENT_INACTIVE, (Slide) => {
            dispatch(EVENT_INACTIVE, { Slide });
        });
        splide.on(EVENT_VISIBLE, (Slide) => {
            dispatch(EVENT_VISIBLE, { Slide });
        });
        splide.on(EVENT_HIDDEN, (Slide) => {
            dispatch(EVENT_HIDDEN, { Slide });
        });
        splide.on(EVENT_UPDATED, (options) => {
            dispatch(EVENT_UPDATED, options);
        });
        splide.on(EVENT_ARROWS_MOUNTED, (prev, next) => {
            dispatch(EVENT_ARROWS_MOUNTED, { prev, next });
        });
        splide.on(EVENT_ARROWS_UPDATED, (prev, next) => {
            dispatch(EVENT_ARROWS_UPDATED, { prev, next });
        });
        splide.on(EVENT_PAGINATION_MOUNTED, (data, item) => {
            dispatch(EVENT_PAGINATION_MOUNTED, { data, item });
        });
        splide.on(EVENT_PAGINATION_UPDATED, (data, prev, curr) => {
            dispatch(EVENT_PAGINATION_UPDATED, { data, prev, curr });
        });
        splide.on(EVENT_NAVIGATION_MOUNTED, (splides) => {
            dispatch(EVENT_NAVIGATION_MOUNTED, { splides });
        });
        splide.on(EVENT_AUTOPLAY_PLAYING, (rate) => {
            dispatch(EVENT_AUTOPLAY_PLAYING, { rate });
        });
        splide.on(EVENT_LAZYLOAD_LOADED, (img, Slide) => {
            dispatch(EVENT_LAZYLOAD_LOADED, { img, Slide });
        });
        EVENTS_WITHOUT_ARGS.forEach(event => {
            splide.on(event, () => {
                dispatch(event);
            });
        });
    }
    /**
     * Transforms Splide event names to the camel case.
     *
     * @since 0.1.0
     *
     * @param event - An event name to transform.
     *
     * @return A transformed event name.
     */
    function transform(event) {
        return event.split(':')
            .map((fragment, index) => {
            return index > 0 ? fragment.charAt(0).toUpperCase() + fragment.slice(1) : fragment;
        })
            .join('')
            .replace('Lazyload', 'LazyLoad');
    }

    /* node_modules/.pnpm/@splidejs+svelte-splide@0.2.9/node_modules/@splidejs/svelte-splide/components/Splide/Splide.svelte generated by Svelte v3.43.0 */
    const file$5 = "node_modules/.pnpm/@splidejs+svelte-splide@0.2.9/node_modules/@splidejs/svelte-splide/components/Splide/Splide.svelte";

    // (102:2) { :else }
    function create_else_block(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(102:2) { :else }",
    		ctx
    	});

    	return block;
    }

    // (98:2) { #if hasTrack }
    function create_if_block$2(ctx) {
    	let splidetrack;
    	let current;

    	splidetrack = new SplideTrack({
    			props: {
    				$$slots: { default: [create_default_slot$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(splidetrack.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(splidetrack, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const splidetrack_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				splidetrack_changes.$$scope = { dirty, ctx };
    			}

    			splidetrack.$set(splidetrack_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(splidetrack.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(splidetrack.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(splidetrack, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(98:2) { #if hasTrack }",
    		ctx
    	});

    	return block;
    }

    // (99:4) <SplideTrack>
    function create_default_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[13], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[13],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[13], dirty, null),
    						null
    					);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(99:4) <SplideTrack>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let div_class_value;
    	let current;
    	const if_block_creators = [create_if_block$2, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*hasTrack*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	let div_levels = [
    		{
    			class: div_class_value = classNames('splide', /*className*/ ctx[0])
    		},
    		/*$$restProps*/ ctx[3]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign$1(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			set_attributes(div, div_data);
    			add_location(div, file$5, 92, 0, 2389);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			/*div_binding*/ ctx[12](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = classNames('splide', /*className*/ ctx[0]))) && { class: div_class_value },
    				dirty & /*$$restProps*/ 8 && /*$$restProps*/ ctx[3]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			/*div_binding*/ ctx[12](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class","options","splide","extensions","transition","hasTrack","go","sync"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Splide', slots, ['default']);
    	let { class: className = undefined } = $$props;
    	let { options = {} } = $$props;
    	let { splide = undefined } = $$props;
    	let { extensions = undefined } = $$props;
    	let { transition = undefined } = $$props;
    	let { hasTrack = true } = $$props;

    	/**
     * A dispatcher function.
     * The `createEventDispatcher` type assertion does not accept a type alias.
     * If specified, the svelte kit fails to generate a type of `events` and it will be `CustomEvent<any>`.
     * Also, the svelte action does not provide the way to specify event types.
     */
    	const dispatch = createEventDispatcher();

    	/**
     * The root element.
     */
    	let root;

    	/**
     * Holds the previous slide elements.
     */
    	let prevSlides;

    	/**
     * Holds the previous options.
     */
    	let prevOptions = merge$1({}, options);

    	onMount(() => {
    		$$invalidate(4, splide = new Splide(root, options));
    		bind(splide, dispatch);
    		splide.mount(extensions, transition);
    		prevSlides = getSlides(splide);
    		return () => splide.destroy();
    	});

    	afterUpdate(() => {
    		if (splide) {
    			const newSlides = getSlides(splide);

    			if (!isEqualShallow(prevSlides, newSlides)) {
    				splide.refresh();
    				prevSlides = newSlides.slice();
    			}
    		}
    	});

    	function go(control) {
    		splide?.go(control);
    	}

    	function sync(target) {
    		splide?.sync(target);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			root = $$value;
    			$$invalidate(2, root);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(3, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ('options' in $$new_props) $$invalidate(5, options = $$new_props.options);
    		if ('splide' in $$new_props) $$invalidate(4, splide = $$new_props.splide);
    		if ('extensions' in $$new_props) $$invalidate(6, extensions = $$new_props.extensions);
    		if ('transition' in $$new_props) $$invalidate(7, transition = $$new_props.transition);
    		if ('hasTrack' in $$new_props) $$invalidate(1, hasTrack = $$new_props.hasTrack);
    		if ('$$scope' in $$new_props) $$invalidate(13, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		classNames,
    		getSlides,
    		isEqualDeep,
    		isEqualShallow,
    		merge: merge$1,
    		Splide,
    		afterUpdate,
    		createEventDispatcher,
    		onMount,
    		bind,
    		SplideTrack,
    		className,
    		options,
    		splide,
    		extensions,
    		transition,
    		hasTrack,
    		dispatch,
    		root,
    		prevSlides,
    		prevOptions,
    		go,
    		sync
    	});

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
    		if ('options' in $$props) $$invalidate(5, options = $$new_props.options);
    		if ('splide' in $$props) $$invalidate(4, splide = $$new_props.splide);
    		if ('extensions' in $$props) $$invalidate(6, extensions = $$new_props.extensions);
    		if ('transition' in $$props) $$invalidate(7, transition = $$new_props.transition);
    		if ('hasTrack' in $$props) $$invalidate(1, hasTrack = $$new_props.hasTrack);
    		if ('root' in $$props) $$invalidate(2, root = $$new_props.root);
    		if ('prevSlides' in $$props) prevSlides = $$new_props.prevSlides;
    		if ('prevOptions' in $$props) $$invalidate(10, prevOptions = $$new_props.prevOptions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*splide, prevOptions, options*/ 1072) {
    			/**
     * Updates splide options only when they have difference with previous options.
     */
    			if (splide && !isEqualDeep(prevOptions, options)) {
    				$$invalidate(4, splide.options = options, splide);
    				$$invalidate(10, prevOptions = merge$1({}, prevOptions));
    			}
    		}
    	};

    	return [
    		className,
    		hasTrack,
    		root,
    		$$restProps,
    		splide,
    		options,
    		extensions,
    		transition,
    		go,
    		sync,
    		prevOptions,
    		slots,
    		div_binding,
    		$$scope
    	];
    }

    class Splide_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			class: 0,
    			options: 5,
    			splide: 4,
    			extensions: 6,
    			transition: 7,
    			hasTrack: 1,
    			go: 8,
    			sync: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Splide_1",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get class() {
    		return this.$$.ctx[0];
    	}

    	set class(className) {
    		this.$$set({ class: className });
    		flush();
    	}

    	get options() {
    		return this.$$.ctx[5];
    	}

    	set options(options) {
    		this.$$set({ options });
    		flush();
    	}

    	get splide() {
    		return this.$$.ctx[4];
    	}

    	set splide(splide) {
    		this.$$set({ splide });
    		flush();
    	}

    	get extensions() {
    		return this.$$.ctx[6];
    	}

    	set extensions(extensions) {
    		this.$$set({ extensions });
    		flush();
    	}

    	get transition() {
    		return this.$$.ctx[7];
    	}

    	set transition(transition) {
    		this.$$set({ transition });
    		flush();
    	}

    	get hasTrack() {
    		return this.$$.ctx[1];
    	}

    	set hasTrack(hasTrack) {
    		this.$$set({ hasTrack });
    		flush();
    	}

    	get go() {
    		return this.$$.ctx[8];
    	}

    	set go(value) {
    		throw new Error("<Splide>: Cannot set read-only property 'go'");
    	}

    	get sync() {
    		return this.$$.ctx[9];
    	}

    	set sync(value) {
    		throw new Error("<Splide>: Cannot set read-only property 'sync'");
    	}
    }

    /* node_modules/.pnpm/@splidejs+svelte-splide@0.2.9/node_modules/@splidejs/svelte-splide/components/SplideTrack/SplideTrack.svelte generated by Svelte v3.43.0 */
    const file$4 = "node_modules/.pnpm/@splidejs+svelte-splide@0.2.9/node_modules/@splidejs/svelte-splide/components/SplideTrack/SplideTrack.svelte";

    function create_fragment$4(ctx) {
    	let div;
    	let ul;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	let div_levels = [
    		{
    			class: div_class_value = classNames('splide__track', /*className*/ ctx[0])
    		},
    		/*$$restProps*/ ctx[1]
    	];

    	let div_data = {};

    	for (let i = 0; i < div_levels.length; i += 1) {
    		div_data = assign$1(div_data, div_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "class", "splide__list");
    			add_location(ul, file$4, 6, 2, 204);
    			set_attributes(div, div_data);
    			add_location(div, file$4, 5, 0, 125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(div, div_data = get_spread_update(div_levels, [
    				(!current || dirty & /*className*/ 1 && div_class_value !== (div_class_value = classNames('splide__track', /*className*/ ctx[0]))) && { class: div_class_value },
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SplideTrack', slots, ['default']);
    	let { class: className = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classNames, className });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [className, $$restProps, $$scope, slots];
    }

    class SplideTrack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { class: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SplideTrack",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get class() {
    		throw new Error("<SplideTrack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SplideTrack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules/.pnpm/@splidejs+svelte-splide@0.2.9/node_modules/@splidejs/svelte-splide/components/SplideSlide/SplideSlide.svelte generated by Svelte v3.43.0 */
    const file$3 = "node_modules/.pnpm/@splidejs+svelte-splide@0.2.9/node_modules/@splidejs/svelte-splide/components/SplideSlide/SplideSlide.svelte";

    function create_fragment$3(ctx) {
    	let li;
    	let li_class_value;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	let li_levels = [
    		{
    			class: li_class_value = classNames('splide__slide', /*className*/ ctx[0])
    		},
    		/*$$restProps*/ ctx[1]
    	];

    	let li_data = {};

    	for (let i = 0; i < li_levels.length; i += 1) {
    		li_data = assign$1(li_data, li_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			if (default_slot) default_slot.c();
    			set_attributes(li, li_data);
    			add_location(li, file$3, 5, 0, 125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);

    			if (default_slot) {
    				default_slot.m(li, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
    					update_slot_base(
    						default_slot,
    						default_slot_template,
    						ctx,
    						/*$$scope*/ ctx[2],
    						!current
    						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
    						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
    						null
    					);
    				}
    			}

    			set_attributes(li, li_data = get_spread_update(li_levels, [
    				(!current || dirty & /*className*/ 1 && li_class_value !== (li_class_value = classNames('splide__slide', /*className*/ ctx[0]))) && { class: li_class_value },
    				dirty & /*$$restProps*/ 2 && /*$$restProps*/ ctx[1]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	const omit_props_names = ["class"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SplideSlide', slots, ['default']);
    	let { class: className = undefined } = $$props;

    	$$self.$$set = $$new_props => {
    		$$props = assign$1(assign$1({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(1, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ('class' in $$new_props) $$invalidate(0, className = $$new_props.class);
    		if ('$$scope' in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({ classNames, className });

    	$$self.$inject_state = $$new_props => {
    		if ('className' in $$props) $$invalidate(0, className = $$new_props.className);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [className, $$restProps, $$scope, slots];
    }

    class SplideSlide extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { class: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SplideSlide",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get class() {
    		throw new Error("<SplideSlide>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set class(value) {
    		throw new Error("<SplideSlide>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/pages/magicchaos/index.svelte generated by Svelte v3.43.0 */

    const { document: document_1 } = globals;
    const file$2 = "src/pages/magicchaos/index.svelte";

    // (142:8) <SplideSlide>
    function create_default_slot_10(ctx) {
    	let img;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "slide svelte-s2ak5w");
    			attr_dev(img, "data-splide-lazy", "/img/magic-hero.png");
    			attr_dev(img, "alt", "");
    			add_location(img, file$2, 142, 10, 3917);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(142:8) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (149:8) <SplideSlide>
    function create_default_slot_9(ctx) {
    	let img;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "slide svelte-s2ak5w");
    			attr_dev(img, "data-splide-lazy", "/img/magic-hero.png");
    			attr_dev(img, "alt", "");
    			add_location(img, file$2, 149, 10, 4095);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(149:8) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (156:8) <SplideSlide>
    function create_default_slot_8(ctx) {
    	let img;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "slide svelte-s2ak5w");
    			attr_dev(img, "data-splide-lazy", "/img/magic-hero.png");
    			attr_dev(img, "alt", "");
    			add_location(img, file$2, 156, 10, 4273);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(156:8) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (163:8) <SplideSlide>
    function create_default_slot_7(ctx) {
    	let img;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "slide svelte-s2ak5w");
    			attr_dev(img, "data-splide-lazy", "/img/magic-hero.png");
    			attr_dev(img, "alt", "");
    			add_location(img, file$2, 163, 10, 4451);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(163:8) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (170:8) <SplideSlide>
    function create_default_slot_6(ctx) {
    	let img;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "slide svelte-s2ak5w");
    			attr_dev(img, "data-splide-lazy", "/img/magic-hero.png");
    			attr_dev(img, "alt", "");
    			add_location(img, file$2, 170, 10, 4629);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(170:8) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (177:8) <SplideSlide>
    function create_default_slot_5(ctx) {
    	let img;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "slide svelte-s2ak5w");
    			attr_dev(img, "data-splide-lazy", "/img/magic-hero.png");
    			attr_dev(img, "alt", "");
    			add_location(img, file$2, 177, 10, 4807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(177:8) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (184:8) <SplideSlide>
    function create_default_slot_4(ctx) {
    	let img;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "slide svelte-s2ak5w");
    			attr_dev(img, "data-splide-lazy", "/img/magic-hero.png");
    			attr_dev(img, "alt", "");
    			add_location(img, file$2, 184, 10, 4985);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(184:8) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (191:8) <SplideSlide>
    function create_default_slot_3(ctx) {
    	let img;

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "class", "slide svelte-s2ak5w");
    			attr_dev(img, "data-splide-lazy", "/img/magic-hero.png");
    			attr_dev(img, "alt", "");
    			add_location(img, file$2, 191, 10, 5163);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(191:8) <SplideSlide>",
    		ctx
    	});

    	return block;
    }

    // (125:6) <Splide         aria-label=""         options={{           type: "loop",           focus: "center",           padding: "30vw",           breakpoints: {             900: {               padding: "10vw",             },           },           gap: "5vw",           autoHeight: true,           lazyLoad: "nearby",           // autoWidth: true,         }}       >
    function create_default_slot_2(ctx) {
    	let splideslide0;
    	let t0;
    	let splideslide1;
    	let t1;
    	let splideslide2;
    	let t2;
    	let splideslide3;
    	let t3;
    	let splideslide4;
    	let t4;
    	let splideslide5;
    	let t5;
    	let splideslide6;
    	let t6;
    	let splideslide7;
    	let current;

    	splideslide0 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide1 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide2 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide3 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide4 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide5 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide6 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	splideslide7 = new SplideSlide({
    			props: {
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(splideslide0.$$.fragment);
    			t0 = space();
    			create_component(splideslide1.$$.fragment);
    			t1 = space();
    			create_component(splideslide2.$$.fragment);
    			t2 = space();
    			create_component(splideslide3.$$.fragment);
    			t3 = space();
    			create_component(splideslide4.$$.fragment);
    			t4 = space();
    			create_component(splideslide5.$$.fragment);
    			t5 = space();
    			create_component(splideslide6.$$.fragment);
    			t6 = space();
    			create_component(splideslide7.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(splideslide0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(splideslide1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(splideslide2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(splideslide3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(splideslide4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(splideslide5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(splideslide6, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(splideslide7, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const splideslide0_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splideslide0_changes.$$scope = { dirty, ctx };
    			}

    			splideslide0.$set(splideslide0_changes);
    			const splideslide1_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splideslide1_changes.$$scope = { dirty, ctx };
    			}

    			splideslide1.$set(splideslide1_changes);
    			const splideslide2_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splideslide2_changes.$$scope = { dirty, ctx };
    			}

    			splideslide2.$set(splideslide2_changes);
    			const splideslide3_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splideslide3_changes.$$scope = { dirty, ctx };
    			}

    			splideslide3.$set(splideslide3_changes);
    			const splideslide4_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splideslide4_changes.$$scope = { dirty, ctx };
    			}

    			splideslide4.$set(splideslide4_changes);
    			const splideslide5_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splideslide5_changes.$$scope = { dirty, ctx };
    			}

    			splideslide5.$set(splideslide5_changes);
    			const splideslide6_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splideslide6_changes.$$scope = { dirty, ctx };
    			}

    			splideslide6.$set(splideslide6_changes);
    			const splideslide7_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splideslide7_changes.$$scope = { dirty, ctx };
    			}

    			splideslide7.$set(splideslide7_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(splideslide0.$$.fragment, local);
    			transition_in(splideslide1.$$.fragment, local);
    			transition_in(splideslide2.$$.fragment, local);
    			transition_in(splideslide3.$$.fragment, local);
    			transition_in(splideslide4.$$.fragment, local);
    			transition_in(splideslide5.$$.fragment, local);
    			transition_in(splideslide6.$$.fragment, local);
    			transition_in(splideslide7.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(splideslide0.$$.fragment, local);
    			transition_out(splideslide1.$$.fragment, local);
    			transition_out(splideslide2.$$.fragment, local);
    			transition_out(splideslide3.$$.fragment, local);
    			transition_out(splideslide4.$$.fragment, local);
    			transition_out(splideslide5.$$.fragment, local);
    			transition_out(splideslide6.$$.fragment, local);
    			transition_out(splideslide7.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(splideslide0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(splideslide1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(splideslide2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(splideslide3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(splideslide4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(splideslide5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(splideslide6, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(splideslide7, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(125:6) <Splide         aria-label=\\\"\\\"         options={{           type: \\\"loop\\\",           focus: \\\"center\\\",           padding: \\\"30vw\\\",           breakpoints: {             900: {               padding: \\\"10vw\\\",             },           },           gap: \\\"5vw\\\",           autoHeight: true,           lazyLoad: \\\"nearby\\\",           // autoWidth: true,         }}       >",
    		ctx
    	});

    	return block;
    }

    // (204:6) <Button href="#">
    function create_default_slot_1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text$1("STEAM");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(204:6) <Button href=\\\"#\\\">",
    		ctx
    	});

    	return block;
    }

    // (209:6) <Button href="#">
    function create_default_slot(ctx) {
    	let svg;
    	let use;
    	let t;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = text$1(" Discord");
    			xlink_attr(use, "xlink:href", "/img/discord.svg#shape");
    			add_location(use, file$2, 215, 10, 5747);
    			attr_dev(svg, "width", "27");
    			attr_dev(svg, "height", "21");
    			attr_dev(svg, "viewBox", "0 0 27 21");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$2, 209, 8, 5604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, use);
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(209:6) <Button href=\\\"#\\\">",
    		ctx
    	});

    	return block;
    }

    // (229:6) {#if loadTwitterWidget}
    function create_if_block$1(ctx) {
    	let script;
    	let script_src_value;

    	const block = {
    		c: function create() {
    			script = element("script");
    			script.async = true;
    			if (!src_url_equal(script.src, script_src_value = "https://platform.twitter.com/widgets.js")) attr_dev(script, "src", script_src_value);
    			attr_dev(script, "charset", "utf-8");
    			add_location(script, file$2, 229, 8, 6159);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, script, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(script);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(229:6) {#if loadTwitterWidget}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let meta;
    	let link0;
    	let link1;
    	let link2;
    	let link3;
    	let link4;
    	let script;
    	let script_src_value;
    	let t0;
    	let img0;
    	let img0_src_value;
    	let t1;
    	let img1;
    	let img1_src_value;
    	let t2;
    	let div8;
    	let div2;
    	let div0;
    	let t3;
    	let div1;
    	let img2;
    	let img2_src_value;
    	let t4;
    	let img3;
    	let img3_src_value;
    	let t5;
    	let img4;
    	let img4_src_value;
    	let t6;
    	let img5;
    	let img5_src_value;
    	let t7;
    	let img6;
    	let img6_src_value;
    	let t8;
    	let div7;
    	let section0;
    	let h1;
    	let t9;
    	let wbr0;
    	let t10;
    	let wbr1;
    	let t11;
    	let br;
    	let t12;
    	let wbr2;
    	let t13;
    	let wbr3;
    	let t14;
    	let t15;
    	let section1;
    	let h20;
    	let t17;
    	let div3;
    	let yframe;
    	let t18;
    	let section2;
    	let h21;
    	let t20;
    	let splide;
    	let t21;
    	let p0;
    	let t23;
    	let section3;
    	let h22;
    	let t25;
    	let p1;
    	let t27;
    	let button0;
    	let t28;
    	let section4;
    	let h23;
    	let t30;
    	let p2;
    	let t32;
    	let button1;
    	let t33;
    	let section5;
    	let a0;
    	let t35;
    	let t36;
    	let div6;
    	let a1;
    	let svg0;
    	let use0;
    	let t37;
    	let div4;
    	let t39;
    	let a2;
    	let svg1;
    	let use1;
    	let t40;
    	let div5;
    	let current;

    	yframe = new Youtube_iframe({
    			props: { id: "foh7rj5YI_E", sizes: "60vw" },
    			$$inline: true
    		});

    	splide = new Splide_1({
    			props: {
    				"aria-label": "",
    				options: {
    					type: "loop",
    					focus: "center",
    					padding: "30vw",
    					breakpoints: { 900: { padding: "10vw" } },
    					gap: "5vw",
    					autoHeight: true,
    					lazyLoad: "nearby"
    				}, // autoWidth: true,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0 = new Magic_button({
    			props: {
    				href: "#",
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new Magic_button({
    			props: {
    				href: "#",
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*loadTwitterWidget*/ ctx[0] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			meta = element("meta");
    			link0 = element("link");
    			link1 = element("link");
    			link2 = element("link");
    			link3 = element("link");
    			link4 = element("link");
    			script = element("script");
    			t0 = space();
    			img0 = element("img");
    			t1 = space();
    			img1 = element("img");
    			t2 = space();
    			div8 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t3 = space();
    			div1 = element("div");
    			img2 = element("img");
    			t4 = space();
    			img3 = element("img");
    			t5 = space();
    			img4 = element("img");
    			t6 = space();
    			img5 = element("img");
    			t7 = space();
    			img6 = element("img");
    			t8 = space();
    			div7 = element("div");
    			section0 = element("section");
    			h1 = element("h1");
    			t9 = text$1("");
    			wbr0 = element("wbr");
    			t10 = text$1("");
    			wbr1 = element("wbr");
    			t11 = text$1("");
    			br = element("br");
    			t12 = text$1("\n        ");
    			wbr2 = element("wbr");
    			t13 = text$1("");
    			wbr3 = element("wbr");
    			t14 = text$1("");
    			t15 = space();
    			section1 = element("section");
    			h20 = element("h2");
    			h20.textContent = "MOVIE";
    			t17 = space();
    			div3 = element("div");
    			create_component(yframe.$$.fragment);
    			t18 = space();
    			section2 = element("section");
    			h21 = element("h2");
    			h21.textContent = "PICTURES";
    			t20 = space();
    			create_component(splide.$$.fragment);
    			t21 = space();
    			p0 = element("p");
    			p0.textContent = "";
    			t23 = space();
    			section3 = element("section");
    			h22 = element("h2");
    			h22.textContent = "STEAM";
    			t25 = space();
    			p1 = element("p");
    			p1.textContent = "";
    			t27 = space();
    			create_component(button0.$$.fragment);
    			t28 = space();
    			section4 = element("section");
    			h23 = element("h2");
    			h23.textContent = "DISCORD";
    			t30 = space();
    			p2 = element("p");
    			p2.textContent = "Discord";
    			t32 = space();
    			create_component(button1.$$.fragment);
    			t33 = space();
    			section5 = element("section");
    			a0 = element("a");
    			a0.textContent = "";
    			t35 = space();
    			if (if_block) if_block.c();
    			t36 = space();
    			div6 = element("div");
    			a1 = element("a");
    			svg0 = svg_element("svg");
    			use0 = svg_element("use");
    			t37 = space();
    			div4 = element("div");
    			div4.textContent = "Steam";
    			t39 = space();
    			a2 = element("a");
    			svg1 = svg_element("svg");
    			use1 = svg_element("use");
    			t40 = space();
    			div5 = element("div");
    			div5.textContent = "Discord";
    			attr_dev(meta, "charset", "UTF-8");
    			add_location(meta, file$2, 70, 2, 1997);
    			document_1.title = " - ";
    			attr_dev(link0, "rel", "preconnect");
    			attr_dev(link0, "href", "https://fonts.googleapis.com");
    			add_location(link0, file$2, 72, 2, 2060);
    			attr_dev(link1, "rel", "preconnect");
    			attr_dev(link1, "href", "https://fonts.gstatic.com");
    			attr_dev(link1, "crossorigin", "");
    			add_location(link1, file$2, 73, 2, 2124);
    			attr_dev(link2, "rel", "preconnect");
    			attr_dev(link2, "href", "https://p.typekit.net/");
    			add_location(link2, file$2, 74, 2, 2197);
    			attr_dev(link3, "href", "https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap");
    			attr_dev(link3, "rel", "stylesheet");
    			add_location(link3, file$2, 75, 2, 2255);
    			attr_dev(link4, "rel", "stylesheet");
    			attr_dev(link4, "href", "https://use.typekit.net/lkm8uks.css");
    			add_location(link4, file$2, 79, 2, 2380);
    			script.async = true;
    			if (!src_url_equal(script.src, script_src_value = "https://platform.twitter.com/widgets.js")) attr_dev(script, "src", script_src_value);
    			attr_dev(script, "charset", "utf-8");
    			add_location(script, file$2, 80, 2, 2451);
    			if (!src_url_equal(img0.src, img0_src_value = "/img/magic-bg.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "");
    			attr_dev(img0, "class", "background svelte-s2ak5w");
    			add_location(img0, file$2, 87, 0, 2568);
    			if (!src_url_equal(img1.src, img1_src_value = "/img/ssm-logo-landscape-white.svg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "");
    			attr_dev(img1, "class", "header_logo_magic svelte-s2ak5w");
    			add_location(img1, file$2, 88, 0, 2626);
    			attr_dev(div0, "class", "logo-bg svelte-s2ak5w");
    			add_location(div0, file$2, 96, 4, 2757);
    			if (!src_url_equal(img2.src, img2_src_value = "/img/magic-c3.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "");
    			attr_dev(img2, "class", "c3 character svelte-s2ak5w");
    			add_location(img2, file$2, 98, 6, 2820);
    			if (!src_url_equal(img3.src, img3_src_value = "/img/magic-c4.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "");
    			attr_dev(img3, "class", "c4 character svelte-s2ak5w");
    			add_location(img3, file$2, 99, 6, 2886);
    			if (!src_url_equal(img4.src, img4_src_value = "/img/magic-c1.png")) attr_dev(img4, "src", img4_src_value);
    			attr_dev(img4, "alt", "");
    			attr_dev(img4, "class", "c1 character svelte-s2ak5w");
    			add_location(img4, file$2, 100, 6, 2952);
    			if (!src_url_equal(img5.src, img5_src_value = "/img/magic-c2.png")) attr_dev(img5, "src", img5_src_value);
    			attr_dev(img5, "alt", "");
    			attr_dev(img5, "class", "c2 character svelte-s2ak5w");
    			add_location(img5, file$2, 101, 6, 3018);
    			if (!src_url_equal(img6.src, img6_src_value = "/img/magic-logo.png")) attr_dev(img6, "src", img6_src_value);
    			attr_dev(img6, "alt", "");
    			attr_dev(img6, "class", "logo svelte-s2ak5w");
    			add_location(img6, file$2, 102, 6, 3084);
    			attr_dev(div1, "class", "characters svelte-s2ak5w");
    			add_location(div1, file$2, 97, 4, 2789);
    			attr_dev(div2, "class", "hero svelte-s2ak5w");
    			add_location(div2, file$2, 95, 2, 2734);
    			add_location(wbr0, file$2, 110, 13, 3218);
    			add_location(wbr1, file$2, 110, 22, 3227);
    			add_location(br, file$2, 110, 31, 3236);
    			add_location(wbr2, file$2, 111, 12, 3255);
    			add_location(wbr3, file$2, 111, 24, 3267);
    			attr_dev(h1, "class", "svelte-s2ak5w");
    			add_location(h1, file$2, 109, 6, 3200);
    			attr_dev(section0, "class", "svelte-s2ak5w");
    			add_location(section0, file$2, 108, 4, 3184);
    			attr_dev(h20, "class", "svelte-s2ak5w");
    			add_location(h20, file$2, 116, 6, 3344);
    			attr_dev(div3, "class", "youtube-wrapper svelte-s2ak5w");
    			add_location(div3, file$2, 117, 6, 3365);
    			attr_dev(section1, "class", "youtube svelte-s2ak5w");
    			add_location(section1, file$2, 115, 4, 3312);
    			attr_dev(h21, "class", "svelte-s2ak5w");
    			add_location(h21, file$2, 123, 6, 3493);
    			add_location(p0, file$2, 198, 6, 5331);
    			attr_dev(section2, "class", "svelte-s2ak5w");
    			add_location(section2, file$2, 122, 4, 3477);
    			attr_dev(h22, "class", "svelte-s2ak5w");
    			add_location(h22, file$2, 201, 6, 5387);
    			add_location(p1, file$2, 202, 6, 5408);
    			attr_dev(section3, "class", "svelte-s2ak5w");
    			add_location(section3, file$2, 200, 4, 5371);
    			attr_dev(h23, "class", "svelte-s2ak5w");
    			add_location(h23, file$2, 206, 6, 5516);
    			add_location(p2, file$2, 207, 6, 5539);
    			attr_dev(section4, "class", "discord svelte-s2ak5w");
    			add_location(section4, file$2, 205, 4, 5484);
    			attr_dev(a0, "class", "twitter-timeline");
    			attr_dev(a0, "data-width", "400");
    			attr_dev(a0, "data-height", "600");
    			attr_dev(a0, "data-theme", "light");
    			attr_dev(a0, "href", "https://twitter.com/necromance_chan?ref_src=twsrc%5Etfw");
    			add_location(a0, file$2, 220, 6, 5884);
    			attr_dev(section5, "class", "twitter svelte-s2ak5w");
    			add_location(section5, file$2, 219, 4, 5852);
    			xlink_attr(use0, "xlink:href", "/img/steam.svg#shape");
    			add_location(use0, file$2, 246, 10, 6559);
    			attr_dev(svg0, "width", "65");
    			attr_dev(svg0, "height", "65");
    			attr_dev(svg0, "viewBox", "0 0 65 65");
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "fill", "#fff");
    			attr_dev(svg0, "class", "svelte-s2ak5w");
    			add_location(svg0, file$2, 239, 8, 6394);
    			attr_dev(div4, "class", "theme svelte-s2ak5w");
    			add_location(div4, file$2, 248, 8, 6624);
    			attr_dev(a1, "class", "steam svelte-s2ak5w");
    			attr_dev(a1, "href", "//steam.com");
    			add_location(a1, file$2, 238, 6, 6349);
    			xlink_attr(use1, "xlink:href", "/img/discord.svg#shape");
    			add_location(use1, file$2, 258, 10, 6886);
    			attr_dev(svg1, "width", "27");
    			attr_dev(svg1, "height", "21");
    			attr_dev(svg1, "viewBox", "0 0 27 21");
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "fill", "#fff");
    			attr_dev(svg1, "class", "svelte-s2ak5w");
    			add_location(svg1, file$2, 251, 8, 6721);
    			attr_dev(div5, "class", "theme svelte-s2ak5w");
    			add_location(div5, file$2, 260, 8, 6953);
    			attr_dev(a2, "class", "discord svelte-s2ak5w");
    			attr_dev(a2, "href", "//discord.com");
    			add_location(a2, file$2, 250, 6, 6672);
    			attr_dev(div6, "class", "bottom-stick svelte-s2ak5w");
    			add_location(div6, file$2, 237, 4, 6316);
    			attr_dev(div7, "class", "dim svelte-s2ak5w");
    			add_location(div7, file$2, 107, 2, 3162);
    			attr_dev(div8, "class", "wrapper svelte-s2ak5w");
    			add_location(div8, file$2, 93, 0, 2707);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			append_dev(document_1.head, meta);
    			append_dev(document_1.head, link0);
    			append_dev(document_1.head, link1);
    			append_dev(document_1.head, link2);
    			append_dev(document_1.head, link3);
    			append_dev(document_1.head, link4);
    			append_dev(document_1.head, script);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, img0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, img1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, img2);
    			append_dev(div1, t4);
    			append_dev(div1, img3);
    			append_dev(div1, t5);
    			append_dev(div1, img4);
    			append_dev(div1, t6);
    			append_dev(div1, img5);
    			append_dev(div1, t7);
    			append_dev(div1, img6);
    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			append_dev(div7, section0);
    			append_dev(section0, h1);
    			append_dev(h1, t9);
    			append_dev(h1, wbr0);
    			append_dev(h1, t10);
    			append_dev(h1, wbr1);
    			append_dev(h1, t11);
    			append_dev(h1, br);
    			append_dev(h1, t12);
    			append_dev(h1, wbr2);
    			append_dev(h1, t13);
    			append_dev(h1, wbr3);
    			append_dev(h1, t14);
    			append_dev(div7, t15);
    			append_dev(div7, section1);
    			append_dev(section1, h20);
    			append_dev(section1, t17);
    			append_dev(section1, div3);
    			mount_component(yframe, div3, null);
    			append_dev(div7, t18);
    			append_dev(div7, section2);
    			append_dev(section2, h21);
    			append_dev(section2, t20);
    			mount_component(splide, section2, null);
    			append_dev(section2, t21);
    			append_dev(section2, p0);
    			append_dev(div7, t23);
    			append_dev(div7, section3);
    			append_dev(section3, h22);
    			append_dev(section3, t25);
    			append_dev(section3, p1);
    			append_dev(section3, t27);
    			mount_component(button0, section3, null);
    			append_dev(div7, t28);
    			append_dev(div7, section4);
    			append_dev(section4, h23);
    			append_dev(section4, t30);
    			append_dev(section4, p2);
    			append_dev(section4, t32);
    			mount_component(button1, section4, null);
    			append_dev(div7, t33);
    			append_dev(div7, section5);
    			append_dev(section5, a0);
    			append_dev(section5, t35);
    			if (if_block) if_block.m(section5, null);
    			append_dev(div7, t36);
    			append_dev(div7, div6);
    			append_dev(div6, a1);
    			append_dev(a1, svg0);
    			append_dev(svg0, use0);
    			append_dev(a1, t37);
    			append_dev(a1, div4);
    			append_dev(div6, t39);
    			append_dev(div6, a2);
    			append_dev(a2, svg1);
    			append_dev(svg1, use1);
    			append_dev(a2, t40);
    			append_dev(a2, div5);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const splide_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				splide_changes.$$scope = { dirty, ctx };
    			}

    			splide.$set(splide_changes);
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (/*loadTwitterWidget*/ ctx[0]) {
    				if (if_block) ; else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(section5, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(yframe.$$.fragment, local);
    			transition_in(splide.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(yframe.$$.fragment, local);
    			transition_out(splide.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			detach_dev(meta);
    			detach_dev(link0);
    			detach_dev(link1);
    			detach_dev(link2);
    			detach_dev(link3);
    			detach_dev(link4);
    			detach_dev(script);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(img0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(img1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div8);
    			destroy_component(yframe);
    			destroy_component(splide);
    			destroy_component(button0);
    			destroy_component(button1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Magicchaos', slots, []);

    	let footerContents = {
    		copyright: ["&copy; 2022", "HIBIKI CUBE", ""],
    		codeLicense: {
    			license: "mpl-2.0",
    			linkLabel: "GitHub",
    			url: "https://github.com/HIBIKI-CUBE/superstarmine-web"
    		},
    		assetsLicense: { ccType: "by-nd" }
    	};

    	let loadTwitterWidget = false;

    	onMount(() => {
    		(d => {
    			var config = {
    					kitId: "egn6fhp",
    					scriptTimeout: 3000,
    					async: !0
    				},
    				h = d.documentElement,
    				t = setTimeout(
    					() => {
    						h.className = h.className.replace(/\bwf-loading\b/g, "") + " wf-inactive";
    					},
    					config.scriptTimeout
    				),
    				tk = d.createElement("script"),
    				f = !1,
    				s = d.getElementsByTagName("script")[0],
    				a;

    			h.className += " wf-loading";
    			tk.src = "https://use.typekit.net/" + config.kitId + ".js";
    			tk.async = !0;

    			tk.onload = tk.onreadystatechange = function () {
    				a = this.readyState;
    				if (f || a && a != "complete" && a != "loaded") return;
    				f = !0;
    				clearTimeout(t);

    				try {
    					Typekit.load(config);
    				} catch(e) {
    					
    				}
    			};

    			s.parentNode.insertBefore(tk, s);
    		})(document);

    		const twitterObserver = new IntersectionObserver(e => {
    				if (e[0].isIntersecting && !loadTwitterWidget) {
    					$$invalidate(0, loadTwitterWidget = true);
    					twitterObserver.unobserve(document.querySelector(".twitter-timeline"));
    				}
    			},
    		{ rootMargin: "50%" });

    		twitterObserver.observe(document.querySelector(".twitter-timeline"));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Magicchaos> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		Yframe: Youtube_iframe,
    		Button: Magic_button,
    		Splide: Splide_1,
    		SplideSlide,
    		Footer,
    		footerContents,
    		loadTwitterWidget
    	});

    	$$self.$inject_state = $$props => {
    		if ('footerContents' in $$props) footerContents = $$props.footerContents;
    		if ('loadTwitterWidget' in $$props) $$invalidate(0, loadTwitterWidget = $$props.loadTwitterWidget);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadTwitterWidget];
    }

    class Magicchaos extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Magicchaos",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src/pages/notfound.svelte generated by Svelte v3.43.0 */

    const file$1 = "src/pages/notfound.svelte";

    function create_fragment$1(ctx) {
    	let h1;
    	let t1;
    	let p;
    	let t2_value = Math.round(/*eta*/ ctx[0] / 1000) + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "";
    			t1 = space();
    			p = element("p");
    			t2 = text$1(t2_value);
    			t3 = text$1("");
    			add_location(h1, file$1, 15, 0, 302);
    			add_location(p, file$1, 16, 0, 330);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, p, anchor);
    			append_dev(p, t2);
    			append_dev(p, t3);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*eta*/ 1 && t2_value !== (t2_value = Math.round(/*eta*/ ctx[0] / 1000) + "")) set_data_dev(t2, t2_value);
    		},
    		i: noop$1,
    		o: noop$1,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Notfound', slots, []);
    	let last = performance.now();
    	let eta = 5000;

    	const cowntdown = time => {
    		$$invalidate(0, eta -= time - last);
    		last = time;

    		if (eta <= 500) {
    			location.replace(location.origin);
    			return;
    		}

    		requestAnimationFrame(cowntdown);
    	};

    	requestAnimationFrame(cowntdown);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Notfound> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ last, eta, cowntdown });

    	$$self.$inject_state = $$props => {
    		if ('last' in $$props) last = $$props.last;
    		if ('eta' in $$props) $$invalidate(0, eta = $$props.eta);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [eta];
    }

    class Notfound extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Notfound",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src/App.svelte generated by Svelte v3.43.0 */

    const { console: console_1 } = globals;
    const file = "src/App.svelte";

    // (49:2) {#if loadAnalytics}
    function create_if_block(ctx) {
    	let link;
    	let t;
    	let script;
    	let script_src_value;

    	const block = {
    		c: function create() {
    			link = element("link");
    			t = space();
    			script = element("script");
    			attr_dev(link, "rel", "preconnect");
    			attr_dev(link, "href", "https://www.google-analytics.com");
    			add_location(link, file, 49, 4, 1658);
    			script.async = true;
    			if (!src_url_equal(script.src, script_src_value = "https://www.googletagmanager.com/gtag/js?id=UA-158103398-1")) attr_dev(script, "src", script_src_value);
    			add_location(script, file, 50, 4, 1726);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, link, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, script, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(link);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(script);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(49:2) {#if loadAnalytics}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let if_block_anchor;
    	let t;
    	let router;
    	let current;
    	let if_block = /*loadAnalytics*/ ctx[0] && create_if_block(ctx);

    	router = new Router({
    			props: { routes: /*routes*/ ctx[1] },
    			$$inline: true
    		});

    	router.$on("routeLoaded", /*analyticsLoader*/ ctx[2]);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty$1();
    			t = space();
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(document.head, null);
    			append_dev(document.head, if_block_anchor);
    			insert_dev(target, t, anchor);
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: noop$1,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			detach_dev(if_block_anchor);
    			if (detaching) detach_dev(t);
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $sync;
    	validate_store(sync, 'sync');
    	component_subscribe($$self, sync, $$value => $$invalidate(3, $sync = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	let loadAnalytics = location.hostname != 'localhost';

    	const routes = {
    		'/': Pages,
    		'/necromance/': Newcromance,
    		'/magicchaos/': Magicchaos,
    		'*': Notfound
    	};

    	function analyticsLoader() {
    		if (loadAnalytics) {
    			window.dataLayer = window.dataLayer || [];

    			function gtag() {
    				dataLayer.push(arguments);
    			}

    			gtag('js', new Date());

    			gtag('config', 'UA-158103398-1', {
    				'page_path': location.pathname + location.hash
    			});
    		}
    	}

    	set_store_value(sync, $sync.standardWidth = null, $sync);
    	const defautlStandardWidth = globalSettings.standardWidths[globalSettings.standardWidths.findIndex(v => v.mediaQuery == 'default')].value;

    	globalSettings.standardWidths.forEach((v, i, array) => {
    		if (v.mediaQuery && v.mediaQuery != 'default') {
    			let media = matchMedia(`(${v.mediaQuery})`);

    			try {
    				media.addEventListener('change', e => set_store_value(sync, $sync.standardWidth = e.matches ? v.value : defautlStandardWidth, $sync));
    			} catch(e1) {
    				try {
    					media.addEventListener(e => set_store_value(sync, $sync.standardWidth = e.matches ? v.value : defautlStandardWidth, $sync));
    				} catch(e2) {
    					console.error(e2);
    				}
    			}
    		}

    		if (i == array.length - 1 && !$sync.standardWidth) set_store_value(sync, $sync.standardWidth = defautlStandardWidth, $sync);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Router,
    		globalSettings,
    		sync,
    		Index: Pages,
    		Necromance: Newcromance,
    		Magicchaos,
    		NotFound: Notfound,
    		loadAnalytics,
    		routes,
    		analyticsLoader,
    		defautlStandardWidth,
    		$sync
    	});

    	$$self.$inject_state = $$props => {
    		if ('loadAnalytics' in $$props) $$invalidate(0, loadAnalytics = $$props.loadAnalytics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [loadAnalytics, routes, analyticsLoader];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
      target: document.body,
      props: {
      }
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
